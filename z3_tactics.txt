"combinators:
- (and-then <tactic>+) executes the given tactics sequentially.
- (or-else <tactic>+) tries the given tactics in sequence until one of them succeeds (i.e., the first that doesn't fail).
- (par-or <tactic>+) executes the given tactics in parallel until one of them succeeds (i.e., the first that doesn't fail).
- (par-then <tactic1> <tactic2>) executes tactic1 and then tactic2 to every subgoal produced by tactic1. All subgoals are processed in parallel.
- (try-for <tactic> <num>) executes the given tactic for at most <num> milliseconds, it fails if the execution takes more than <num> milliseconds.
- (if <probe> <tactic> <tactic>) if <probe> evaluates to true, then execute the first tactic. Otherwise execute the second.
- (when <probe> <tactic>) shorthand for (if <probe> <tactic> skip).
- (fail-if <probe>) fail if <probe> evaluates to true.
- (using-params <tactic> <attribute>*) executes the given tactic using the given attributes, where <attribute> ::= <keyword> <value>. ! is a syntax sugar for using-params.
builtin tactics:
- ackermannize_bv A tactic for performing full Ackermannization on bv instances.
    div0_ackermann_limit (unsigned int) a bound for number of congruence Ackermann lemmas for div0 modelling (default: 1000)
- subpaving tactic for testing subpaving module.
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    epsilon (unsigned int) (default: 20) value k s.t. a new lower (upper) bound for x is propagated only new-lower(x) > lower(k) + 1/k * max(min(upper(x) - lower(x), |lower|), 1) (new-upper(x) < upper(x) - 1/k * max(min(upper(x) - lower(x), |lower|), 1)). If k = 0, then this restriction is ignored.
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    max_bound (unsigned int) (default 10) value k s.t. a new upper (lower) bound for x is propagated only if upper(x) > -10^k or lower(x) = -oo (lower(x) < 10^k or upper(x) = oo)
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_depth (unsigned int) (default: 128) maximum depth of the subpaving tree.
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    max_nodes (unsigned int) (default: 8192) maximum number of nodes in the subpaving tree.
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    nth_root_precision (unsigned int) (default 8192) value k s.t. 1/k is the precision for computing the nth root in the subpaving module.
    numeral (symbol) (default: mpq) options: mpq, mpf, hwf, mpff, mpfx.
    print_nodes (bool) (default: false) display subpaving tree leaves.
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    rewrite_patterns (bool) rewrite patterns. (default: false)
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
- horn apply tactic for horn clauses.
    bmc.linear_unrolling_depth (unsigned int) Maximal level to explore (default: 4294967295)
    ctrl_c (bool) enable interrupts from ctrl-c (default: true)
    datalog.all_or_nothing_deltas (bool) compile rules so that it is enough for the delta relation in union and widening operations to determine only whether the updated relation was modified or not (default: false)
    datalog.check_relation (symbol) name of default relation to check. operations on the default relation will be verified using SMT solving (default: null)
    datalog.compile_with_widening (bool) widening will be used to compile recursive rules (default: false)
    datalog.dbg_fpr_nonempty_relation_signature (bool) if true, finite_product_relation will attempt to avoid creating inner relation with empty signature by putting in half of the table columns, if it would have been empty otherwise (default: false)
    datalog.default_relation (symbol) default relation implementation: external_relation, pentagon (default: pentagon)
    datalog.default_table (symbol) default table implementation: sparse, hashtable, bitvector, interval (default: sparse)
    datalog.default_table_checked (bool) if true, the default table will be default_table inside a wrapper that checks that its results are the same as of default_table_checker table (default: false)
    datalog.default_table_checker (symbol) see default_table_checked (default: null)
    datalog.explanations_on_relation_level (bool) if true, explanations are generated as history of each relation, rather than per fact (generate_explanations must be set to true for this option to have any effect) (default: false)
    datalog.generate_explanations (bool) produce explanations for produced facts when using the datalog engine (default: false)
    datalog.initial_restart_timeout (unsigned int) length of saturation run before the first restart (in ms), zero means no restarts (default: 0)
    datalog.magic_sets_for_queries (bool) magic set transformation will be used for queries (default: false)
    datalog.output_profile (bool) determines whether profile information should be output when outputting Datalog rules or instructions (default: false)
    datalog.print.tuples (bool) determines whether tuples for output predicates should be output (default: true)
    datalog.profile_timeout_milliseconds (unsigned int) instructions and rules that took less than the threshold will not be printed when printed the instruction/rule list (default: 0)
    datalog.similarity_compressor (bool) rules that differ only in values of constants will be merged into a single rule (default: true)
    datalog.similarity_compressor_threshold (unsigned int) if similarity_compressor is on, this value determines how many similar rules there must be in order for them to be merged (default: 11)
    datalog.subsumption (bool) if true, removes/filters predicates with total transitions (default: true)
    datalog.timeout (unsigned int) Time limit used for saturation (default: 0)
    datalog.unbound_compressor (bool) auxiliary relations will be introduced to avoid unbound variables in rule heads (default: true)
    datalog.use_map_names (bool) use names from map files when displaying tuples (default: true)
    engine (symbol) Select: auto-config, datalog, bmc, spacer (default: auto-config)
    generate_proof_trace (bool) trace for 'sat' answer as proof object (default: false)
    print_aig (symbol) Dump clauses in AIG text format (AAG) to the given file name (default: )
    print_answer (bool) print answer instance(s) to query (default: false)
    print_boogie_certificate (bool) print certificate for reachability or non-reachability using a format understood by Boogie (default: false)
    print_certificate (bool) print certificate for reachability or non-reachability (default: false)
    print_fixedpoint_extensions (bool) use SMT-LIB2 fixedpoint extensions, instead of pure SMT2, when printing rules (default: true)
    print_low_level_smt2 (bool) use (faster) low-level SMT2 printer (the printer is scalable but the result may not be as readable) (default: false)
    print_statistics (bool) print statistics (default: false)
    print_with_variable_declarations (bool) use variable declarations when displaying rules (instead of attempting to use original names) (default: true)
    spacer.arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 2)
    spacer.blast_term_ite_inflation (unsigned int) Maximum inflation for non-Boolean ite-terms expansion: 0 (none), k (multiplicative) (default: 3)
    spacer.ctp (bool) Enable counterexample-to-pushing (default: true)
    spacer.dump_benchmarks (bool) Dump SMT queries as benchmarks (default: false)
    spacer.dump_threshold (double) Threshold in seconds on dumping benchmarks (default: 5.0)
    spacer.elim_aux (bool) Eliminate auxiliary variables in reachability facts (default: true)
    spacer.eq_prop (bool) Enable equality and bound propagation in arithmetic (default: true)
    spacer.gpdr (bool) Use GPDR solving strategy for non-linear CHC (default: false)
    spacer.gpdr.bfs (bool) Use BFS exploration strategy for expanding model search (default: true)
    spacer.ground_pobs (bool) Ground pobs by using values from a model (default: true)
    spacer.iuc (unsigned int) 0 = use old implementation of unsat-core-generation, 1 = use new implementation of IUC generation, 2 = use new implementation of IUC + min-cut optimization (default: 1)
    spacer.iuc.arith (unsigned int) 0 = use simple Farkas plugin, 1 = use simple Farkas plugin with constant from other partition (like old unsat-core-generation),2 = use Gaussian elimination optimization (broken), 3 = use additive IUC plugin (default: 1)
    spacer.iuc.debug_proof (bool) prints proof used by unsat-core-learner for debugging purposes (debugging) (default: false)
    spacer.iuc.old_hyp_reducer (bool) use old hyp reducer instead of new implementation, for debugging only (default: false)
    spacer.iuc.print_farkas_stats (bool) prints for each proof how many Farkas lemmas it contains and how many of these participate in the cut (for debugging) (default: false)
    spacer.iuc.split_farkas_literals (bool) Split Farkas literals (default: false)
    spacer.keep_proxy (bool) keep proxy variables (internal parameter) (default: true)
    spacer.logic (symbol) SMT-LIB logic to configure internal SMT solvers (default: )
    spacer.max_level (unsigned int) Maximum level to explore (default: 4294967295)
    spacer.max_num_contexts (unsigned int) maximal number of contexts to create (default: 500)
    spacer.mbqi (bool) Enable mbqi (default: true)
    spacer.min_level (unsigned int) Minimal level to explore (default: 0)
    spacer.native_mbp (bool) Use native mbp of Z3 (default: true)
    spacer.order_children (unsigned int) SPACER: order of enqueuing children in non-linear rules : 0 (original), 1 (reverse), 2 (random) (default: 0)
    spacer.p3.share_invariants (bool) Share invariants lemmas (default: false)
    spacer.p3.share_lemmas (bool) Share frame lemmas (default: false)
    spacer.print_json (symbol) Print pobs tree in JSON format to a given file (default: )
    spacer.propagate (bool) Enable propagate/pushing phase (default: true)
    spacer.push_pob (bool) push blocked pobs to higher level (default: false)
    spacer.push_pob_max_depth (unsigned int) Maximum depth at which push_pob is enabled (default: 4294967295)
    spacer.q3 (bool) Allow quantified lemmas in frames (default: true)
    spacer.q3.instantiate (bool) Instantiate quantified lemmas (default: true)
    spacer.q3.qgen.normalize (bool) normalize cube before quantified generalization (default: true)
    spacer.q3.use_qgen (bool) use quantified lemma generalizer (default: false)
    spacer.random_seed (unsigned int) Random seed to be used by SMT solver (default: 0)
    spacer.reach_dnf (bool) Restrict reachability facts to DNF (default: true)
    spacer.reset_pob_queue (bool) SPACER: reset pob obligation queue when entering a new level (default: true)
    spacer.restart_initial_threshold (unsigned int) Initial threshold for restarts (default: 10)
    spacer.restarts (bool) Enable resetting obligation queue (default: false)
    spacer.simplify_lemmas_post (bool) simplify derived lemmas after inductive propagation (default: false)
    spacer.simplify_lemmas_pre (bool) simplify derived lemmas before inductive propagation (default: false)
    spacer.simplify_pob (bool) simplify pobs by removing redundant constraints (default: false)
    spacer.trace_file (symbol) Log file for progress events (default: )
    spacer.use_array_eq_generalizer (bool) SPACER: attempt to generalize lemmas with array equalities (default: true)
    spacer.use_bg_invs (bool) Enable external background invariants (default: false)
    spacer.use_derivations (bool) SPACER: using derivation mechanism to cache intermediate results for non-linear rules (default: true)
    spacer.use_euf_gen (bool) Generalize lemmas and pobs using implied equalities (default: false)
    spacer.use_inc_clause (bool) Use incremental clause to represent trans (default: true)
    spacer.use_inductive_generalizer (bool) generalize lemmas using induction strengthening (default: true)
    spacer.use_lemma_as_cti (bool) SPACER: use a lemma instead of a CTI in flexible_trace (default: false)
    spacer.use_lim_num_gen (bool) Enable limit numbers generalizer to get smaller numbers (default: false)
    spacer.validate_lemmas (bool) Validate each lemma after generalization (default: false)
    spacer.weak_abs (bool) Weak abstraction (default: true)
    tab.selection (symbol) selection method for tabular strategy: weight (default), first, var-use (default: weight)
    timeout (unsigned int) (default: infty) timeout in milliseconds. (default: 4294967295)
    validate (bool) validate result (by proof checking or model checking) (default: false)
    xform.array_blast (bool) try to eliminate local array terms using Ackermannization -- some array terms may remain (default: false)
    xform.array_blast_full (bool) eliminate all local array variables by QE (default: false)
    xform.bit_blast (bool) bit-blast bit-vectors (default: false)
    xform.coalesce_rules (bool) coalesce rules (default: false)
    xform.coi (bool) use cone of influence simplification (default: true)
    xform.compress_unbound (bool) compress tails with unbound variables (default: true)
    xform.elim_term_ite (bool) Eliminate term-ite expressions (default: false)
    xform.elim_term_ite.inflation (unsigned int) Maximum inflation for non-Boolean ite-terms blasting: 0 (none), k (multiplicative) (default: 3)
    xform.fix_unbound_vars (bool) fix unbound variables in tail (default: false)
    xform.inline_eager (bool) try eager inlining of rules (default: true)
    xform.inline_linear (bool) try linear inlining method (default: true)
    xform.inline_linear_branch (bool) try linear inlining method with potential expansion (default: false)
    xform.instantiate_arrays (bool) Transforms P(a) into P(i, a[i] a) (default: false)
    xform.instantiate_arrays.enforce (bool) Transforms P(a) into P(i, a[i]), discards a from predicate (default: false)
    xform.instantiate_arrays.nb_quantifier (unsigned int) Gives the number of quantifiers per array (default: 1)
    xform.instantiate_arrays.slice_technique (symbol) <no-slicing>=> GetId(i) = i, <smash> => GetId(i) = true (default: no-slicing)
    xform.instantiate_quantifiers (bool) instantiate quantified Horn clauses using E-matching heuristic (default: false)
    xform.magic (bool) perform symbolic magic set transformation (default: false)
    xform.quantify_arrays (bool) create quantified Horn clauses from clauses with arrays (default: false)
    xform.scale (bool) add scaling variable to linear real arithmetic clauses (default: false)
    xform.slice (bool) simplify clause set using slicing (default: true)
    xform.subsumption_checker (bool) Enable subsumption checker (no support for model conversion) (default: true)
    xform.tail_simplifier_pve (bool) propagate_variable_equivalences (default: true)
    xform.transform_arrays (bool) Rewrites arrays equalities and applies select over store (default: false)
    xform.unfold_rules (unsigned int) unfold rules statically using iterative squaring (default: 0)
- horn-simplify simplify horn clauses.
    bmc.linear_unrolling_depth (unsigned int) Maximal level to explore (default: 4294967295)
    ctrl_c (bool) enable interrupts from ctrl-c (default: true)
    datalog.all_or_nothing_deltas (bool) compile rules so that it is enough for the delta relation in union and widening operations to determine only whether the updated relation was modified or not (default: false)
    datalog.check_relation (symbol) name of default relation to check. operations on the default relation will be verified using SMT solving (default: null)
    datalog.compile_with_widening (bool) widening will be used to compile recursive rules (default: false)
    datalog.dbg_fpr_nonempty_relation_signature (bool) if true, finite_product_relation will attempt to avoid creating inner relation with empty signature by putting in half of the table columns, if it would have been empty otherwise (default: false)
    datalog.default_relation (symbol) default relation implementation: external_relation, pentagon (default: pentagon)
    datalog.default_table (symbol) default table implementation: sparse, hashtable, bitvector, interval (default: sparse)
    datalog.default_table_checked (bool) if true, the default table will be default_table inside a wrapper that checks that its results are the same as of default_table_checker table (default: false)
    datalog.default_table_checker (symbol) see default_table_checked (default: null)
    datalog.explanations_on_relation_level (bool) if true, explanations are generated as history of each relation, rather than per fact (generate_explanations must be set to true for this option to have any effect) (default: false)
    datalog.generate_explanations (bool) produce explanations for produced facts when using the datalog engine (default: false)
    datalog.initial_restart_timeout (unsigned int) length of saturation run before the first restart (in ms), zero means no restarts (default: 0)
    datalog.magic_sets_for_queries (bool) magic set transformation will be used for queries (default: false)
    datalog.output_profile (bool) determines whether profile information should be output when outputting Datalog rules or instructions (default: false)
    datalog.print.tuples (bool) determines whether tuples for output predicates should be output (default: true)
    datalog.profile_timeout_milliseconds (unsigned int) instructions and rules that took less than the threshold will not be printed when printed the instruction/rule list (default: 0)
    datalog.similarity_compressor (bool) rules that differ only in values of constants will be merged into a single rule (default: true)
    datalog.similarity_compressor_threshold (unsigned int) if similarity_compressor is on, this value determines how many similar rules there must be in order for them to be merged (default: 11)
    datalog.subsumption (bool) if true, removes/filters predicates with total transitions (default: true)
    datalog.timeout (unsigned int) Time limit used for saturation (default: 0)
    datalog.unbound_compressor (bool) auxiliary relations will be introduced to avoid unbound variables in rule heads (default: true)
    datalog.use_map_names (bool) use names from map files when displaying tuples (default: true)
    engine (symbol) Select: auto-config, datalog, bmc, spacer (default: auto-config)
    generate_proof_trace (bool) trace for 'sat' answer as proof object (default: false)
    print_aig (symbol) Dump clauses in AIG text format (AAG) to the given file name (default: )
    print_answer (bool) print answer instance(s) to query (default: false)
    print_boogie_certificate (bool) print certificate for reachability or non-reachability using a format understood by Boogie (default: false)
    print_certificate (bool) print certificate for reachability or non-reachability (default: false)
    print_fixedpoint_extensions (bool) use SMT-LIB2 fixedpoint extensions, instead of pure SMT2, when printing rules (default: true)
    print_low_level_smt2 (bool) use (faster) low-level SMT2 printer (the printer is scalable but the result may not be as readable) (default: false)
    print_statistics (bool) print statistics (default: false)
    print_with_variable_declarations (bool) use variable declarations when displaying rules (instead of attempting to use original names) (default: true)
    spacer.arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 2)
    spacer.blast_term_ite_inflation (unsigned int) Maximum inflation for non-Boolean ite-terms expansion: 0 (none), k (multiplicative) (default: 3)
    spacer.ctp (bool) Enable counterexample-to-pushing (default: true)
    spacer.dump_benchmarks (bool) Dump SMT queries as benchmarks (default: false)
    spacer.dump_threshold (double) Threshold in seconds on dumping benchmarks (default: 5.0)
    spacer.elim_aux (bool) Eliminate auxiliary variables in reachability facts (default: true)
    spacer.eq_prop (bool) Enable equality and bound propagation in arithmetic (default: true)
    spacer.gpdr (bool) Use GPDR solving strategy for non-linear CHC (default: false)
    spacer.gpdr.bfs (bool) Use BFS exploration strategy for expanding model search (default: true)
    spacer.ground_pobs (bool) Ground pobs by using values from a model (default: true)
    spacer.iuc (unsigned int) 0 = use old implementation of unsat-core-generation, 1 = use new implementation of IUC generation, 2 = use new implementation of IUC + min-cut optimization (default: 1)
    spacer.iuc.arith (unsigned int) 0 = use simple Farkas plugin, 1 = use simple Farkas plugin with constant from other partition (like old unsat-core-generation),2 = use Gaussian elimination optimization (broken), 3 = use additive IUC plugin (default: 1)
    spacer.iuc.debug_proof (bool) prints proof used by unsat-core-learner for debugging purposes (debugging) (default: false)
    spacer.iuc.old_hyp_reducer (bool) use old hyp reducer instead of new implementation, for debugging only (default: false)
    spacer.iuc.print_farkas_stats (bool) prints for each proof how many Farkas lemmas it contains and how many of these participate in the cut (for debugging) (default: false)
    spacer.iuc.split_farkas_literals (bool) Split Farkas literals (default: false)
    spacer.keep_proxy (bool) keep proxy variables (internal parameter) (default: true)
    spacer.logic (symbol) SMT-LIB logic to configure internal SMT solvers (default: )
    spacer.max_level (unsigned int) Maximum level to explore (default: 4294967295)
    spacer.max_num_contexts (unsigned int) maximal number of contexts to create (default: 500)
    spacer.mbqi (bool) Enable mbqi (default: true)
    spacer.min_level (unsigned int) Minimal level to explore (default: 0)
    spacer.native_mbp (bool) Use native mbp of Z3 (default: true)
    spacer.order_children (unsigned int) SPACER: order of enqueuing children in non-linear rules : 0 (original), 1 (reverse), 2 (random) (default: 0)
    spacer.p3.share_invariants (bool) Share invariants lemmas (default: false)
    spacer.p3.share_lemmas (bool) Share frame lemmas (default: false)
    spacer.print_json (symbol) Print pobs tree in JSON format to a given file (default: )
    spacer.propagate (bool) Enable propagate/pushing phase (default: true)
    spacer.push_pob (bool) push blocked pobs to higher level (default: false)
    spacer.push_pob_max_depth (unsigned int) Maximum depth at which push_pob is enabled (default: 4294967295)
    spacer.q3 (bool) Allow quantified lemmas in frames (default: true)
    spacer.q3.instantiate (bool) Instantiate quantified lemmas (default: true)
    spacer.q3.qgen.normalize (bool) normalize cube before quantified generalization (default: true)
    spacer.q3.use_qgen (bool) use quantified lemma generalizer (default: false)
    spacer.random_seed (unsigned int) Random seed to be used by SMT solver (default: 0)
    spacer.reach_dnf (bool) Restrict reachability facts to DNF (default: true)
    spacer.reset_pob_queue (bool) SPACER: reset pob obligation queue when entering a new level (default: true)
    spacer.restart_initial_threshold (unsigned int) Initial threshold for restarts (default: 10)
    spacer.restarts (bool) Enable resetting obligation queue (default: false)
    spacer.simplify_lemmas_post (bool) simplify derived lemmas after inductive propagation (default: false)
    spacer.simplify_lemmas_pre (bool) simplify derived lemmas before inductive propagation (default: false)
    spacer.simplify_pob (bool) simplify pobs by removing redundant constraints (default: false)
    spacer.trace_file (symbol) Log file for progress events (default: )
    spacer.use_array_eq_generalizer (bool) SPACER: attempt to generalize lemmas with array equalities (default: true)
    spacer.use_bg_invs (bool) Enable external background invariants (default: false)
    spacer.use_derivations (bool) SPACER: using derivation mechanism to cache intermediate results for non-linear rules (default: true)
    spacer.use_euf_gen (bool) Generalize lemmas and pobs using implied equalities (default: false)
    spacer.use_inc_clause (bool) Use incremental clause to represent trans (default: true)
    spacer.use_inductive_generalizer (bool) generalize lemmas using induction strengthening (default: true)
    spacer.use_lemma_as_cti (bool) SPACER: use a lemma instead of a CTI in flexible_trace (default: false)
    spacer.use_lim_num_gen (bool) Enable limit numbers generalizer to get smaller numbers (default: false)
    spacer.validate_lemmas (bool) Validate each lemma after generalization (default: false)
    spacer.weak_abs (bool) Weak abstraction (default: true)
    tab.selection (symbol) selection method for tabular strategy: weight (default), first, var-use (default: weight)
    timeout (unsigned int) (default: infty) timeout in milliseconds. (default: 4294967295)
    validate (bool) validate result (by proof checking or model checking) (default: false)
    xform.array_blast (bool) try to eliminate local array terms using Ackermannization -- some array terms may remain (default: false)
    xform.array_blast_full (bool) eliminate all local array variables by QE (default: false)
    xform.bit_blast (bool) bit-blast bit-vectors (default: false)
    xform.coalesce_rules (bool) coalesce rules (default: false)
    xform.coi (bool) use cone of influence simplification (default: true)
    xform.compress_unbound (bool) compress tails with unbound variables (default: true)
    xform.elim_term_ite (bool) Eliminate term-ite expressions (default: false)
    xform.elim_term_ite.inflation (unsigned int) Maximum inflation for non-Boolean ite-terms blasting: 0 (none), k (multiplicative) (default: 3)
    xform.fix_unbound_vars (bool) fix unbound variables in tail (default: false)
    xform.inline_eager (bool) try eager inlining of rules (default: true)
    xform.inline_linear (bool) try linear inlining method (default: true)
    xform.inline_linear_branch (bool) try linear inlining method with potential expansion (default: false)
    xform.instantiate_arrays (bool) Transforms P(a) into P(i, a[i] a) (default: false)
    xform.instantiate_arrays.enforce (bool) Transforms P(a) into P(i, a[i]), discards a from predicate (default: false)
    xform.instantiate_arrays.nb_quantifier (unsigned int) Gives the number of quantifiers per array (default: 1)
    xform.instantiate_arrays.slice_technique (symbol) <no-slicing>=> GetId(i) = i, <smash> => GetId(i) = true (default: no-slicing)
    xform.instantiate_quantifiers (bool) instantiate quantified Horn clauses using E-matching heuristic (default: false)
    xform.magic (bool) perform symbolic magic set transformation (default: false)
    xform.quantify_arrays (bool) create quantified Horn clauses from clauses with arrays (default: false)
    xform.scale (bool) add scaling variable to linear real arithmetic clauses (default: false)
    xform.slice (bool) simplify clause set using slicing (default: true)
    xform.subsumption_checker (bool) Enable subsumption checker (no support for model conversion) (default: true)
    xform.tail_simplifier_pve (bool) propagate_variable_equivalences (default: true)
    xform.transform_arrays (bool) Rewrites arrays equalities and applies select over store (default: false)
    xform.unfold_rules (unsigned int) unfold rules statically using iterative squaring (default: 0)
- nlsat (try to) solve goal using a nonlinear arithmetic solver.
    check_lemmas (bool) check lemmas on the fly using an independent nlsat solver (default: false)
    factor (bool) (default: true) factor polynomials.
    factor_max_prime (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step (default: 31)
    factor_num_primes (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)'s. This parameter specify the maximum number of finite factorizations to be considered, before lifiting and searching (default: 1)
    factor_search_size (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space (default: 5000)
    inline_vars (bool) inline variables that can be isolated from equations (not supported in incremental mode) (default: false)
    lazy (unsigned int) how lazy the solver is. (default: 0)
    log_lemmas (bool) display lemmas as self-contained SMT formulas (default: false)
    max_conflicts (unsigned int) maximum number of conflicts. (default: 4294967295)
    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes.
    max_prime (unsigned int) (default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step.
    max_search_size (unsigned int) (default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space.
    min_mag (unsigned int) Z3 represents algebraic numbers using a (square-free) polynomial p and an isolating interval (which contains one and only one root of p). This interval may be refined during the computations. This parameter specifies whether to cache the value of a refined interval or not. It says the minimal size of an interval for caching purposes is 1/2^16 (default: 16)
    minimize_conflicts (bool) minimize conflicts (default: false)
    num_primes (unsigned int) (default: 1) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)'s. This parameter specify the maximum number of finite factorizations to be considered, before lifiting and searching.
    randomize (bool) randomize selection of a witness in nlsat. (default: true)
    reorder (bool) reorder variables. (default: true)
    seed (unsigned int) random seed. (default: 0)
    shuffle_vars (bool) use a random variable order. (default: false)
    simplify_conflicts (bool) simplify conflicts using equalities before resolving them in nlsat solver. (default: true)
    zero_accuracy (unsigned int) one of the most time-consuming operations in the real algebraic number module is determining the sign of a polynomial evaluated at a sample point with non-rational algebraic number values. Let k be the value of this option. If k is 0, Z3 uses precise computation. Otherwise, the result of a polynomial evaluation is considered to be 0 if Z3 can show it is inside the interval (-1/2^k, 1/2^k) (default: 0)
- qfnra-nlsat builtin strategy for solving QF_NRA problems using only nlsat.
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    check_lemmas (bool) check lemmas on the fly using an independent nlsat solver (default: false)
    common_patterns (bool) (default: true) minimize the number of auxiliary variables during CNF encoding by identifing commonly used patterns
    complete (bool) (default: true) add constraints to make sure that any interpretation of a underspecified arithmetic operators is a function. The result will include additional uninterpreted functions/constants: /0, div0, mod0, 0^0, neg-root
    context_solve (bool) (default: false) solve equalities under disjunctions.
    distributivity (bool) (default: true) minimize the number of auxiliary variables during CNF encoding by applying distributivity over unshared subformulas
    distributivity_blowup (unsigned int) (default: 32) maximum overhead for applying distributivity during CNF encoding
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_inverses (bool) (default: true) eliminate inverse trigonometric functions (asin, acos, atan).
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_root_objects (bool) (default: true) eliminate root objects.
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    factor (bool) (default: true) factor polynomials.
    factor_max_prime (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step (default: 31)
    factor_num_primes (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)'s. This parameter specify the maximum number of finite factorizations to be considered, before lifiting and searching (default: 1)
    factor_search_size (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space (default: 5000)
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_labels (bool) remove/ignore labels in the input formula, this option is ignored if proofs are enabled (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    inline_vars (bool) inline variables that can be isolated from equations (not supported in incremental mode) (default: false)
    ite_chaing (bool) (default: true) minimize the number of auxiliary variables during CNF encoding by identifing if-then-else chains
    ite_extra (bool) (default: true) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    ite_solver (bool) (default: true) use if-then-else solver.
    lazy (unsigned int) how lazy the solver is. (default: 0)
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    log_lemmas (bool) display lemmas as self-contained SMT formulas (default: false)
    max_args (unsigned int) (default: 128) maximum number of arguments (per application) that will be considered by the greedy (quadratic) heuristic.
    max_conflicts (unsigned int) maximum number of conflicts. (default: 4294967295)
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    max_prime (unsigned int) (default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step.
    max_rounds (unsigned int) (default: 4) maximum number of rounds.
    max_search_size (unsigned int) (default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space.
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    min_mag (unsigned int) Z3 represents algebraic numbers using a (square-free) polynomial p and an isolating interval (which contains one and only one root of p). This interval may be refined during the computations. This parameter specifies whether to cache the value of a refined interval or not. It says the minimal size of an interval for caching purposes is 1/2^16 (default: 16)
    minimize_conflicts (bool) minimize conflicts (default: false)
    mode (symbol) NNF translation mode: skolem (skolem normal form), quantifiers (skolem normal form + quantifiers in NNF), full (default: skolem)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    num_primes (unsigned int) (default: 1) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)'s. This parameter specify the maximum number of finite factorizations to be considered, before lifiting and searching.
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    randomize (bool) randomize selection of a witness in nlsat. (default: true)
    reorder (bool) reorder variables. (default: true)
    rewrite_patterns (bool) rewrite patterns. (default: false)
    seed (unsigned int) random seed. (default: 0)
    shuffle_vars (bool) use a random variable order. (default: false)
    simplify_conflicts (bool) simplify conflicts using equalities before resolving them in nlsat solver. (default: true)
    sk_hack (bool) hack for VCC (default: false)
    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations.
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
    split_factors (bool) (default: true) apply simplifications such as (= (* p1 p2) 0) --> (or (= p1 0) (= p2 0)).
    theory_solver (bool) (default: true) use theory solvers.
    zero_accuracy (unsigned int) one of the most time-consuming operations in the real algebraic number module is determining the sign of a polynomial evaluated at a sample point with non-rational algebraic number values. Let k be the value of this option. If k is 0, Z3 uses precise computation. Otherwise, the result of a polynomial evaluation is considered to be 0 if Z3 can show it is inside the interval (-1/2^k, 1/2^k) (default: 0)
- nlqsat apply a NL-QSAT solver.
- qe-light apply light-weight quantifier elimination.
- qe apply quantifier elimination.
    eliminate_variables_as_block (bool) (default: true) eliminate variables as a block (true) or one at a time (false)
    qe_nonlinear (bool) (default: false) enable virtual term substitution.
- qsat apply a QSAT solver.
- qe2 apply a QSAT based quantifier elimination.
- qe_rec apply a QSAT based quantifier elimination recursively.
- psat (try to) solve goal using a parallel SAT solver.
    abce (bool) eliminate blocked clauses using asymmetric literals (default: false)
    acce (bool) eliminate covered clauses using asymmetric added literals (default: false)
    anf (bool) enable ANF based simplification in-processing (default: false)
    anf.delay (unsigned int) delay ANF simplification by in-processing round (default: 2)
    anf.exlin (bool) enable extended linear simplification (default: false)
    asymm_branch (bool) asymmetric branching (default: true)
    asymm_branch.all (bool) asymmetric branching on all literals per clause (default: false)
    asymm_branch.delay (unsigned int) number of simplification rounds to wait until invoking asymmetric branch simplification (default: 1)
    asymm_branch.limit (unsigned int) approx. maximum number of literals visited during asymmetric branching (default: 100000000)
    asymm_branch.rounds (unsigned int) maximal number of rounds to run asymmetric branch simplifications if progress is made (default: 2)
    asymm_branch.sampled (bool) use sampling based asymmetric branching based on binary implication graph (default: true)
    ate (bool) asymmetric tautology elimination (default: true)
    backtrack.conflicts (unsigned int) number of conflicts before enabling chronological backtracking (default: 4000)
    backtrack.scopes (unsigned int) number of scopes to enable chronological backtracking (default: 100)
    bca (bool) blocked clause addition - add blocked binary clauses (default: false)
    bce (bool) eliminate blocked clauses (default: false)
    bce_at (unsigned int) eliminate blocked clauses only once at the given simplification round (default: 2)
    bce_delay (unsigned int) delay eliminate blocked clauses until simplification round (default: 2)
    binspr (bool) enable SPR inferences of binary propagation redundant clauses. This inprocessing step eliminates models (default: false)
    blocked_clause_limit (unsigned int) maximum number of literals visited during blocked clause elimination (default: 100000000)
    branching.anti_exploration (bool) apply anti-exploration heuristic for branch selection (default: false)
    branching.heuristic (symbol) branching heuristic vsids, chb (default: vsids)
    burst_search (unsigned int) number of conflicts before first global simplification (default: 100)
    cardinality.encoding (symbol) encoding used for at-most-k constraints: grouped, bimander, ordered, unate, circuit (default: grouped)
    cardinality.solver (bool) use cardinality solver (default: true)
    cce (bool) eliminate covered clauses (default: false)
    core.minimize (bool) minimize computed core (default: false)
    core.minimize_partial (bool) apply partial (cheap) core minimization (default: false)
    cut (bool) enable AIG based simplification in-processing (default: false)
    cut.aig (bool) extract aigs (and ites) from cluases for cut simplification (default: false)
    cut.delay (unsigned int) delay cut simplification by in-processing round (default: 2)
    cut.dont_cares (bool) integrate dont cares with cuts (default: true)
    cut.force (bool) force redoing cut-enumeration until a fixed-point (default: false)
    cut.lut (bool) extract luts from clauses for cut simplification (default: false)
    cut.npn3 (bool) extract 3 input functions from clauses for cut simplification (default: false)
    cut.redundancies (bool) integrate redundancy checking of cuts (default: true)
    cut.xor (bool) extract xors from clauses for cut simplification (default: false)
    ddfw.init_clause_weight (unsigned int) initial clause weight for DDFW local search (default: 8)
    ddfw.reinit_base (unsigned int) increment basis for geometric backoff scheme of re-initialization of weights (default: 10000)
    ddfw.restart_base (unsigned int) number of flips used a starting point for hessitant restart backoff (default: 100000)
    ddfw.threads (unsigned int) number of ddfw threads to run in parallel with sat solver (default: 0)
    ddfw.use_reward_pct (unsigned int) percentage to pick highest reward variable when it has reward 0 (default: 15)
    ddfw_search (bool) use ddfw local search instead of CDCL (default: false)
    dimacs.core (bool) extract core from DIMACS benchmarks (default: false)
    drat.activity (bool) dump variable activities (default: false)
    drat.binary (bool) use Binary DRAT output format (default: false)
    drat.check_sat (bool) build up internal trace, check satisfying model (default: false)
    drat.check_unsat (bool) build up internal proof and check (default: false)
    drat.file (symbol) file to dump DRAT proofs (default: )
    dyn_sub_res (bool) dynamic subsumption resolution for minimizing learned clauses (default: true)
    elim_vars (bool) enable variable elimination using resolution during simplification (default: true)
    elim_vars_bdd (bool) enable variable elimination using BDD recompilation during simplification (default: true)
    elim_vars_bdd_delay (unsigned int) delay elimination of variables using BDDs until after simplification round (default: 3)
    enable_pre_simplify (bool) enable pre simplifications before the bounded search (default: false)
    force_cleanup (bool) force cleanup to remove tautologies and simplify clauses (default: false)
    gc (symbol) garbage collection strategy: psm, glue, glue_psm, dyn_psm (default: glue_psm)
    gc.burst (bool) perform eager garbage collection during initialization (default: false)
    gc.defrag (bool) defragment clauses when garbage collecting (default: true)
    gc.increment (unsigned int) increment to the garbage collection threshold (default: 500)
    gc.initial (unsigned int) learned clauses garbage collection frequency (default: 20000)
    gc.k (unsigned int) learned clauses that are inactive for k gc rounds are permanently deleted (only used in dyn_psm) (default: 7)
    gc.small_lbd (unsigned int) learned clauses with small LBD are never deleted (only used in dyn_psm) (default: 3)
    inprocess.max (unsigned int) maximal number of inprocessing passes (default: 4294967295)
    inprocess.out (symbol) file to dump result of the first inprocessing step and exit (default: )
    ite_extra (bool) (default: true) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas
    learned (bool) (default: false) collect also learned clauses.
    local_search (bool) use local search instead of CDCL (default: false)
    local_search_dbg_flips (bool) write debug information for number of flips (default: false)
    local_search_mode (symbol) local search algorithm, either default wsat or qsat (default: wsat)
    local_search_threads (unsigned int) number of local search threads to find satisfiable solution (default: 0)
    lookahead.cube.cutoff (symbol) cutoff type used to create lookahead cubes: depth, freevars, psat, adaptive_freevars, adaptive_psat (default: depth)
    lookahead.cube.depth (unsigned int) cut-off depth to create cubes. Used when lookahead.cube.cutoff is depth. (default: 1)
    lookahead.cube.fraction (double) adaptive fraction to create lookahead cubes. Used when lookahead.cube.cutoff is adaptive_freevars or adaptive_psat (default: 0.4)
    lookahead.cube.freevars (double) cube free variable fraction. Used when lookahead.cube.cutoff is freevars (default: 0.8)
    lookahead.cube.psat.clause_base (double) clause base for PSAT cutoff (default: 2)
    lookahead.cube.psat.trigger (double) trigger value to create lookahead cubes for PSAT cutoff. Used when lookahead.cube.cutoff is psat (default: 5)
    lookahead.cube.psat.var_exp (double) free variable exponent for PSAT cutoff (default: 1)
    lookahead.delta_fraction (double) number between 0 and 1, the smaller the more literals are selected for double lookahead (default: 1.0)
    lookahead.double (bool) enable doubld lookahead (default: true)
    lookahead.global_autarky (bool) prefer to branch on variables that occur in clauses that are reduced (default: false)
    lookahead.preselect (bool) use pre-selection of subset of variables for branching (default: false)
    lookahead.reward (symbol) select lookahead heuristic: ternary, heule_schur (Heule Schur), heuleu (Heule Unit), unit, or march_cu (default: march_cu)
    lookahead.use_learned (bool) use learned clauses when selecting lookahead literal (default: false)
    lookahead_scores (bool) extract lookahead scores. A utility that can only be used from the DIMACS front-end (default: false)
    lookahead_simplify (bool) use lookahead solver during simplification (default: false)
    lookahead_simplify.bca (bool) add learned binary clauses as part of lookahead simplification (default: true)
    max_conflicts (unsigned int) maximum number of conflicts (default: 4294967295)
    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes.
    minimize_lemmas (bool) minimize learned clauses (default: true)
    override_incremental (bool) override incremental safety gaps. Enable elimination of blocked clauses and variables even if solver is reused (default: false)
    pb.lemma_format (symbol) generate either cardinality or pb lemmas (default: cardinality)
    pb.min_arity (unsigned int) minimal arity to compile pb/cardinality constraints to CNF (default: 9)
    pb.resolve (symbol) resolution strategy for boolean algebra solver: cardinality, rounding (default: cardinality)
    pb.solver (symbol) method for handling Pseudo-Boolean constraints: circuit (arithmetical circuit), sorting (sorting circuit), totalizer (use totalizer encoding), binary_merge, segmented, solver (use native solver) (default: solver)
    phase (symbol) phase selection strategy: always_false, always_true, basic_caching, random, caching (default: caching)
    phase.sticky (bool) use sticky phase caching (default: true)
    prob_search (bool) use probsat local search instead of CDCL (default: false)
    probing (bool) apply failed literal detection during simplification (default: true)
    probing_binary (bool) probe binary clauses (default: true)
    probing_cache (bool) add binary literals as lemmas (default: true)
    probing_cache_limit (unsigned int) cache binaries unless overall memory usage exceeds cache limit (default: 1024)
    probing_limit (unsigned int) limit to the number of probe calls (default: 5000000)
    propagate.prefetch (bool) prefetch watch lists for assigned literals (default: true)
    random_freq (double) frequency of random case splits (default: 0.01)
    random_seed (unsigned int) random seed (default: 0)
    reorder.activity_scale (unsigned int) scaling factor for activity update (default: 100)
    reorder.base (unsigned int) number of conflicts per random reorder  (default: 4294967295)
    reorder.itau (double) inverse temperature for softmax (default: 4.0)
    rephase.base (unsigned int) number of conflicts per rephase  (default: 1000)
    resolution.cls_cutoff1 (unsigned int) limit1 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 100000000)
    resolution.cls_cutoff2 (unsigned int) limit2 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 700000000)
    resolution.limit (unsigned int) approx. maximum number of literals visited during variable elimination (default: 500000000)
    resolution.lit_cutoff_range1 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 700)
    resolution.lit_cutoff_range2 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 400)
    resolution.lit_cutoff_range3 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 300)
    resolution.occ_cutoff (unsigned int) first cutoff (on number of positive/negative occurrences) for Boolean variable elimination (default: 10)
    resolution.occ_cutoff_range1 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 8)
    resolution.occ_cutoff_range2 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 5)
    resolution.occ_cutoff_range3 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 3)
    restart (symbol) restart strategy: static, luby, ema or geometric (default: ema)
    restart.emafastglue (double) ema alpha factor for fast moving average (default: 0.03)
    restart.emaslowglue (double) ema alpha factor for slow moving average (default: 1e-05)
    restart.factor (double) restart increment factor for geometric strategy (default: 1.5)
    restart.fast (bool) use fast restart approach only removing less active literals. (default: true)
    restart.initial (unsigned int) initial restart (number of conflicts) (default: 2)
    restart.margin (double) margin between fast and slow restart factors. For ema (default: 1.1)
    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)
    retain_blocked_clauses (bool) retain blocked clauses as lemmas (default: true)
    scc (bool) eliminate Boolean variables by computing strongly connected components (default: true)
    scc.tr (bool) apply transitive reduction, eliminate redundant binary clauses (default: true)
    search.sat.conflicts (unsigned int) period for solving for sat (in number of conflicts) (default: 400)
    search.unsat.conflicts (unsigned int) period for solving for unsat (in number of conflicts) (default: 400)
    simplify.delay (unsigned int) set initial delay of simplification by a conflict count (default: 0)
    subsumption (bool) eliminate subsumed clauses (default: true)
    subsumption.limit (unsigned int) approx. maximum number of literals visited during subsumption (and subsumption resolution) (default: 100000000)
    threads (unsigned int) number of parallel threads to use (default: 1)
    variable_decay (unsigned int) multiplier (divided by 100) for the VSIDS activity increment (default: 110)
- sat (try to) solve goal using a SAT solver.
    abce (bool) eliminate blocked clauses using asymmetric literals (default: false)
    acce (bool) eliminate covered clauses using asymmetric added literals (default: false)
    anf (bool) enable ANF based simplification in-processing (default: false)
    anf.delay (unsigned int) delay ANF simplification by in-processing round (default: 2)
    anf.exlin (bool) enable extended linear simplification (default: false)
    asymm_branch (bool) asymmetric branching (default: true)
    asymm_branch.all (bool) asymmetric branching on all literals per clause (default: false)
    asymm_branch.delay (unsigned int) number of simplification rounds to wait until invoking asymmetric branch simplification (default: 1)
    asymm_branch.limit (unsigned int) approx. maximum number of literals visited during asymmetric branching (default: 100000000)
    asymm_branch.rounds (unsigned int) maximal number of rounds to run asymmetric branch simplifications if progress is made (default: 2)
    asymm_branch.sampled (bool) use sampling based asymmetric branching based on binary implication graph (default: true)
    ate (bool) asymmetric tautology elimination (default: true)
    backtrack.conflicts (unsigned int) number of conflicts before enabling chronological backtracking (default: 4000)
    backtrack.scopes (unsigned int) number of scopes to enable chronological backtracking (default: 100)
    bca (bool) blocked clause addition - add blocked binary clauses (default: false)
    bce (bool) eliminate blocked clauses (default: false)
    bce_at (unsigned int) eliminate blocked clauses only once at the given simplification round (default: 2)
    bce_delay (unsigned int) delay eliminate blocked clauses until simplification round (default: 2)
    binspr (bool) enable SPR inferences of binary propagation redundant clauses. This inprocessing step eliminates models (default: false)
    blocked_clause_limit (unsigned int) maximum number of literals visited during blocked clause elimination (default: 100000000)
    branching.anti_exploration (bool) apply anti-exploration heuristic for branch selection (default: false)
    branching.heuristic (symbol) branching heuristic vsids, chb (default: vsids)
    burst_search (unsigned int) number of conflicts before first global simplification (default: 100)
    cardinality.encoding (symbol) encoding used for at-most-k constraints: grouped, bimander, ordered, unate, circuit (default: grouped)
    cardinality.solver (bool) use cardinality solver (default: true)
    cce (bool) eliminate covered clauses (default: false)
    core.minimize (bool) minimize computed core (default: false)
    core.minimize_partial (bool) apply partial (cheap) core minimization (default: false)
    cut (bool) enable AIG based simplification in-processing (default: false)
    cut.aig (bool) extract aigs (and ites) from cluases for cut simplification (default: false)
    cut.delay (unsigned int) delay cut simplification by in-processing round (default: 2)
    cut.dont_cares (bool) integrate dont cares with cuts (default: true)
    cut.force (bool) force redoing cut-enumeration until a fixed-point (default: false)
    cut.lut (bool) extract luts from clauses for cut simplification (default: false)
    cut.npn3 (bool) extract 3 input functions from clauses for cut simplification (default: false)
    cut.redundancies (bool) integrate redundancy checking of cuts (default: true)
    cut.xor (bool) extract xors from clauses for cut simplification (default: false)
    ddfw.init_clause_weight (unsigned int) initial clause weight for DDFW local search (default: 8)
    ddfw.reinit_base (unsigned int) increment basis for geometric backoff scheme of re-initialization of weights (default: 10000)
    ddfw.restart_base (unsigned int) number of flips used a starting point for hessitant restart backoff (default: 100000)
    ddfw.threads (unsigned int) number of ddfw threads to run in parallel with sat solver (default: 0)
    ddfw.use_reward_pct (unsigned int) percentage to pick highest reward variable when it has reward 0 (default: 15)
    ddfw_search (bool) use ddfw local search instead of CDCL (default: false)
    dimacs.core (bool) extract core from DIMACS benchmarks (default: false)
    drat.activity (bool) dump variable activities (default: false)
    drat.binary (bool) use Binary DRAT output format (default: false)
    drat.check_sat (bool) build up internal trace, check satisfying model (default: false)
    drat.check_unsat (bool) build up internal proof and check (default: false)
    drat.file (symbol) file to dump DRAT proofs (default: )
    dyn_sub_res (bool) dynamic subsumption resolution for minimizing learned clauses (default: true)
    elim_vars (bool) enable variable elimination using resolution during simplification (default: true)
    elim_vars_bdd (bool) enable variable elimination using BDD recompilation during simplification (default: true)
    elim_vars_bdd_delay (unsigned int) delay elimination of variables using BDDs until after simplification round (default: 3)
    enable_pre_simplify (bool) enable pre simplifications before the bounded search (default: false)
    force_cleanup (bool) force cleanup to remove tautologies and simplify clauses (default: false)
    gc (symbol) garbage collection strategy: psm, glue, glue_psm, dyn_psm (default: glue_psm)
    gc.burst (bool) perform eager garbage collection during initialization (default: false)
    gc.defrag (bool) defragment clauses when garbage collecting (default: true)
    gc.increment (unsigned int) increment to the garbage collection threshold (default: 500)
    gc.initial (unsigned int) learned clauses garbage collection frequency (default: 20000)
    gc.k (unsigned int) learned clauses that are inactive for k gc rounds are permanently deleted (only used in dyn_psm) (default: 7)
    gc.small_lbd (unsigned int) learned clauses with small LBD are never deleted (only used in dyn_psm) (default: 3)
    inprocess.max (unsigned int) maximal number of inprocessing passes (default: 4294967295)
    inprocess.out (symbol) file to dump result of the first inprocessing step and exit (default: )
    ite_extra (bool) (default: true) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas
    learned (bool) (default: false) collect also learned clauses.
    local_search (bool) use local search instead of CDCL (default: false)
    local_search_dbg_flips (bool) write debug information for number of flips (default: false)
    local_search_mode (symbol) local search algorithm, either default wsat or qsat (default: wsat)
    local_search_threads (unsigned int) number of local search threads to find satisfiable solution (default: 0)
    lookahead.cube.cutoff (symbol) cutoff type used to create lookahead cubes: depth, freevars, psat, adaptive_freevars, adaptive_psat (default: depth)
    lookahead.cube.depth (unsigned int) cut-off depth to create cubes. Used when lookahead.cube.cutoff is depth. (default: 1)
    lookahead.cube.fraction (double) adaptive fraction to create lookahead cubes. Used when lookahead.cube.cutoff is adaptive_freevars or adaptive_psat (default: 0.4)
    lookahead.cube.freevars (double) cube free variable fraction. Used when lookahead.cube.cutoff is freevars (default: 0.8)
    lookahead.cube.psat.clause_base (double) clause base for PSAT cutoff (default: 2)
    lookahead.cube.psat.trigger (double) trigger value to create lookahead cubes for PSAT cutoff. Used when lookahead.cube.cutoff is psat (default: 5)
    lookahead.cube.psat.var_exp (double) free variable exponent for PSAT cutoff (default: 1)
    lookahead.delta_fraction (double) number between 0 and 1, the smaller the more literals are selected for double lookahead (default: 1.0)
    lookahead.double (bool) enable doubld lookahead (default: true)
    lookahead.global_autarky (bool) prefer to branch on variables that occur in clauses that are reduced (default: false)
    lookahead.preselect (bool) use pre-selection of subset of variables for branching (default: false)
    lookahead.reward (symbol) select lookahead heuristic: ternary, heule_schur (Heule Schur), heuleu (Heule Unit), unit, or march_cu (default: march_cu)
    lookahead.use_learned (bool) use learned clauses when selecting lookahead literal (default: false)
    lookahead_scores (bool) extract lookahead scores. A utility that can only be used from the DIMACS front-end (default: false)
    lookahead_simplify (bool) use lookahead solver during simplification (default: false)
    lookahead_simplify.bca (bool) add learned binary clauses as part of lookahead simplification (default: true)
    max_conflicts (unsigned int) maximum number of conflicts (default: 4294967295)
    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes.
    minimize_lemmas (bool) minimize learned clauses (default: true)
    override_incremental (bool) override incremental safety gaps. Enable elimination of blocked clauses and variables even if solver is reused (default: false)
    pb.lemma_format (symbol) generate either cardinality or pb lemmas (default: cardinality)
    pb.min_arity (unsigned int) minimal arity to compile pb/cardinality constraints to CNF (default: 9)
    pb.resolve (symbol) resolution strategy for boolean algebra solver: cardinality, rounding (default: cardinality)
    pb.solver (symbol) method for handling Pseudo-Boolean constraints: circuit (arithmetical circuit), sorting (sorting circuit), totalizer (use totalizer encoding), binary_merge, segmented, solver (use native solver) (default: solver)
    phase (symbol) phase selection strategy: always_false, always_true, basic_caching, random, caching (default: caching)
    phase.sticky (bool) use sticky phase caching (default: true)
    prob_search (bool) use probsat local search instead of CDCL (default: false)
    probing (bool) apply failed literal detection during simplification (default: true)
    probing_binary (bool) probe binary clauses (default: true)
    probing_cache (bool) add binary literals as lemmas (default: true)
    probing_cache_limit (unsigned int) cache binaries unless overall memory usage exceeds cache limit (default: 1024)
    probing_limit (unsigned int) limit to the number of probe calls (default: 5000000)
    propagate.prefetch (bool) prefetch watch lists for assigned literals (default: true)
    random_freq (double) frequency of random case splits (default: 0.01)
    random_seed (unsigned int) random seed (default: 0)
    reorder.activity_scale (unsigned int) scaling factor for activity update (default: 100)
    reorder.base (unsigned int) number of conflicts per random reorder  (default: 4294967295)
    reorder.itau (double) inverse temperature for softmax (default: 4.0)
    rephase.base (unsigned int) number of conflicts per rephase  (default: 1000)
    resolution.cls_cutoff1 (unsigned int) limit1 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 100000000)
    resolution.cls_cutoff2 (unsigned int) limit2 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 700000000)
    resolution.limit (unsigned int) approx. maximum number of literals visited during variable elimination (default: 500000000)
    resolution.lit_cutoff_range1 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 700)
    resolution.lit_cutoff_range2 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 400)
    resolution.lit_cutoff_range3 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 300)
    resolution.occ_cutoff (unsigned int) first cutoff (on number of positive/negative occurrences) for Boolean variable elimination (default: 10)
    resolution.occ_cutoff_range1 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 8)
    resolution.occ_cutoff_range2 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 5)
    resolution.occ_cutoff_range3 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 3)
    restart (symbol) restart strategy: static, luby, ema or geometric (default: ema)
    restart.emafastglue (double) ema alpha factor for fast moving average (default: 0.03)
    restart.emaslowglue (double) ema alpha factor for slow moving average (default: 1e-05)
    restart.factor (double) restart increment factor for geometric strategy (default: 1.5)
    restart.fast (bool) use fast restart approach only removing less active literals. (default: true)
    restart.initial (unsigned int) initial restart (number of conflicts) (default: 2)
    restart.margin (double) margin between fast and slow restart factors. For ema (default: 1.1)
    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)
    retain_blocked_clauses (bool) retain blocked clauses as lemmas (default: true)
    scc (bool) eliminate Boolean variables by computing strongly connected components (default: true)
    scc.tr (bool) apply transitive reduction, eliminate redundant binary clauses (default: true)
    search.sat.conflicts (unsigned int) period for solving for sat (in number of conflicts) (default: 400)
    search.unsat.conflicts (unsigned int) period for solving for unsat (in number of conflicts) (default: 400)
    simplify.delay (unsigned int) set initial delay of simplification by a conflict count (default: 0)
    subsumption (bool) eliminate subsumed clauses (default: true)
    subsumption.limit (unsigned int) approx. maximum number of literals visited during subsumption (and subsumption resolution) (default: 100000000)
    threads (unsigned int) number of parallel threads to use (default: 1)
    variable_decay (unsigned int) multiplier (divided by 100) for the VSIDS activity increment (default: 110)
- sat-preprocess Apply SAT solver preprocessing procedures (bounded resolution, Boolean constant propagation, 2-SAT, subsumption, subsumption resolution).
    abce (bool) eliminate blocked clauses using asymmetric literals (default: false)
    acce (bool) eliminate covered clauses using asymmetric added literals (default: false)
    anf (bool) enable ANF based simplification in-processing (default: false)
    anf.delay (unsigned int) delay ANF simplification by in-processing round (default: 2)
    anf.exlin (bool) enable extended linear simplification (default: false)
    asymm_branch (bool) asymmetric branching (default: true)
    asymm_branch.all (bool) asymmetric branching on all literals per clause (default: false)
    asymm_branch.delay (unsigned int) number of simplification rounds to wait until invoking asymmetric branch simplification (default: 1)
    asymm_branch.limit (unsigned int) approx. maximum number of literals visited during asymmetric branching (default: 100000000)
    asymm_branch.rounds (unsigned int) maximal number of rounds to run asymmetric branch simplifications if progress is made (default: 2)
    asymm_branch.sampled (bool) use sampling based asymmetric branching based on binary implication graph (default: true)
    ate (bool) asymmetric tautology elimination (default: true)
    backtrack.conflicts (unsigned int) number of conflicts before enabling chronological backtracking (default: 4000)
    backtrack.scopes (unsigned int) number of scopes to enable chronological backtracking (default: 100)
    bca (bool) blocked clause addition - add blocked binary clauses (default: false)
    bce (bool) eliminate blocked clauses (default: false)
    bce_at (unsigned int) eliminate blocked clauses only once at the given simplification round (default: 2)
    bce_delay (unsigned int) delay eliminate blocked clauses until simplification round (default: 2)
    binspr (bool) enable SPR inferences of binary propagation redundant clauses. This inprocessing step eliminates models (default: false)
    blocked_clause_limit (unsigned int) maximum number of literals visited during blocked clause elimination (default: 100000000)
    branching.anti_exploration (bool) apply anti-exploration heuristic for branch selection (default: false)
    branching.heuristic (symbol) branching heuristic vsids, chb (default: vsids)
    burst_search (unsigned int) number of conflicts before first global simplification (default: 100)
    cardinality.encoding (symbol) encoding used for at-most-k constraints: grouped, bimander, ordered, unate, circuit (default: grouped)
    cardinality.solver (bool) use cardinality solver (default: true)
    cce (bool) eliminate covered clauses (default: false)
    core.minimize (bool) minimize computed core (default: false)
    core.minimize_partial (bool) apply partial (cheap) core minimization (default: false)
    cut (bool) enable AIG based simplification in-processing (default: false)
    cut.aig (bool) extract aigs (and ites) from cluases for cut simplification (default: false)
    cut.delay (unsigned int) delay cut simplification by in-processing round (default: 2)
    cut.dont_cares (bool) integrate dont cares with cuts (default: true)
    cut.force (bool) force redoing cut-enumeration until a fixed-point (default: false)
    cut.lut (bool) extract luts from clauses for cut simplification (default: false)
    cut.npn3 (bool) extract 3 input functions from clauses for cut simplification (default: false)
    cut.redundancies (bool) integrate redundancy checking of cuts (default: true)
    cut.xor (bool) extract xors from clauses for cut simplification (default: false)
    ddfw.init_clause_weight (unsigned int) initial clause weight for DDFW local search (default: 8)
    ddfw.reinit_base (unsigned int) increment basis for geometric backoff scheme of re-initialization of weights (default: 10000)
    ddfw.restart_base (unsigned int) number of flips used a starting point for hessitant restart backoff (default: 100000)
    ddfw.threads (unsigned int) number of ddfw threads to run in parallel with sat solver (default: 0)
    ddfw.use_reward_pct (unsigned int) percentage to pick highest reward variable when it has reward 0 (default: 15)
    ddfw_search (bool) use ddfw local search instead of CDCL (default: false)
    dimacs.core (bool) extract core from DIMACS benchmarks (default: false)
    drat.activity (bool) dump variable activities (default: false)
    drat.binary (bool) use Binary DRAT output format (default: false)
    drat.check_sat (bool) build up internal trace, check satisfying model (default: false)
    drat.check_unsat (bool) build up internal proof and check (default: false)
    drat.file (symbol) file to dump DRAT proofs (default: )
    dyn_sub_res (bool) dynamic subsumption resolution for minimizing learned clauses (default: true)
    elim_vars (bool) enable variable elimination using resolution during simplification (default: true)
    elim_vars_bdd (bool) enable variable elimination using BDD recompilation during simplification (default: true)
    elim_vars_bdd_delay (unsigned int) delay elimination of variables using BDDs until after simplification round (default: 3)
    enable_pre_simplify (bool) enable pre simplifications before the bounded search (default: false)
    force_cleanup (bool) force cleanup to remove tautologies and simplify clauses (default: false)
    gc (symbol) garbage collection strategy: psm, glue, glue_psm, dyn_psm (default: glue_psm)
    gc.burst (bool) perform eager garbage collection during initialization (default: false)
    gc.defrag (bool) defragment clauses when garbage collecting (default: true)
    gc.increment (unsigned int) increment to the garbage collection threshold (default: 500)
    gc.initial (unsigned int) learned clauses garbage collection frequency (default: 20000)
    gc.k (unsigned int) learned clauses that are inactive for k gc rounds are permanently deleted (only used in dyn_psm) (default: 7)
    gc.small_lbd (unsigned int) learned clauses with small LBD are never deleted (only used in dyn_psm) (default: 3)
    inprocess.max (unsigned int) maximal number of inprocessing passes (default: 4294967295)
    inprocess.out (symbol) file to dump result of the first inprocessing step and exit (default: )
    ite_extra (bool) (default: true) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas
    learned (bool) (default: false) collect also learned clauses.
    local_search (bool) use local search instead of CDCL (default: false)
    local_search_dbg_flips (bool) write debug information for number of flips (default: false)
    local_search_mode (symbol) local search algorithm, either default wsat or qsat (default: wsat)
    local_search_threads (unsigned int) number of local search threads to find satisfiable solution (default: 0)
    lookahead.cube.cutoff (symbol) cutoff type used to create lookahead cubes: depth, freevars, psat, adaptive_freevars, adaptive_psat (default: depth)
    lookahead.cube.depth (unsigned int) cut-off depth to create cubes. Used when lookahead.cube.cutoff is depth. (default: 1)
    lookahead.cube.fraction (double) adaptive fraction to create lookahead cubes. Used when lookahead.cube.cutoff is adaptive_freevars or adaptive_psat (default: 0.4)
    lookahead.cube.freevars (double) cube free variable fraction. Used when lookahead.cube.cutoff is freevars (default: 0.8)
    lookahead.cube.psat.clause_base (double) clause base for PSAT cutoff (default: 2)
    lookahead.cube.psat.trigger (double) trigger value to create lookahead cubes for PSAT cutoff. Used when lookahead.cube.cutoff is psat (default: 5)
    lookahead.cube.psat.var_exp (double) free variable exponent for PSAT cutoff (default: 1)
    lookahead.delta_fraction (double) number between 0 and 1, the smaller the more literals are selected for double lookahead (default: 1.0)
    lookahead.double (bool) enable doubld lookahead (default: true)
    lookahead.global_autarky (bool) prefer to branch on variables that occur in clauses that are reduced (default: false)
    lookahead.preselect (bool) use pre-selection of subset of variables for branching (default: false)
    lookahead.reward (symbol) select lookahead heuristic: ternary, heule_schur (Heule Schur), heuleu (Heule Unit), unit, or march_cu (default: march_cu)
    lookahead.use_learned (bool) use learned clauses when selecting lookahead literal (default: false)
    lookahead_scores (bool) extract lookahead scores. A utility that can only be used from the DIMACS front-end (default: false)
    lookahead_simplify (bool) use lookahead solver during simplification (default: false)
    lookahead_simplify.bca (bool) add learned binary clauses as part of lookahead simplification (default: true)
    max_conflicts (unsigned int) maximum number of conflicts (default: 4294967295)
    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes.
    minimize_lemmas (bool) minimize learned clauses (default: true)
    override_incremental (bool) override incremental safety gaps. Enable elimination of blocked clauses and variables even if solver is reused (default: false)
    pb.lemma_format (symbol) generate either cardinality or pb lemmas (default: cardinality)
    pb.min_arity (unsigned int) minimal arity to compile pb/cardinality constraints to CNF (default: 9)
    pb.resolve (symbol) resolution strategy for boolean algebra solver: cardinality, rounding (default: cardinality)
    pb.solver (symbol) method for handling Pseudo-Boolean constraints: circuit (arithmetical circuit), sorting (sorting circuit), totalizer (use totalizer encoding), binary_merge, segmented, solver (use native solver) (default: solver)
    phase (symbol) phase selection strategy: always_false, always_true, basic_caching, random, caching (default: caching)
    phase.sticky (bool) use sticky phase caching (default: true)
    prob_search (bool) use probsat local search instead of CDCL (default: false)
    probing (bool) apply failed literal detection during simplification (default: true)
    probing_binary (bool) probe binary clauses (default: true)
    probing_cache (bool) add binary literals as lemmas (default: true)
    probing_cache_limit (unsigned int) cache binaries unless overall memory usage exceeds cache limit (default: 1024)
    probing_limit (unsigned int) limit to the number of probe calls (default: 5000000)
    propagate.prefetch (bool) prefetch watch lists for assigned literals (default: true)
    random_freq (double) frequency of random case splits (default: 0.01)
    random_seed (unsigned int) random seed (default: 0)
    reorder.activity_scale (unsigned int) scaling factor for activity update (default: 100)
    reorder.base (unsigned int) number of conflicts per random reorder  (default: 4294967295)
    reorder.itau (double) inverse temperature for softmax (default: 4.0)
    rephase.base (unsigned int) number of conflicts per rephase  (default: 1000)
    resolution.cls_cutoff1 (unsigned int) limit1 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 100000000)
    resolution.cls_cutoff2 (unsigned int) limit2 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 700000000)
    resolution.limit (unsigned int) approx. maximum number of literals visited during variable elimination (default: 500000000)
    resolution.lit_cutoff_range1 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 700)
    resolution.lit_cutoff_range2 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 400)
    resolution.lit_cutoff_range3 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 300)
    resolution.occ_cutoff (unsigned int) first cutoff (on number of positive/negative occurrences) for Boolean variable elimination (default: 10)
    resolution.occ_cutoff_range1 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 8)
    resolution.occ_cutoff_range2 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 5)
    resolution.occ_cutoff_range3 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 3)
    restart (symbol) restart strategy: static, luby, ema or geometric (default: ema)
    restart.emafastglue (double) ema alpha factor for fast moving average (default: 0.03)
    restart.emaslowglue (double) ema alpha factor for slow moving average (default: 1e-05)
    restart.factor (double) restart increment factor for geometric strategy (default: 1.5)
    restart.fast (bool) use fast restart approach only removing less active literals. (default: true)
    restart.initial (unsigned int) initial restart (number of conflicts) (default: 2)
    restart.margin (double) margin between fast and slow restart factors. For ema (default: 1.1)
    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)
    retain_blocked_clauses (bool) retain blocked clauses as lemmas (default: true)
    scc (bool) eliminate Boolean variables by computing strongly connected components (default: true)
    scc.tr (bool) apply transitive reduction, eliminate redundant binary clauses (default: true)
    search.sat.conflicts (unsigned int) period for solving for sat (in number of conflicts) (default: 400)
    search.unsat.conflicts (unsigned int) period for solving for unsat (in number of conflicts) (default: 400)
    simplify.delay (unsigned int) set initial delay of simplification by a conflict count (default: 0)
    subsumption (bool) eliminate subsumed clauses (default: true)
    subsumption.limit (unsigned int) approx. maximum number of literals visited during subsumption (and subsumption resolution) (default: 100000000)
    threads (unsigned int) number of parallel threads to use (default: 1)
    variable_decay (unsigned int) multiplier (divided by 100) for the VSIDS activity increment (default: 110)
- ctx-solver-simplify apply solver-based contextual simplification rules.
    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)
    arith.bounded_expansion (bool) box variables used in branch and bound into bound assumptions (default: false)
    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)
    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)
    arith.cheap_eqs (unsigned int) 0 - do not run, 1 - use tree, 2 - use table (default: 1)
    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)
    arith.eager_eq_axioms (bool) eager equality axioms (default: true)
    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)
    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)
    arith.ignore_int (bool) treat integer variables as real (default: false)
    arith.int_eq_branch (bool) branching using derived integer equations (default: false)
    arith.min (bool) minimize cost (default: false)
    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.branching (bool) branching on integer variables in non linear clusters, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.expp (bool) expensive patching (default: false)
    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)
    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)
    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)
    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)
    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)
    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)
    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)
    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)
    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.horner (bool) run horner's heuristic (default: true)
    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)
    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)
    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.nra (bool) call nra_solver when incremental lianirization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)
    arith.nl.order (bool) run order lemmas (default: true)
    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)
    arith.nl.tangents (bool) run tangent lemmas (default: true)
    arith.print_ext_var_names (bool) print external variable names (default: false)
    arith.print_stats (bool) print statistic (default: false)
    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)
    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine bounds (default: 2)
    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)
    arith.reflect (bool) reflect arithmetical operators to the congruence closure (default: true)
    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)
    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)
    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)
    array.extensional (bool) extensional array theory (default: true)
    array.weak (bool) weak array theory (default: false)
    auto_config (bool) automatically configure solver (default: true)
    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)
    bv.reflect (bool) create enode for every bit-vector term (default: true)
    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)
    clause_proof (bool) record a clausal proof (default: false)
    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)
    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)
    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)
    core.minimize (bool) minimize unsat core produced by SMT context (default: false)
    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)
    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)
    dack.eq (bool) enable dynamic ackermannization for transtivity of equalities (default: false)
    dack.factor (double) number of instance per conflict (default: 0.1)
    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)
    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)
    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)
    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)
    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)
    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)
    ematching (bool) E-Matching based quantifier instantiation (default: true)
    induction (bool) enable generation of induction lemmas (default: false)
    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)
    logic (symbol) logic used to setup the SMT solver (default: )
    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)
    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)
    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)
    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)
    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )
    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)
    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)
    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)
    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)
    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)
    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)
    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)
    pull_nested_quantifiers (bool) pull nested quantifiers (default: false)
    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))
    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)
    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)
    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)
    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)
    qi.profile (bool) profile quantifier instantiation (default: false)
    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)
    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)
    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)
    random_seed (unsigned int) random seed for the smt solver (default: 0)
    refine_inj_axioms (bool) refine injectivity axioms (default: true)
    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)
    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)
    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)
    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)
    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)
    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)
    seq.use_derivatives (bool) dev flag (not for users) enable derivative based unfolding of regex (default: false)
    seq.use_unicode (bool) dev flag (not for users) enable unicode semantics (default: false)
    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)
    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)
    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)
    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)
    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)
    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)
    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)
    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)
    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)
    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)
    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)
    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)
    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)
    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)
    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)
    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)
    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)
    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)
    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)
    threads (unsigned int) maximal number of parallel threads. (default: 1)
    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)
- smt apply a SAT based SMT solver.
    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)
    arith.bounded_expansion (bool) box variables used in branch and bound into bound assumptions (default: false)
    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)
    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)
    arith.cheap_eqs (unsigned int) 0 - do not run, 1 - use tree, 2 - use table (default: 1)
    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)
    arith.eager_eq_axioms (bool) eager equality axioms (default: true)
    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)
    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)
    arith.ignore_int (bool) treat integer variables as real (default: false)
    arith.int_eq_branch (bool) branching using derived integer equations (default: false)
    arith.min (bool) minimize cost (default: false)
    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.branching (bool) branching on integer variables in non linear clusters, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.expp (bool) expensive patching (default: false)
    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)
    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)
    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)
    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)
    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)
    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)
    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)
    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)
    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.horner (bool) run horner's heuristic (default: true)
    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)
    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)
    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.nra (bool) call nra_solver when incremental lianirization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)
    arith.nl.order (bool) run order lemmas (default: true)
    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)
    arith.nl.tangents (bool) run tangent lemmas (default: true)
    arith.print_ext_var_names (bool) print external variable names (default: false)
    arith.print_stats (bool) print statistic (default: false)
    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)
    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine bounds (default: 2)
    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)
    arith.reflect (bool) reflect arithmetical operators to the congruence closure (default: true)
    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)
    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)
    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)
    array.extensional (bool) extensional array theory (default: true)
    array.weak (bool) weak array theory (default: false)
    auto_config (bool) automatically configure solver (default: true)
    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)
    bv.reflect (bool) create enode for every bit-vector term (default: true)
    candidate_models (bool) (default: false) create candidate models even when quantifier or theory reasoning is incomplete.
    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)
    clause_proof (bool) record a clausal proof (default: false)
    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)
    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)
    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)
    core.minimize (bool) minimize unsat core produced by SMT context (default: false)
    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)
    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)
    dack.eq (bool) enable dynamic ackermannization for transtivity of equalities (default: false)
    dack.factor (double) number of instance per conflict (default: 0.1)
    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)
    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)
    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)
    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)
    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)
    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)
    ematching (bool) E-Matching based quantifier instantiation (default: true)
    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.
    induction (bool) enable generation of induction lemmas (default: false)
    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)
    logic (symbol) logic used to setup the SMT solver (default: )
    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)
    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)
    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)
    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)
    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )
    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)
    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)
    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)
    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)
    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)
    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)
    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)
    pull_nested_quantifiers (bool) pull nested quantifiers (default: false)
    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))
    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)
    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)
    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)
    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)
    qi.profile (bool) profile quantifier instantiation (default: false)
    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)
    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)
    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)
    random_seed (unsigned int) random seed for the smt solver (default: 0)
    refine_inj_axioms (bool) refine injectivity axioms (default: true)
    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)
    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)
    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)
    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)
    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)
    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)
    seq.use_derivatives (bool) dev flag (not for users) enable derivative based unfolding of regex (default: false)
    seq.use_unicode (bool) dev flag (not for users) enable unicode semantics (default: false)
    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)
    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)
    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)
    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)
    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)
    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)
    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)
    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)
    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)
    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)
    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)
    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)
    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)
    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)
    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)
    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)
    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)
    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)
    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)
    threads (unsigned int) maximal number of parallel threads. (default: 1)
    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)
- psmt builtin strategy for SMT tactic in parallel.
- unit-subsume-simplify unit subsumption simplification.
- aig simplify Boolean structure using AIGs.
    aig_per_assertion (bool) (default: true) process one assertion at a time.
    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes.
- add-bounds add bounds to unbounded variables (under approximation).
    add_bound_lower (rational) (default: -2) lower bound to be added to unbounded variables.
    add_bound_upper (rational) (default: 2) upper bound to be added to unbounded variables.
- card2bv convert pseudo-boolean constraints to bit-vectors.
    keep_cardinality_constraints (bool) (default: true) retain cardinality constraints for solver
- degree-shift try to reduce degree of polynomials (remark: :mul2power simplification is automatically applied).
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    rewrite_patterns (bool) rewrite patterns. (default: false)
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
- diff-neq specialized solver for integer arithmetic problems that contain only atoms of the form (<= k x) (<= x k) and (not (= (- x y) k)), where x and y are constants and k is a numeral, and all constants are bounded.
    diff_neq_max_k (unsigned int) (default: 1024) maximum variable upper bound for diff neq solver.
- eq2bv convert integer variables used as finite domain elements to bit-vectors.
- factor polynomial factorization.
    max_prime (unsigned int) (default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step.
    max_search_size (unsigned int) (default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space.
    num_primes (unsigned int) (default: 1) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)'s. This parameter specify the maximum number of finite factorizations to be considered, before lifiting and searching.
    split_factors (bool) (default: true) apply simplifications such as (= (* p1 p2) 0) --> (or (= p1 0) (= p2 0)).
- fix-dl-var if goal is in the difference logic fragment, then fix the variable with the most number of occurrences at 0.
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    rewrite_patterns (bool) rewrite patterns. (default: false)
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
- fm eliminate variables using fourier-motzkin elimination.
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    fm_cutoff1 (unsigned int) (default: 8) first cutoff for FM based on maximum number of lower/upper occurrences.
    fm_cutoff2 (unsigned int) (default: 256) second cutoff for FM based on num_lower * num_upper occurrences.
    fm_extra (unsigned int) (default: 0) max. increase on the number of inequalities for each FM variable elimination step.
    fm_limit (unsigned int) (default: 5000000) maximum number of constraints, monomials, clauses visited during FM.
    fm_occ (bool) (default: false) consider inequalities occurring in clauses for FM.
    fm_real_only (bool) (default: true) consider only real variables for fourier-motzkin elimination.
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    produce_models (bool) (default: false) model generation.
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    rewrite_patterns (bool) rewrite patterns. (default: false)
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
- lia2card introduce cardinality constraints from 0-1 integer.
    compile_equality (bool) (default:false) compile equalities into pseudo-Boolean equality
- lia2pb convert bounded integer variables into a sequence of 0-1 variables.
    lia2pb_max_bits (unsigned int) (default: 32) maximum number of bits to be used (per variable) in lia2pb.
    lia2pb_partial (bool) (default: false) partial lia2pb conversion.
    lia2pb_total_bits (unsigned int) (default: 2048) total number of bits to be used (per problem) in lia2pb.
- nla2bv convert a nonlinear arithmetic problem into a bit-vector problem, in most cases the resultant goal is an under approximation and is useul for finding models.
    nla2bv_bv_size (unsigned int) (default: 4) default bit-vector size used by nla2bv tactic.
    nla2bv_divisor (unsigned int) (default: 2) nla2bv tactic parameter.
    nla2bv_max_bv_size (unsigned int) (default: inf) maximum bit-vector size used by nla2bv tactic
    nla2bv_root (unsigned int) (default: 2) nla2bv tactic encodes reals into bit-vectors using expressions of the form a+b*sqrt(c), this parameter sets the value of c used in the encoding.
- normalize-bounds replace a variable x with lower bound k <= x with x' = x - k.
    norm_int_only (bool) (default: true) normalize only the bounds of integer constants.
    produce_models (bool) (default: false) model generation.
- pb2bv convert pseudo-boolean constraints to bit-vectors.
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes.
    pb2bv_all_clauses_limit (unsigned int) (default: 8) maximum number of literals for using equivalent CNF encoding of PB constraint.
    pb2bv_cardinality_limit (unsigned int) (default: inf) limit for using arc-consistent cardinality constraint encoding.
- propagate-ineqs propagate ineqs/bounds, remove subsumed inequalities.
- purify-arith eliminate unnecessary operators: -, /, div, mod, rem, is-int, to-int, ^, root-objects.
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    complete (bool) (default: true) add constraints to make sure that any interpretation of a underspecified arithmetic operators is a function. The result will include additional uninterpreted functions/constants: /0, div0, mod0, 0^0, neg-root
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_inverses (bool) (default: true) eliminate inverse trigonometric functions (asin, acos, atan).
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_root_objects (bool) (default: true) eliminate root objects.
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_labels (bool) remove/ignore labels in the input formula, this option is ignored if proofs are enabled (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    mode (symbol) NNF translation mode: skolem (skolem normal form), quantifiers (skolem normal form + quantifiers in NNF), full (default: skolem)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    rewrite_patterns (bool) rewrite patterns. (default: false)
    sk_hack (bool) hack for VCC (default: false)
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
- recover-01 recover 0-1 variables hidden as Boolean variables.
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    recover_01_max_bits (unsigned int) (default: 10) maximum number of bits to consider in a clause.
    rewrite_patterns (bool) rewrite patterns. (default: false)
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
- bit-blast reduce bit-vector expressions into SAT.
    blast_add (bool) (default: true) bit-blast adders.
    blast_full (bool) (default: false) bit-blast any term with bit-vector sort, this option will make E-matching ineffective in any pattern containing bit-vector terms.
    blast_mul (bool) (default: true) bit-blast multipliers (and dividers, remainders).
    blast_quant (bool) (default: false) bit-blast quantified variables.
    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes.
    max_steps (unsigned int) (default: infty) maximum number of steps.
- bv1-blast reduce bit-vector expressions into bit-vectors of size 1 (notes: only equality, extract and concat are supported).
    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes.
    max_steps (unsigned int) (default: infty) maximum number of steps.
- bv_bound_chk attempts to detect inconsistencies of bounds on bv expressions.
- propagate-bv-bounds propagate bit-vector bounds by simplifying implied or contradictory bounds.
    max_depth (unsigned int) (default: 1024) maximum term depth.
    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes.
    max_steps (unsigned int) (default: infty) maximum number of steps.
    propagate_eq (bool) (default: false) enable equality propagation from bounds.
- propagate-bv-bounds-new propagate bit-vector bounds by simplifying implied or contradictory bounds.
- reduce-bv-size try to reduce bit-vector sizes using inequalities.
- bvarray2uf Rewrite bit-vector arrays into bit-vector (uninterpreted) functions.
    produce_models (bool) (default: false) model generation.
- dt2bv eliminate finite domain data-types. Replace by bit-vectors.
- elim-small-bv eliminate small, quantified bit-vectors by expansion.
    max_bits (unsigned int) (default: 4) maximum bit-vector size of quantified bit-vectors to be eliminated.
    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes.
    max_steps (unsigned int) (default: infty) maximum number of steps.
- max-bv-sharing use heuristics to maximize the sharing of bit-vector expressions such as adders and multipliers.
    max_args (unsigned int) (default: 128) maximum number of arguments (per application) that will be considered by the greedy (quadratic) heuristic.
    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes.
    max_steps (unsigned int) (default: infty) maximum number of steps.
- blast-term-ite blast term if-then-else by hoisting them.
    max_inflation (unsigned int) (default: infinity) multiplicative factor of initial term size.
    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes.
    max_steps (unsigned int) (default: infty) maximum number of steps.
- cofactor-term-ite eliminate term if-the-else using cofactors.
    cofactor_equalities (bool) (default: true) use equalities to rewrite bodies of ite-expressions. This is potentially expensive.
- collect-statistics Collects various statistics.
- ctx-simplify apply contextual simplification rules.
    max_depth (unsigned int) (default: 1024) maximum term depth.
    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes.
    max_steps (unsigned int) (default: infty) maximum number of steps.
    propagate_eq (bool) (default: false) enable equality propagation from bounds.
- der destructive equality resolution.
- distribute-forall distribute forall over conjunctions.
- dom-simplify apply dominator simplification rules.
- elim-term-ite eliminate term if-then-else by adding fresh auxiliary declarations.
    max_args (unsigned int) (default: 128) maximum number of arguments (per application) that will be considered by the greedy (quadratic) heuristic.
    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes.
    max_steps (unsigned int) (default: infty) maximum number of steps.
- elim-uncnstr eliminate application containing unconstrained variables.
    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes.
    max_steps (unsigned int) (default: infty) maximum number of steps.
- injectivity Identifies and applies injectivity axioms.
    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes.
    produce_models (bool) (default: false) model generation.
- snf put goal in skolem normal form.
    ignore_labels (bool) remove/ignore labels in the input formula, this option is ignored if proofs are enabled (default: false)
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    mode (symbol) NNF translation mode: skolem (skolem normal form), quantifiers (skolem normal form + quantifiers in NNF), full (default: skolem)
    sk_hack (bool) hack for VCC (default: false)
- nnf put goal in negation normal form.
    ignore_labels (bool) remove/ignore labels in the input formula, this option is ignored if proofs are enabled (default: false)
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    mode (symbol) NNF translation mode: skolem (skolem normal form), quantifiers (skolem normal form + quantifiers in NNF), full (default: skolem)
    sk_hack (bool) hack for VCC (default: false)
- occf put goal in one constraint per clause normal form (notes: fails if proof generation is enabled; only clauses are considered).
- pb-preprocess pre-process pseudo-Boolean constraints a la Davis Putnam.
- propagate-values propagate constants.
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    max_rounds (unsigned int) (default: 4) maximum number of rounds.
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    rewrite_patterns (bool) rewrite patterns. (default: false)
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
- reduce-args reduce the number of arguments of function applications, when for all occurrences of a function f the i-th is a value.
- reduce-invertible reduce invertible variable occurrences.
- simplify apply simplification rules.
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    rewrite_patterns (bool) rewrite patterns. (default: false)
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
- elim-and convert (and a b) into (not (or (not a) (not b))).
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    rewrite_patterns (bool) rewrite patterns. (default: false)
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
- solve-eqs eliminate variables by solving equations.
    context_solve (bool) (default: false) solve equalities under disjunctions.
    ite_solver (bool) (default: true) use if-then-else solver.
    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations.
    theory_solver (bool) (default: true) use theory solvers.
- special-relations detect and replace by special relations.
- split-clause split a clause in many subgoals.
    split_largest_clause (bool) (default: false) split the largest clause in the goal.
- symmetry-reduce apply symmetry reduction.
- tseitin-cnf convert goal into CNF using tseitin-like encoding (note: quantifiers are ignored).
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    common_patterns (bool) (default: true) minimize the number of auxiliary variables during CNF encoding by identifing commonly used patterns
    distributivity (bool) (default: true) minimize the number of auxiliary variables during CNF encoding by applying distributivity over unshared subformulas
    distributivity_blowup (unsigned int) (default: 32) maximum overhead for applying distributivity during CNF encoding
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    ite_chaing (bool) (default: true) minimize the number of auxiliary variables during CNF encoding by identifing if-then-else chains
    ite_extra (bool) (default: true) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes.
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    rewrite_patterns (bool) rewrite patterns. (default: false)
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
- tseitin-cnf-core convert goal into CNF using tseitin-like encoding (note: quantifiers are ignored). This tactic does not apply required simplifications to the input goal like the tseitin-cnf tactic.
    common_patterns (bool) (default: true) minimize the number of auxiliary variables during CNF encoding by identifing commonly used patterns
    distributivity (bool) (default: true) minimize the number of auxiliary variables during CNF encoding by applying distributivity over unshared subformulas
    distributivity_blowup (unsigned int) (default: 32) maximum overhead for applying distributivity during CNF encoding
    ite_chaing (bool) (default: true) minimize the number of auxiliary variables during CNF encoding by identifing if-then-else chains
    ite_extra (bool) (default: true) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas
    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes.
- qffd builtin strategy for solving QF_FD problems.
    abce (bool) eliminate blocked clauses using asymmetric literals (default: false)
    acce (bool) eliminate covered clauses using asymmetric added literals (default: false)
    anf (bool) enable ANF based simplification in-processing (default: false)
    anf.delay (unsigned int) delay ANF simplification by in-processing round (default: 2)
    anf.exlin (bool) enable extended linear simplification (default: false)
    asymm_branch (bool) asymmetric branching (default: true)
    asymm_branch.all (bool) asymmetric branching on all literals per clause (default: false)
    asymm_branch.delay (unsigned int) number of simplification rounds to wait until invoking asymmetric branch simplification (default: 1)
    asymm_branch.limit (unsigned int) approx. maximum number of literals visited during asymmetric branching (default: 100000000)
    asymm_branch.rounds (unsigned int) maximal number of rounds to run asymmetric branch simplifications if progress is made (default: 2)
    asymm_branch.sampled (bool) use sampling based asymmetric branching based on binary implication graph (default: true)
    ate (bool) asymmetric tautology elimination (default: true)
    backtrack.conflicts (unsigned int) number of conflicts before enabling chronological backtracking (default: 4000)
    backtrack.scopes (unsigned int) number of scopes to enable chronological backtracking (default: 100)
    bca (bool) blocked clause addition - add blocked binary clauses (default: false)
    bce (bool) eliminate blocked clauses (default: false)
    bce_at (unsigned int) eliminate blocked clauses only once at the given simplification round (default: 2)
    bce_delay (unsigned int) delay eliminate blocked clauses until simplification round (default: 2)
    binspr (bool) enable SPR inferences of binary propagation redundant clauses. This inprocessing step eliminates models (default: false)
    blocked_clause_limit (unsigned int) maximum number of literals visited during blocked clause elimination (default: 100000000)
    branching.anti_exploration (bool) apply anti-exploration heuristic for branch selection (default: false)
    branching.heuristic (symbol) branching heuristic vsids, chb (default: vsids)
    burst_search (unsigned int) number of conflicts before first global simplification (default: 100)
    cancel_backup_file (symbol) file to save partial search state if search is canceled (default: )
    cardinality.encoding (symbol) encoding used for at-most-k constraints: grouped, bimander, ordered, unate, circuit (default: grouped)
    cardinality.solver (bool) use cardinality solver (default: true)
    cce (bool) eliminate covered clauses (default: false)
    compact (bool) try to compact function graph (i.e., function interpretations that are lookup tables) (default: true)
    completion (bool) enable/disable model completion (default: false)
    core.minimize (bool) minimize computed core (default: false)
    core.minimize_partial (bool) apply partial (cheap) core minimization (default: false)
    ctrl_c (bool) enable interrupts from ctrl-c (default: true)
    cut (bool) enable AIG based simplification in-processing (default: false)
    cut.aig (bool) extract aigs (and ites) from cluases for cut simplification (default: false)
    cut.delay (unsigned int) delay cut simplification by in-processing round (default: 2)
    cut.dont_cares (bool) integrate dont cares with cuts (default: true)
    cut.force (bool) force redoing cut-enumeration until a fixed-point (default: false)
    cut.lut (bool) extract luts from clauses for cut simplification (default: false)
    cut.npn3 (bool) extract 3 input functions from clauses for cut simplification (default: false)
    cut.redundancies (bool) integrate redundancy checking of cuts (default: true)
    cut.xor (bool) extract xors from clauses for cut simplification (default: false)
    ddfw.init_clause_weight (unsigned int) initial clause weight for DDFW local search (default: 8)
    ddfw.reinit_base (unsigned int) increment basis for geometric backoff scheme of re-initialization of weights (default: 10000)
    ddfw.restart_base (unsigned int) number of flips used a starting point for hessitant restart backoff (default: 100000)
    ddfw.threads (unsigned int) number of ddfw threads to run in parallel with sat solver (default: 0)
    ddfw.use_reward_pct (unsigned int) percentage to pick highest reward variable when it has reward 0 (default: 15)
    ddfw_search (bool) use ddfw local search instead of CDCL (default: false)
    dimacs.core (bool) extract core from DIMACS benchmarks (default: false)
    drat.activity (bool) dump variable activities (default: false)
    drat.binary (bool) use Binary DRAT output format (default: false)
    drat.check_sat (bool) build up internal trace, check satisfying model (default: false)
    drat.check_unsat (bool) build up internal proof and check (default: false)
    drat.file (symbol) file to dump DRAT proofs (default: )
    dyn_sub_res (bool) dynamic subsumption resolution for minimizing learned clauses (default: true)
    elim_vars (bool) enable variable elimination using resolution during simplification (default: true)
    elim_vars_bdd (bool) enable variable elimination using BDD recompilation during simplification (default: true)
    elim_vars_bdd_delay (unsigned int) delay elimination of variables using BDDs until after simplification round (default: 3)
    enable_pre_simplify (bool) enable pre simplifications before the bounded search (default: false)
    enforce_model_conversion (bool) apply model transformation on new assertions (default: false)
    force_cleanup (bool) force cleanup to remove tautologies and simplify clauses (default: false)
    gc (symbol) garbage collection strategy: psm, glue, glue_psm, dyn_psm (default: glue_psm)
    gc.burst (bool) perform eager garbage collection during initialization (default: false)
    gc.defrag (bool) defragment clauses when garbage collecting (default: true)
    gc.increment (unsigned int) increment to the garbage collection threshold (default: 500)
    gc.initial (unsigned int) learned clauses garbage collection frequency (default: 20000)
    gc.k (unsigned int) learned clauses that are inactive for k gc rounds are permanently deleted (only used in dyn_psm) (default: 7)
    gc.small_lbd (unsigned int) learned clauses with small LBD are never deleted (only used in dyn_psm) (default: 3)
    inline_def (bool) inline local function definitions ignoring possible expansion (default: false)
    inprocess.max (unsigned int) maximal number of inprocessing passes (default: 4294967295)
    inprocess.out (symbol) file to dump result of the first inprocessing step and exit (default: )
    ite_extra (bool) (default: true) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas
    keep_cardinality_constraints (bool) (default: false) retain cardinality constraints (don't bit-blast them) and use built-in cardinality solver
    local_search (bool) use local search instead of CDCL (default: false)
    local_search_dbg_flips (bool) write debug information for number of flips (default: false)
    local_search_mode (symbol) local search algorithm, either default wsat or qsat (default: wsat)
    local_search_threads (unsigned int) number of local search threads to find satisfiable solution (default: 0)
    lookahead.cube.cutoff (symbol) cutoff type used to create lookahead cubes: depth, freevars, psat, adaptive_freevars, adaptive_psat (default: depth)
    lookahead.cube.depth (unsigned int) cut-off depth to create cubes. Used when lookahead.cube.cutoff is depth. (default: 1)
    lookahead.cube.fraction (double) adaptive fraction to create lookahead cubes. Used when lookahead.cube.cutoff is adaptive_freevars or adaptive_psat (default: 0.4)
    lookahead.cube.freevars (double) cube free variable fraction. Used when lookahead.cube.cutoff is freevars (default: 0.8)
    lookahead.cube.psat.clause_base (double) clause base for PSAT cutoff (default: 2)
    lookahead.cube.psat.trigger (double) trigger value to create lookahead cubes for PSAT cutoff. Used when lookahead.cube.cutoff is psat (default: 5)
    lookahead.cube.psat.var_exp (double) free variable exponent for PSAT cutoff (default: 1)
    lookahead.delta_fraction (double) number between 0 and 1, the smaller the more literals are selected for double lookahead (default: 1.0)
    lookahead.double (bool) enable doubld lookahead (default: true)
    lookahead.global_autarky (bool) prefer to branch on variables that occur in clauses that are reduced (default: false)
    lookahead.preselect (bool) use pre-selection of subset of variables for branching (default: false)
    lookahead.reward (symbol) select lookahead heuristic: ternary, heule_schur (Heule Schur), heuleu (Heule Unit), unit, or march_cu (default: march_cu)
    lookahead.use_learned (bool) use learned clauses when selecting lookahead literal (default: false)
    lookahead_scores (bool) extract lookahead scores. A utility that can only be used from the DIMACS front-end (default: false)
    lookahead_simplify (bool) use lookahead solver during simplification (default: false)
    lookahead_simplify.bca (bool) add learned binary clauses as part of lookahead simplification (default: true)
    max_conflicts (unsigned int) maximum number of conflicts (default: 4294967295)
    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes.
    minimize_lemmas (bool) minimize learned clauses (default: true)
    override_incremental (bool) override incremental safety gaps. Enable elimination of blocked clauses and variables even if solver is reused (default: false)
    partial (bool) enable/disable partial function interpretations (default: false)
    pb.lemma_format (symbol) generate either cardinality or pb lemmas (default: cardinality)
    pb.min_arity (unsigned int) minimal arity to compile pb/cardinality constraints to CNF (default: 9)
    pb.resolve (symbol) resolution strategy for boolean algebra solver: cardinality, rounding (default: cardinality)
    pb.solver (symbol) method for handling Pseudo-Boolean constraints: circuit (arithmetical circuit), sorting (sorting circuit), totalizer (use totalizer encoding), binary_merge, segmented, solver (use native solver) (default: solver)
    phase (symbol) phase selection strategy: always_false, always_true, basic_caching, random, caching (default: caching)
    phase.sticky (bool) use sticky phase caching (default: true)
    prob_search (bool) use probsat local search instead of CDCL (default: false)
    probing (bool) apply failed literal detection during simplification (default: true)
    probing_binary (bool) probe binary clauses (default: true)
    probing_cache (bool) add binary literals as lemmas (default: true)
    probing_cache_limit (unsigned int) cache binaries unless overall memory usage exceeds cache limit (default: 1024)
    probing_limit (unsigned int) limit to the number of probe calls (default: 5000000)
    propagate.prefetch (bool) prefetch watch lists for assigned literals (default: true)
    random_freq (double) frequency of random case splits (default: 0.01)
    random_seed (unsigned int) random seed (default: 0)
    reorder.activity_scale (unsigned int) scaling factor for activity update (default: 100)
    reorder.base (unsigned int) number of conflicts per random reorder  (default: 4294967295)
    reorder.itau (double) inverse temperature for softmax (default: 4.0)
    rephase.base (unsigned int) number of conflicts per rephase  (default: 1000)
    resolution.cls_cutoff1 (unsigned int) limit1 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 100000000)
    resolution.cls_cutoff2 (unsigned int) limit2 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 700000000)
    resolution.limit (unsigned int) approx. maximum number of literals visited during variable elimination (default: 500000000)
    resolution.lit_cutoff_range1 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 700)
    resolution.lit_cutoff_range2 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 400)
    resolution.lit_cutoff_range3 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 300)
    resolution.occ_cutoff (unsigned int) first cutoff (on number of positive/negative occurrences) for Boolean variable elimination (default: 10)
    resolution.occ_cutoff_range1 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 8)
    resolution.occ_cutoff_range2 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 5)
    resolution.occ_cutoff_range3 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 3)
    restart (symbol) restart strategy: static, luby, ema or geometric (default: ema)
    restart.emafastglue (double) ema alpha factor for fast moving average (default: 0.03)
    restart.emaslowglue (double) ema alpha factor for slow moving average (default: 1e-05)
    restart.factor (double) restart increment factor for geometric strategy (default: 1.5)
    restart.fast (bool) use fast restart approach only removing less active literals. (default: true)
    restart.initial (unsigned int) initial restart (number of conflicts) (default: 2)
    restart.margin (double) margin between fast and slow restart factors. For ema (default: 1.1)
    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)
    retain_blocked_clauses (bool) retain blocked clauses as lemmas (default: true)
    rlimit (unsigned int) default resource limit used for solvers. Unrestricted when set to 0. (default: 0)
    scc (bool) eliminate Boolean variables by computing strongly connected components (default: true)
    scc.tr (bool) apply transitive reduction, eliminate redundant binary clauses (default: true)
    search.sat.conflicts (unsigned int) period for solving for sat (in number of conflicts) (default: 400)
    search.unsat.conflicts (unsigned int) period for solving for unsat (in number of conflicts) (default: 400)
    simplify.delay (unsigned int) set initial delay of simplification by a conflict count (default: 0)
    smtlib2_log (symbol) file to save solver interaction (default: )
    subsumption (bool) eliminate subsumed clauses (default: true)
    subsumption.limit (unsigned int) approx. maximum number of literals visited during subsumption (and subsumption resolution) (default: 100000000)
    threads (unsigned int) number of parallel threads to use (default: 1)
    timeout (unsigned int) timeout on the solver object; overwrites a global timeout (default: 4294967295)
    v1 (bool) use Z3 version 1.x pretty printer (default: false)
    v2 (bool) use Z3 version 2.x (x <= 16) pretty printer (default: false)
    variable_decay (unsigned int) multiplier (divided by 100) for the VSIDS activity increment (default: 110)
- pqffd builtin strategy for solving QF_FD problems in parallel.
- smtfd builtin strategy for solving SMT problems by reduction to FD.
    abce (bool) eliminate blocked clauses using asymmetric literals (default: false)
    acce (bool) eliminate covered clauses using asymmetric added literals (default: false)
    anf (bool) enable ANF based simplification in-processing (default: false)
    anf.delay (unsigned int) delay ANF simplification by in-processing round (default: 2)
    anf.exlin (bool) enable extended linear simplification (default: false)
    asymm_branch (bool) asymmetric branching (default: true)
    asymm_branch.all (bool) asymmetric branching on all literals per clause (default: false)
    asymm_branch.delay (unsigned int) number of simplification rounds to wait until invoking asymmetric branch simplification (default: 1)
    asymm_branch.limit (unsigned int) approx. maximum number of literals visited during asymmetric branching (default: 100000000)
    asymm_branch.rounds (unsigned int) maximal number of rounds to run asymmetric branch simplifications if progress is made (default: 2)
    asymm_branch.sampled (bool) use sampling based asymmetric branching based on binary implication graph (default: true)
    ate (bool) asymmetric tautology elimination (default: true)
    backtrack.conflicts (unsigned int) number of conflicts before enabling chronological backtracking (default: 4000)
    backtrack.scopes (unsigned int) number of scopes to enable chronological backtracking (default: 100)
    bca (bool) blocked clause addition - add blocked binary clauses (default: false)
    bce (bool) eliminate blocked clauses (default: false)
    bce_at (unsigned int) eliminate blocked clauses only once at the given simplification round (default: 2)
    bce_delay (unsigned int) delay eliminate blocked clauses until simplification round (default: 2)
    binspr (bool) enable SPR inferences of binary propagation redundant clauses. This inprocessing step eliminates models (default: false)
    blocked_clause_limit (unsigned int) maximum number of literals visited during blocked clause elimination (default: 100000000)
    branching.anti_exploration (bool) apply anti-exploration heuristic for branch selection (default: false)
    branching.heuristic (symbol) branching heuristic vsids, chb (default: vsids)
    burst_search (unsigned int) number of conflicts before first global simplification (default: 100)
    cancel_backup_file (symbol) file to save partial search state if search is canceled (default: )
    cardinality.encoding (symbol) encoding used for at-most-k constraints: grouped, bimander, ordered, unate, circuit (default: grouped)
    cardinality.solver (bool) use cardinality solver (default: true)
    cce (bool) eliminate covered clauses (default: false)
    compact (bool) try to compact function graph (i.e., function interpretations that are lookup tables) (default: true)
    completion (bool) enable/disable model completion (default: false)
    core.minimize (bool) minimize computed core (default: false)
    core.minimize_partial (bool) apply partial (cheap) core minimization (default: false)
    ctrl_c (bool) enable interrupts from ctrl-c (default: true)
    cut (bool) enable AIG based simplification in-processing (default: false)
    cut.aig (bool) extract aigs (and ites) from cluases for cut simplification (default: false)
    cut.delay (unsigned int) delay cut simplification by in-processing round (default: 2)
    cut.dont_cares (bool) integrate dont cares with cuts (default: true)
    cut.force (bool) force redoing cut-enumeration until a fixed-point (default: false)
    cut.lut (bool) extract luts from clauses for cut simplification (default: false)
    cut.npn3 (bool) extract 3 input functions from clauses for cut simplification (default: false)
    cut.redundancies (bool) integrate redundancy checking of cuts (default: true)
    cut.xor (bool) extract xors from clauses for cut simplification (default: false)
    ddfw.init_clause_weight (unsigned int) initial clause weight for DDFW local search (default: 8)
    ddfw.reinit_base (unsigned int) increment basis for geometric backoff scheme of re-initialization of weights (default: 10000)
    ddfw.restart_base (unsigned int) number of flips used a starting point for hessitant restart backoff (default: 100000)
    ddfw.threads (unsigned int) number of ddfw threads to run in parallel with sat solver (default: 0)
    ddfw.use_reward_pct (unsigned int) percentage to pick highest reward variable when it has reward 0 (default: 15)
    ddfw_search (bool) use ddfw local search instead of CDCL (default: false)
    dimacs.core (bool) extract core from DIMACS benchmarks (default: false)
    drat.activity (bool) dump variable activities (default: false)
    drat.binary (bool) use Binary DRAT output format (default: false)
    drat.check_sat (bool) build up internal trace, check satisfying model (default: false)
    drat.check_unsat (bool) build up internal proof and check (default: false)
    drat.file (symbol) file to dump DRAT proofs (default: )
    dyn_sub_res (bool) dynamic subsumption resolution for minimizing learned clauses (default: true)
    elim_vars (bool) enable variable elimination using resolution during simplification (default: true)
    elim_vars_bdd (bool) enable variable elimination using BDD recompilation during simplification (default: true)
    elim_vars_bdd_delay (unsigned int) delay elimination of variables using BDDs until after simplification round (default: 3)
    enable_pre_simplify (bool) enable pre simplifications before the bounded search (default: false)
    enforce_model_conversion (bool) apply model transformation on new assertions (default: false)
    force_cleanup (bool) force cleanup to remove tautologies and simplify clauses (default: false)
    gc (symbol) garbage collection strategy: psm, glue, glue_psm, dyn_psm (default: glue_psm)
    gc.burst (bool) perform eager garbage collection during initialization (default: false)
    gc.defrag (bool) defragment clauses when garbage collecting (default: true)
    gc.increment (unsigned int) increment to the garbage collection threshold (default: 500)
    gc.initial (unsigned int) learned clauses garbage collection frequency (default: 20000)
    gc.k (unsigned int) learned clauses that are inactive for k gc rounds are permanently deleted (only used in dyn_psm) (default: 7)
    gc.small_lbd (unsigned int) learned clauses with small LBD are never deleted (only used in dyn_psm) (default: 3)
    inline_def (bool) inline local function definitions ignoring possible expansion (default: false)
    inprocess.max (unsigned int) maximal number of inprocessing passes (default: 4294967295)
    inprocess.out (symbol) file to dump result of the first inprocessing step and exit (default: )
    ite_extra (bool) (default: true) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas
    keep_cardinality_constraints (bool) (default: false) retain cardinality constraints (don't bit-blast them) and use built-in cardinality solver
    local_search (bool) use local search instead of CDCL (default: false)
    local_search_dbg_flips (bool) write debug information for number of flips (default: false)
    local_search_mode (symbol) local search algorithm, either default wsat or qsat (default: wsat)
    local_search_threads (unsigned int) number of local search threads to find satisfiable solution (default: 0)
    lookahead.cube.cutoff (symbol) cutoff type used to create lookahead cubes: depth, freevars, psat, adaptive_freevars, adaptive_psat (default: depth)
    lookahead.cube.depth (unsigned int) cut-off depth to create cubes. Used when lookahead.cube.cutoff is depth. (default: 1)
    lookahead.cube.fraction (double) adaptive fraction to create lookahead cubes. Used when lookahead.cube.cutoff is adaptive_freevars or adaptive_psat (default: 0.4)
    lookahead.cube.freevars (double) cube free variable fraction. Used when lookahead.cube.cutoff is freevars (default: 0.8)
    lookahead.cube.psat.clause_base (double) clause base for PSAT cutoff (default: 2)
    lookahead.cube.psat.trigger (double) trigger value to create lookahead cubes for PSAT cutoff. Used when lookahead.cube.cutoff is psat (default: 5)
    lookahead.cube.psat.var_exp (double) free variable exponent for PSAT cutoff (default: 1)
    lookahead.delta_fraction (double) number between 0 and 1, the smaller the more literals are selected for double lookahead (default: 1.0)
    lookahead.double (bool) enable doubld lookahead (default: true)
    lookahead.global_autarky (bool) prefer to branch on variables that occur in clauses that are reduced (default: false)
    lookahead.preselect (bool) use pre-selection of subset of variables for branching (default: false)
    lookahead.reward (symbol) select lookahead heuristic: ternary, heule_schur (Heule Schur), heuleu (Heule Unit), unit, or march_cu (default: march_cu)
    lookahead.use_learned (bool) use learned clauses when selecting lookahead literal (default: false)
    lookahead_scores (bool) extract lookahead scores. A utility that can only be used from the DIMACS front-end (default: false)
    lookahead_simplify (bool) use lookahead solver during simplification (default: false)
    lookahead_simplify.bca (bool) add learned binary clauses as part of lookahead simplification (default: true)
    max_lemmas (unsigned int) maximal number of lemmas per round (default: 10)
    max_conflicts (unsigned int) maximum number of conflicts (default: 4294967295)
    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes.
    minimize_lemmas (bool) minimize learned clauses (default: true)
    override_incremental (bool) override incremental safety gaps. Enable elimination of blocked clauses and variables even if solver is reused (default: false)
    partial (bool) enable/disable partial function interpretations (default: false)
    pb.lemma_format (symbol) generate either cardinality or pb lemmas (default: cardinality)
    pb.min_arity (unsigned int) minimal arity to compile pb/cardinality constraints to CNF (default: 9)
    pb.resolve (symbol) resolution strategy for boolean algebra solver: cardinality, rounding (default: cardinality)
    pb.solver (symbol) method for handling Pseudo-Boolean constraints: circuit (arithmetical circuit), sorting (sorting circuit), totalizer (use totalizer encoding), binary_merge, segmented, solver (use native solver) (default: solver)
    phase (symbol) phase selection strategy: always_false, always_true, basic_caching, random, caching (default: caching)
    phase.sticky (bool) use sticky phase caching (default: true)
    prob_search (bool) use probsat local search instead of CDCL (default: false)
    probing (bool) apply failed literal detection during simplification (default: true)
    probing_binary (bool) probe binary clauses (default: true)
    probing_cache (bool) add binary literals as lemmas (default: true)
    probing_cache_limit (unsigned int) cache binaries unless overall memory usage exceeds cache limit (default: 1024)
    probing_limit (unsigned int) limit to the number of probe calls (default: 5000000)
    propagate.prefetch (bool) prefetch watch lists for assigned literals (default: true)
    random_freq (double) frequency of random case splits (default: 0.01)
    random_seed (unsigned int) random seed (default: 0)
    reorder.activity_scale (unsigned int) scaling factor for activity update (default: 100)
    reorder.base (unsigned int) number of conflicts per random reorder  (default: 4294967295)
    reorder.itau (double) inverse temperature for softmax (default: 4.0)
    rephase.base (unsigned int) number of conflicts per rephase  (default: 1000)
    resolution.cls_cutoff1 (unsigned int) limit1 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 100000000)
    resolution.cls_cutoff2 (unsigned int) limit2 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 700000000)
    resolution.limit (unsigned int) approx. maximum number of literals visited during variable elimination (default: 500000000)
    resolution.lit_cutoff_range1 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 700)
    resolution.lit_cutoff_range2 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 400)
    resolution.lit_cutoff_range3 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 300)
    resolution.occ_cutoff (unsigned int) first cutoff (on number of positive/negative occurrences) for Boolean variable elimination (default: 10)
    resolution.occ_cutoff_range1 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 8)
    resolution.occ_cutoff_range2 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 5)
    resolution.occ_cutoff_range3 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 3)
    restart (symbol) restart strategy: static, luby, ema or geometric (default: ema)
    restart.emafastglue (double) ema alpha factor for fast moving average (default: 0.03)
    restart.emaslowglue (double) ema alpha factor for slow moving average (default: 1e-05)
    restart.factor (double) restart increment factor for geometric strategy (default: 1.5)
    restart.fast (bool) use fast restart approach only removing less active literals. (default: true)
    restart.initial (unsigned int) initial restart (number of conflicts) (default: 2)
    restart.margin (double) margin between fast and slow restart factors. For ema (default: 1.1)
    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)
    retain_blocked_clauses (bool) retain blocked clauses as lemmas (default: true)
    rlimit (unsigned int) default resource limit used for solvers. Unrestricted when set to 0. (default: 0)
    scc (bool) eliminate Boolean variables by computing strongly connected components (default: true)
    scc.tr (bool) apply transitive reduction, eliminate redundant binary clauses (default: true)
    search.sat.conflicts (unsigned int) period for solving for sat (in number of conflicts) (default: 400)
    search.unsat.conflicts (unsigned int) period for solving for unsat (in number of conflicts) (default: 400)
    simplify.delay (unsigned int) set initial delay of simplification by a conflict count (default: 0)
    smtlib2_log (symbol) file to save solver interaction (default: )
    subsumption (bool) eliminate subsumed clauses (default: true)
    subsumption.limit (unsigned int) approx. maximum number of literals visited during subsumption (and subsumption resolution) (default: 100000000)
    threads (unsigned int) number of parallel threads to use (default: 1)
    timeout (unsigned int) timeout on the solver object; overwrites a global timeout (default: 4294967295)
    v1 (bool) use Z3 version 1.x pretty printer (default: false)
    v2 (bool) use Z3 version 2.x (x <= 16) pretty printer (default: false)
    variable_decay (unsigned int) multiplier (divided by 100) for the VSIDS activity increment (default: 110)
- fpa2bv convert floating point numbers to bit-vectors.
- qffp (try to) solve goal using the tactic for QF_FP.
    abce (bool) eliminate blocked clauses using asymmetric literals (default: false)
    acce (bool) eliminate covered clauses using asymmetric added literals (default: false)
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    anf (bool) enable ANF based simplification in-processing (default: false)
    anf.delay (unsigned int) delay ANF simplification by in-processing round (default: 2)
    anf.exlin (bool) enable extended linear simplification (default: false)
    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)
    arith.bounded_expansion (bool) box variables used in branch and bound into bound assumptions (default: false)
    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)
    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)
    arith.cheap_eqs (unsigned int) 0 - do not run, 1 - use tree, 2 - use table (default: 1)
    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)
    arith.eager_eq_axioms (bool) eager equality axioms (default: true)
    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)
    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)
    arith.ignore_int (bool) treat integer variables as real (default: false)
    arith.int_eq_branch (bool) branching using derived integer equations (default: false)
    arith.min (bool) minimize cost (default: false)
    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.branching (bool) branching on integer variables in non linear clusters, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.expp (bool) expensive patching (default: false)
    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)
    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)
    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)
    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)
    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)
    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)
    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)
    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)
    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.horner (bool) run horner's heuristic (default: true)
    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)
    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)
    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.nra (bool) call nra_solver when incremental lianirization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)
    arith.nl.order (bool) run order lemmas (default: true)
    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)
    arith.nl.tangents (bool) run tangent lemmas (default: true)
    arith.print_ext_var_names (bool) print external variable names (default: false)
    arith.print_stats (bool) print statistic (default: false)
    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)
    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine bounds (default: 2)
    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)
    arith.reflect (bool) reflect arithmetical operators to the congruence closure (default: true)
    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)
    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)
    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    array.extensional (bool) extensional array theory (default: true)
    array.weak (bool) weak array theory (default: false)
    asymm_branch (bool) asymmetric branching (default: true)
    asymm_branch.all (bool) asymmetric branching on all literals per clause (default: false)
    asymm_branch.delay (unsigned int) number of simplification rounds to wait until invoking asymmetric branch simplification (default: 1)
    asymm_branch.limit (unsigned int) approx. maximum number of literals visited during asymmetric branching (default: 100000000)
    asymm_branch.rounds (unsigned int) maximal number of rounds to run asymmetric branch simplifications if progress is made (default: 2)
    asymm_branch.sampled (bool) use sampling based asymmetric branching based on binary implication graph (default: true)
    ate (bool) asymmetric tautology elimination (default: true)
    auto_config (bool) automatically configure solver (default: true)
    backtrack.conflicts (unsigned int) number of conflicts before enabling chronological backtracking (default: 4000)
    backtrack.scopes (unsigned int) number of scopes to enable chronological backtracking (default: 100)
    bca (bool) blocked clause addition - add blocked binary clauses (default: false)
    bce (bool) eliminate blocked clauses (default: false)
    bce_at (unsigned int) eliminate blocked clauses only once at the given simplification round (default: 2)
    bce_delay (unsigned int) delay eliminate blocked clauses until simplification round (default: 2)
    binspr (bool) enable SPR inferences of binary propagation redundant clauses. This inprocessing step eliminates models (default: false)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_add (bool) (default: true) bit-blast adders.
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    blast_full (bool) (default: false) bit-blast any term with bit-vector sort, this option will make E-matching ineffective in any pattern containing bit-vector terms.
    blast_mul (bool) (default: true) bit-blast multipliers (and dividers, remainders).
    blast_quant (bool) (default: false) bit-blast quantified variables.
    blocked_clause_limit (unsigned int) maximum number of literals visited during blocked clause elimination (default: 100000000)
    branching.anti_exploration (bool) apply anti-exploration heuristic for branch selection (default: false)
    branching.heuristic (symbol) branching heuristic vsids, chb (default: vsids)
    burst_search (unsigned int) number of conflicts before first global simplification (default: 100)
    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)
    bv.reflect (bool) create enode for every bit-vector term (default: true)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    candidate_models (bool) (default: false) create candidate models even when quantifier or theory reasoning is incomplete.
    cardinality.encoding (symbol) encoding used for at-most-k constraints: grouped, bimander, ordered, unate, circuit (default: grouped)
    cardinality.solver (bool) use cardinality solver (default: true)
    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)
    cce (bool) eliminate covered clauses (default: false)
    check_lemmas (bool) check lemmas on the fly using an independent nlsat solver (default: false)
    clause_proof (bool) record a clausal proof (default: false)
    common_patterns (bool) (default: true) minimize the number of auxiliary variables during CNF encoding by identifing commonly used patterns
    complete (bool) (default: true) add constraints to make sure that any interpretation of a underspecified arithmetic operators is a function. The result will include additional uninterpreted functions/constants: /0, div0, mod0, 0^0, neg-root
    context_solve (bool) (default: false) solve equalities under disjunctions.
    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)
    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)
    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)
    core.minimize (bool) minimize unsat core produced by SMT context (default: false)
    core.minimize_partial (bool) apply partial (cheap) core minimization (default: false)
    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)
    cut (bool) enable AIG based simplification in-processing (default: false)
    cut.aig (bool) extract aigs (and ites) from cluases for cut simplification (default: false)
    cut.delay (unsigned int) delay cut simplification by in-processing round (default: 2)
    cut.dont_cares (bool) integrate dont cares with cuts (default: true)
    cut.force (bool) force redoing cut-enumeration until a fixed-point (default: false)
    cut.lut (bool) extract luts from clauses for cut simplification (default: false)
    cut.npn3 (bool) extract 3 input functions from clauses for cut simplification (default: false)
    cut.redundancies (bool) integrate redundancy checking of cuts (default: true)
    cut.xor (bool) extract xors from clauses for cut simplification (default: false)
    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)
    dack.eq (bool) enable dynamic ackermannization for transtivity of equalities (default: false)
    dack.factor (double) number of instance per conflict (default: 0.1)
    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)
    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)
    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)
    ddfw.init_clause_weight (unsigned int) initial clause weight for DDFW local search (default: 8)
    ddfw.reinit_base (unsigned int) increment basis for geometric backoff scheme of re-initialization of weights (default: 10000)
    ddfw.restart_base (unsigned int) number of flips used a starting point for hessitant restart backoff (default: 100000)
    ddfw.threads (unsigned int) number of ddfw threads to run in parallel with sat solver (default: 0)
    ddfw.use_reward_pct (unsigned int) percentage to pick highest reward variable when it has reward 0 (default: 15)
    ddfw_search (bool) use ddfw local search instead of CDCL (default: false)
    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)
    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)
    dimacs.core (bool) extract core from DIMACS benchmarks (default: false)
    distributivity (bool) (default: true) minimize the number of auxiliary variables during CNF encoding by applying distributivity over unshared subformulas
    distributivity_blowup (unsigned int) (default: 32) maximum overhead for applying distributivity during CNF encoding
    div0_ackermann_limit (unsigned int) a bound for number of congruence Ackermann lemmas for div0 modelling (default: 1000)
    drat.activity (bool) dump variable activities (default: false)
    drat.binary (bool) use Binary DRAT output format (default: false)
    drat.check_sat (bool) build up internal trace, check satisfying model (default: false)
    drat.check_unsat (bool) build up internal proof and check (default: false)
    drat.file (symbol) file to dump DRAT proofs (default: )
    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)
    dyn_sub_res (bool) dynamic subsumption resolution for minimizing learned clauses (default: true)
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_inverses (bool) (default: true) eliminate inverse trigonometric functions (asin, acos, atan).
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_root_objects (bool) (default: true) eliminate root objects.
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    elim_vars (bool) enable variable elimination using resolution during simplification (default: true)
    elim_vars_bdd (bool) enable variable elimination using BDD recompilation during simplification (default: true)
    elim_vars_bdd_delay (unsigned int) delay elimination of variables using BDDs until after simplification round (default: 3)
    ematching (bool) E-Matching based quantifier instantiation (default: true)
    enable_pre_simplify (bool) enable pre simplifications before the bounded search (default: false)
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    factor (bool) (default: true) factor polynomials.
    factor_max_prime (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step (default: 31)
    factor_num_primes (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)'s. This parameter specify the maximum number of finite factorizations to be considered, before lifiting and searching (default: 1)
    factor_search_size (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space (default: 5000)
    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    force_cleanup (bool) force cleanup to remove tautologies and simplify clauses (default: false)
    gc (symbol) garbage collection strategy: psm, glue, glue_psm, dyn_psm (default: glue_psm)
    gc.burst (bool) perform eager garbage collection during initialization (default: false)
    gc.defrag (bool) defragment clauses when garbage collecting (default: true)
    gc.increment (unsigned int) increment to the garbage collection threshold (default: 500)
    gc.initial (unsigned int) learned clauses garbage collection frequency (default: 20000)
    gc.k (unsigned int) learned clauses that are inactive for k gc rounds are permanently deleted (only used in dyn_psm) (default: 7)
    gc.small_lbd (unsigned int) learned clauses with small LBD are never deleted (only used in dyn_psm) (default: 3)
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_labels (bool) remove/ignore labels in the input formula, this option is ignored if proofs are enabled (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    induction (bool) enable generation of induction lemmas (default: false)
    inline_vars (bool) inline variables that can be isolated from equations (not supported in incremental mode) (default: false)
    inprocess.max (unsigned int) maximal number of inprocessing passes (default: 4294967295)
    inprocess.out (symbol) file to dump result of the first inprocessing step and exit (default: )
    ite_chaing (bool) (default: true) minimize the number of auxiliary variables during CNF encoding by identifing if-then-else chains
    ite_extra (bool) (default: true) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    ite_solver (bool) (default: true) use if-then-else solver.
    lazy (unsigned int) how lazy the solver is. (default: 0)
    learned (bool) (default: false) collect also learned clauses.
    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    local_search (bool) use local search instead of CDCL (default: false)
    local_search_dbg_flips (bool) write debug information for number of flips (default: false)
    local_search_mode (symbol) local search algorithm, either default wsat or qsat (default: wsat)
    local_search_threads (unsigned int) number of local search threads to find satisfiable solution (default: 0)
    log_lemmas (bool) display lemmas as self-contained SMT formulas (default: false)
    logic (symbol) logic used to setup the SMT solver (default: )
    lookahead.cube.cutoff (symbol) cutoff type used to create lookahead cubes: depth, freevars, psat, adaptive_freevars, adaptive_psat (default: depth)
    lookahead.cube.depth (unsigned int) cut-off depth to create cubes. Used when lookahead.cube.cutoff is depth. (default: 1)
    lookahead.cube.fraction (double) adaptive fraction to create lookahead cubes. Used when lookahead.cube.cutoff is adaptive_freevars or adaptive_psat (default: 0.4)
    lookahead.cube.freevars (double) cube free variable fraction. Used when lookahead.cube.cutoff is freevars (default: 0.8)
    lookahead.cube.psat.clause_base (double) clause base for PSAT cutoff (default: 2)
    lookahead.cube.psat.trigger (double) trigger value to create lookahead cubes for PSAT cutoff. Used when lookahead.cube.cutoff is psat (default: 5)
    lookahead.cube.psat.var_exp (double) free variable exponent for PSAT cutoff (default: 1)
    lookahead.delta_fraction (double) number between 0 and 1, the smaller the more literals are selected for double lookahead (default: 1.0)
    lookahead.double (bool) enable doubld lookahead (default: true)
    lookahead.global_autarky (bool) prefer to branch on variables that occur in clauses that are reduced (default: false)
    lookahead.preselect (bool) use pre-selection of subset of variables for branching (default: false)
    lookahead.reward (symbol) select lookahead heuristic: ternary, heule_schur (Heule Schur), heuleu (Heule Unit), unit, or march_cu (default: march_cu)
    lookahead.use_learned (bool) use learned clauses when selecting lookahead literal (default: false)
    lookahead_scores (bool) extract lookahead scores. A utility that can only be used from the DIMACS front-end (default: false)
    lookahead_simplify (bool) use lookahead solver during simplification (default: false)
    lookahead_simplify.bca (bool) add learned binary clauses as part of lookahead simplification (default: true)
    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)
    max_args (unsigned int) (default: 128) maximum number of arguments (per application) that will be considered by the greedy (quadratic) heuristic.
    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    max_prime (unsigned int) (default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step.
    max_rounds (unsigned int) (default: 4) maximum number of rounds.
    max_search_size (unsigned int) (default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space.
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)
    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)
    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )
    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)
    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)
    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)
    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)
    min_mag (unsigned int) Z3 represents algebraic numbers using a (square-free) polynomial p and an isolating interval (which contains one and only one root of p). This interval may be refined during the computations. This parameter specifies whether to cache the value of a refined interval or not. It says the minimal size of an interval for caching purposes is 1/2^16 (default: 16)
    minimize_conflicts (bool) minimize conflicts (default: false)
    minimize_lemmas (bool) minimize learned clauses (default: true)
    mode (symbol) NNF translation mode: skolem (skolem normal form), quantifiers (skolem normal form + quantifiers in NNF), full (default: skolem)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    nla2bv_bv_size (unsigned int) (default: 4) default bit-vector size used by nla2bv tactic.
    nla2bv_divisor (unsigned int) (default: 2) nla2bv tactic parameter.
    nla2bv_max_bv_size (unsigned int) (default: inf) maximum bit-vector size used by nla2bv tactic
    nla2bv_root (unsigned int) (default: 2) nla2bv tactic encodes reals into bit-vectors using expressions of the form a+b*sqrt(c), this parameter sets the value of c used in the encoding.
    num_primes (unsigned int) (default: 1) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)'s. This parameter specify the maximum number of finite factorizations to be considered, before lifiting and searching.
    override_incremental (bool) override incremental safety gaps. Enable elimination of blocked clauses and variables even if solver is reused (default: false)
    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)
    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)
    pb.lemma_format (symbol) generate either cardinality or pb lemmas (default: cardinality)
    pb.min_arity (unsigned int) minimal arity to compile pb/cardinality constraints to CNF (default: 9)
    pb.resolve (symbol) resolution strategy for boolean algebra solver: cardinality, rounding (default: cardinality)
    pb.solver (symbol) method for handling Pseudo-Boolean constraints: circuit (arithmetical circuit), sorting (sorting circuit), totalizer (use totalizer encoding), binary_merge, segmented, solver (use native solver) (default: solver)
    phase (symbol) phase selection strategy: always_false, always_true, basic_caching, random, caching (default: caching)
    phase.sticky (bool) use sticky phase caching (default: true)
    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)
    prob_search (bool) use probsat local search instead of CDCL (default: false)
    probing (bool) apply failed literal detection during simplification (default: true)
    probing_binary (bool) probe binary clauses (default: true)
    probing_cache (bool) add binary literals as lemmas (default: true)
    probing_cache_limit (unsigned int) cache binaries unless overall memory usage exceeds cache limit (default: 1024)
    probing_limit (unsigned int) limit to the number of probe calls (default: 5000000)
    propagate.prefetch (bool) prefetch watch lists for assigned literals (default: true)
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    pull_nested_quantifiers (bool) pull nested quantifiers (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))
    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)
    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)
    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)
    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)
    qi.profile (bool) profile quantifier instantiation (default: false)
    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)
    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)
    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)
    random_freq (double) frequency of random case splits (default: 0.01)
    random_seed (unsigned int) random seed for the smt solver (default: 0)
    randomize (bool) randomize selection of a witness in nlsat. (default: true)
    refine_inj_axioms (bool) refine injectivity axioms (default: true)
    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)
    reorder (bool) reorder variables. (default: true)
    reorder.activity_scale (unsigned int) scaling factor for activity update (default: 100)
    reorder.base (unsigned int) number of conflicts per random reorder  (default: 4294967295)
    reorder.itau (double) inverse temperature for softmax (default: 4.0)
    rephase.base (unsigned int) number of conflicts per rephase  (default: 1000)
    resolution.cls_cutoff1 (unsigned int) limit1 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 100000000)
    resolution.cls_cutoff2 (unsigned int) limit2 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 700000000)
    resolution.limit (unsigned int) approx. maximum number of literals visited during variable elimination (default: 500000000)
    resolution.lit_cutoff_range1 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 700)
    resolution.lit_cutoff_range2 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 400)
    resolution.lit_cutoff_range3 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 300)
    resolution.occ_cutoff (unsigned int) first cutoff (on number of positive/negative occurrences) for Boolean variable elimination (default: 10)
    resolution.occ_cutoff_range1 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 8)
    resolution.occ_cutoff_range2 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 5)
    resolution.occ_cutoff_range3 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 3)
    restart (symbol) restart strategy: static, luby, ema or geometric (default: ema)
    restart.emafastglue (double) ema alpha factor for fast moving average (default: 0.03)
    restart.emaslowglue (double) ema alpha factor for slow moving average (default: 1e-05)
    restart.factor (double) restart increment factor for geometric strategy (default: 1.5)
    restart.fast (bool) use fast restart approach only removing less active literals. (default: true)
    restart.initial (unsigned int) initial restart (number of conflicts) (default: 2)
    restart.margin (double) margin between fast and slow restart factors. For ema (default: 1.1)
    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)
    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)
    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)
    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)
    retain_blocked_clauses (bool) retain blocked clauses as lemmas (default: true)
    rewrite_patterns (bool) rewrite patterns. (default: false)
    scc (bool) eliminate Boolean variables by computing strongly connected components (default: true)
    scc.tr (bool) apply transitive reduction, eliminate redundant binary clauses (default: true)
    search.sat.conflicts (unsigned int) period for solving for sat (in number of conflicts) (default: 400)
    search.unsat.conflicts (unsigned int) period for solving for unsat (in number of conflicts) (default: 400)
    seed (unsigned int) random seed. (default: 0)
    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)
    seq.use_derivatives (bool) dev flag (not for users) enable derivative based unfolding of regex (default: false)
    seq.use_unicode (bool) dev flag (not for users) enable unicode semantics (default: false)
    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)
    shuffle_vars (bool) use a random variable order. (default: false)
    simplify.delay (unsigned int) set initial delay of simplification by a conflict count (default: 0)
    simplify_conflicts (bool) simplify conflicts using equalities before resolving them in nlsat solver. (default: true)
    sk_hack (bool) hack for VCC (default: false)
    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations.
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
    split_factors (bool) (default: true) apply simplifications such as (= (* p1 p2) 0) --> (or (= p1 0) (= p2 0)).
    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)
    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)
    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)
    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)
    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)
    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)
    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)
    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)
    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)
    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)
    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)
    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)
    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)
    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)
    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)
    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)
    subsumption (bool) eliminate subsumed clauses (default: true)
    subsumption.limit (unsigned int) approx. maximum number of literals visited during subsumption (and subsumption resolution) (default: 100000000)
    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)
    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)
    theory_solver (bool) (default: true) use theory solvers.
    threads (unsigned int) maximal number of parallel threads. (default: 1)
    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)
    variable_decay (unsigned int) multiplier (divided by 100) for the VSIDS activity increment (default: 110)
    zero_accuracy (unsigned int) one of the most time-consuming operations in the real algebraic number module is determining the sign of a polynomial evaluated at a sample point with non-rational algebraic number values. Let k be the value of this option. If k is 0, Z3 uses precise computation. Otherwise, the result of a polynomial evaluation is considered to be 0 if Z3 can show it is inside the interval (-1/2^k, 1/2^k) (default: 0)
- qffpbv (try to) solve goal using the tactic for QF_FPBV (floats+bit-vectors).
    abce (bool) eliminate blocked clauses using asymmetric literals (default: false)
    acce (bool) eliminate covered clauses using asymmetric added literals (default: false)
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    anf (bool) enable ANF based simplification in-processing (default: false)
    anf.delay (unsigned int) delay ANF simplification by in-processing round (default: 2)
    anf.exlin (bool) enable extended linear simplification (default: false)
    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)
    arith.bounded_expansion (bool) box variables used in branch and bound into bound assumptions (default: false)
    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)
    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)
    arith.cheap_eqs (unsigned int) 0 - do not run, 1 - use tree, 2 - use table (default: 1)
    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)
    arith.eager_eq_axioms (bool) eager equality axioms (default: true)
    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)
    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)
    arith.ignore_int (bool) treat integer variables as real (default: false)
    arith.int_eq_branch (bool) branching using derived integer equations (default: false)
    arith.min (bool) minimize cost (default: false)
    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.branching (bool) branching on integer variables in non linear clusters, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.expp (bool) expensive patching (default: false)
    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)
    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)
    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)
    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)
    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)
    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)
    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)
    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)
    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.horner (bool) run horner's heuristic (default: true)
    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)
    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)
    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.nra (bool) call nra_solver when incremental lianirization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)
    arith.nl.order (bool) run order lemmas (default: true)
    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)
    arith.nl.tangents (bool) run tangent lemmas (default: true)
    arith.print_ext_var_names (bool) print external variable names (default: false)
    arith.print_stats (bool) print statistic (default: false)
    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)
    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine bounds (default: 2)
    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)
    arith.reflect (bool) reflect arithmetical operators to the congruence closure (default: true)
    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)
    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)
    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    array.extensional (bool) extensional array theory (default: true)
    array.weak (bool) weak array theory (default: false)
    asymm_branch (bool) asymmetric branching (default: true)
    asymm_branch.all (bool) asymmetric branching on all literals per clause (default: false)
    asymm_branch.delay (unsigned int) number of simplification rounds to wait until invoking asymmetric branch simplification (default: 1)
    asymm_branch.limit (unsigned int) approx. maximum number of literals visited during asymmetric branching (default: 100000000)
    asymm_branch.rounds (unsigned int) maximal number of rounds to run asymmetric branch simplifications if progress is made (default: 2)
    asymm_branch.sampled (bool) use sampling based asymmetric branching based on binary implication graph (default: true)
    ate (bool) asymmetric tautology elimination (default: true)
    auto_config (bool) automatically configure solver (default: true)
    backtrack.conflicts (unsigned int) number of conflicts before enabling chronological backtracking (default: 4000)
    backtrack.scopes (unsigned int) number of scopes to enable chronological backtracking (default: 100)
    bca (bool) blocked clause addition - add blocked binary clauses (default: false)
    bce (bool) eliminate blocked clauses (default: false)
    bce_at (unsigned int) eliminate blocked clauses only once at the given simplification round (default: 2)
    bce_delay (unsigned int) delay eliminate blocked clauses until simplification round (default: 2)
    binspr (bool) enable SPR inferences of binary propagation redundant clauses. This inprocessing step eliminates models (default: false)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_add (bool) (default: true) bit-blast adders.
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    blast_full (bool) (default: false) bit-blast any term with bit-vector sort, this option will make E-matching ineffective in any pattern containing bit-vector terms.
    blast_mul (bool) (default: true) bit-blast multipliers (and dividers, remainders).
    blast_quant (bool) (default: false) bit-blast quantified variables.
    blocked_clause_limit (unsigned int) maximum number of literals visited during blocked clause elimination (default: 100000000)
    branching.anti_exploration (bool) apply anti-exploration heuristic for branch selection (default: false)
    branching.heuristic (symbol) branching heuristic vsids, chb (default: vsids)
    burst_search (unsigned int) number of conflicts before first global simplification (default: 100)
    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)
    bv.reflect (bool) create enode for every bit-vector term (default: true)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    candidate_models (bool) (default: false) create candidate models even when quantifier or theory reasoning is incomplete.
    cardinality.encoding (symbol) encoding used for at-most-k constraints: grouped, bimander, ordered, unate, circuit (default: grouped)
    cardinality.solver (bool) use cardinality solver (default: true)
    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)
    cce (bool) eliminate covered clauses (default: false)
    check_lemmas (bool) check lemmas on the fly using an independent nlsat solver (default: false)
    clause_proof (bool) record a clausal proof (default: false)
    common_patterns (bool) (default: true) minimize the number of auxiliary variables during CNF encoding by identifing commonly used patterns
    complete (bool) (default: true) add constraints to make sure that any interpretation of a underspecified arithmetic operators is a function. The result will include additional uninterpreted functions/constants: /0, div0, mod0, 0^0, neg-root
    context_solve (bool) (default: false) solve equalities under disjunctions.
    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)
    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)
    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)
    core.minimize (bool) minimize unsat core produced by SMT context (default: false)
    core.minimize_partial (bool) apply partial (cheap) core minimization (default: false)
    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)
    cut (bool) enable AIG based simplification in-processing (default: false)
    cut.aig (bool) extract aigs (and ites) from cluases for cut simplification (default: false)
    cut.delay (unsigned int) delay cut simplification by in-processing round (default: 2)
    cut.dont_cares (bool) integrate dont cares with cuts (default: true)
    cut.force (bool) force redoing cut-enumeration until a fixed-point (default: false)
    cut.lut (bool) extract luts from clauses for cut simplification (default: false)
    cut.npn3 (bool) extract 3 input functions from clauses for cut simplification (default: false)
    cut.redundancies (bool) integrate redundancy checking of cuts (default: true)
    cut.xor (bool) extract xors from clauses for cut simplification (default: false)
    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)
    dack.eq (bool) enable dynamic ackermannization for transtivity of equalities (default: false)
    dack.factor (double) number of instance per conflict (default: 0.1)
    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)
    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)
    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)
    ddfw.init_clause_weight (unsigned int) initial clause weight for DDFW local search (default: 8)
    ddfw.reinit_base (unsigned int) increment basis for geometric backoff scheme of re-initialization of weights (default: 10000)
    ddfw.restart_base (unsigned int) number of flips used a starting point for hessitant restart backoff (default: 100000)
    ddfw.threads (unsigned int) number of ddfw threads to run in parallel with sat solver (default: 0)
    ddfw.use_reward_pct (unsigned int) percentage to pick highest reward variable when it has reward 0 (default: 15)
    ddfw_search (bool) use ddfw local search instead of CDCL (default: false)
    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)
    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)
    dimacs.core (bool) extract core from DIMACS benchmarks (default: false)
    distributivity (bool) (default: true) minimize the number of auxiliary variables during CNF encoding by applying distributivity over unshared subformulas
    distributivity_blowup (unsigned int) (default: 32) maximum overhead for applying distributivity during CNF encoding
    div0_ackermann_limit (unsigned int) a bound for number of congruence Ackermann lemmas for div0 modelling (default: 1000)
    drat.activity (bool) dump variable activities (default: false)
    drat.binary (bool) use Binary DRAT output format (default: false)
    drat.check_sat (bool) build up internal trace, check satisfying model (default: false)
    drat.check_unsat (bool) build up internal proof and check (default: false)
    drat.file (symbol) file to dump DRAT proofs (default: )
    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)
    dyn_sub_res (bool) dynamic subsumption resolution for minimizing learned clauses (default: true)
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_inverses (bool) (default: true) eliminate inverse trigonometric functions (asin, acos, atan).
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_root_objects (bool) (default: true) eliminate root objects.
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    elim_vars (bool) enable variable elimination using resolution during simplification (default: true)
    elim_vars_bdd (bool) enable variable elimination using BDD recompilation during simplification (default: true)
    elim_vars_bdd_delay (unsigned int) delay elimination of variables using BDDs until after simplification round (default: 3)
    ematching (bool) E-Matching based quantifier instantiation (default: true)
    enable_pre_simplify (bool) enable pre simplifications before the bounded search (default: false)
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    factor (bool) (default: true) factor polynomials.
    factor_max_prime (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step (default: 31)
    factor_num_primes (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)'s. This parameter specify the maximum number of finite factorizations to be considered, before lifiting and searching (default: 1)
    factor_search_size (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space (default: 5000)
    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    force_cleanup (bool) force cleanup to remove tautologies and simplify clauses (default: false)
    gc (symbol) garbage collection strategy: psm, glue, glue_psm, dyn_psm (default: glue_psm)
    gc.burst (bool) perform eager garbage collection during initialization (default: false)
    gc.defrag (bool) defragment clauses when garbage collecting (default: true)
    gc.increment (unsigned int) increment to the garbage collection threshold (default: 500)
    gc.initial (unsigned int) learned clauses garbage collection frequency (default: 20000)
    gc.k (unsigned int) learned clauses that are inactive for k gc rounds are permanently deleted (only used in dyn_psm) (default: 7)
    gc.small_lbd (unsigned int) learned clauses with small LBD are never deleted (only used in dyn_psm) (default: 3)
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_labels (bool) remove/ignore labels in the input formula, this option is ignored if proofs are enabled (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    induction (bool) enable generation of induction lemmas (default: false)
    inline_vars (bool) inline variables that can be isolated from equations (not supported in incremental mode) (default: false)
    inprocess.max (unsigned int) maximal number of inprocessing passes (default: 4294967295)
    inprocess.out (symbol) file to dump result of the first inprocessing step and exit (default: )
    ite_chaing (bool) (default: true) minimize the number of auxiliary variables during CNF encoding by identifing if-then-else chains
    ite_extra (bool) (default: true) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    ite_solver (bool) (default: true) use if-then-else solver.
    lazy (unsigned int) how lazy the solver is. (default: 0)
    learned (bool) (default: false) collect also learned clauses.
    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    local_search (bool) use local search instead of CDCL (default: false)
    local_search_dbg_flips (bool) write debug information for number of flips (default: false)
    local_search_mode (symbol) local search algorithm, either default wsat or qsat (default: wsat)
    local_search_threads (unsigned int) number of local search threads to find satisfiable solution (default: 0)
    log_lemmas (bool) display lemmas as self-contained SMT formulas (default: false)
    logic (symbol) logic used to setup the SMT solver (default: )
    lookahead.cube.cutoff (symbol) cutoff type used to create lookahead cubes: depth, freevars, psat, adaptive_freevars, adaptive_psat (default: depth)
    lookahead.cube.depth (unsigned int) cut-off depth to create cubes. Used when lookahead.cube.cutoff is depth. (default: 1)
    lookahead.cube.fraction (double) adaptive fraction to create lookahead cubes. Used when lookahead.cube.cutoff is adaptive_freevars or adaptive_psat (default: 0.4)
    lookahead.cube.freevars (double) cube free variable fraction. Used when lookahead.cube.cutoff is freevars (default: 0.8)
    lookahead.cube.psat.clause_base (double) clause base for PSAT cutoff (default: 2)
    lookahead.cube.psat.trigger (double) trigger value to create lookahead cubes for PSAT cutoff. Used when lookahead.cube.cutoff is psat (default: 5)
    lookahead.cube.psat.var_exp (double) free variable exponent for PSAT cutoff (default: 1)
    lookahead.delta_fraction (double) number between 0 and 1, the smaller the more literals are selected for double lookahead (default: 1.0)
    lookahead.double (bool) enable doubld lookahead (default: true)
    lookahead.global_autarky (bool) prefer to branch on variables that occur in clauses that are reduced (default: false)
    lookahead.preselect (bool) use pre-selection of subset of variables for branching (default: false)
    lookahead.reward (symbol) select lookahead heuristic: ternary, heule_schur (Heule Schur), heuleu (Heule Unit), unit, or march_cu (default: march_cu)
    lookahead.use_learned (bool) use learned clauses when selecting lookahead literal (default: false)
    lookahead_scores (bool) extract lookahead scores. A utility that can only be used from the DIMACS front-end (default: false)
    lookahead_simplify (bool) use lookahead solver during simplification (default: false)
    lookahead_simplify.bca (bool) add learned binary clauses as part of lookahead simplification (default: true)
    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)
    max_args (unsigned int) (default: 128) maximum number of arguments (per application) that will be considered by the greedy (quadratic) heuristic.
    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    max_prime (unsigned int) (default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step.
    max_rounds (unsigned int) (default: 4) maximum number of rounds.
    max_search_size (unsigned int) (default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space.
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)
    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)
    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )
    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)
    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)
    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)
    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)
    min_mag (unsigned int) Z3 represents algebraic numbers using a (square-free) polynomial p and an isolating interval (which contains one and only one root of p). This interval may be refined during the computations. This parameter specifies whether to cache the value of a refined interval or not. It says the minimal size of an interval for caching purposes is 1/2^16 (default: 16)
    minimize_conflicts (bool) minimize conflicts (default: false)
    minimize_lemmas (bool) minimize learned clauses (default: true)
    mode (symbol) NNF translation mode: skolem (skolem normal form), quantifiers (skolem normal form + quantifiers in NNF), full (default: skolem)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    nla2bv_bv_size (unsigned int) (default: 4) default bit-vector size used by nla2bv tactic.
    nla2bv_divisor (unsigned int) (default: 2) nla2bv tactic parameter.
    nla2bv_max_bv_size (unsigned int) (default: inf) maximum bit-vector size used by nla2bv tactic
    nla2bv_root (unsigned int) (default: 2) nla2bv tactic encodes reals into bit-vectors using expressions of the form a+b*sqrt(c), this parameter sets the value of c used in the encoding.
    num_primes (unsigned int) (default: 1) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)'s. This parameter specify the maximum number of finite factorizations to be considered, before lifiting and searching.
    override_incremental (bool) override incremental safety gaps. Enable elimination of blocked clauses and variables even if solver is reused (default: false)
    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)
    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)
    pb.lemma_format (symbol) generate either cardinality or pb lemmas (default: cardinality)
    pb.min_arity (unsigned int) minimal arity to compile pb/cardinality constraints to CNF (default: 9)
    pb.resolve (symbol) resolution strategy for boolean algebra solver: cardinality, rounding (default: cardinality)
    pb.solver (symbol) method for handling Pseudo-Boolean constraints: circuit (arithmetical circuit), sorting (sorting circuit), totalizer (use totalizer encoding), binary_merge, segmented, solver (use native solver) (default: solver)
    phase (symbol) phase selection strategy: always_false, always_true, basic_caching, random, caching (default: caching)
    phase.sticky (bool) use sticky phase caching (default: true)
    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)
    prob_search (bool) use probsat local search instead of CDCL (default: false)
    probing (bool) apply failed literal detection during simplification (default: true)
    probing_binary (bool) probe binary clauses (default: true)
    probing_cache (bool) add binary literals as lemmas (default: true)
    probing_cache_limit (unsigned int) cache binaries unless overall memory usage exceeds cache limit (default: 1024)
    probing_limit (unsigned int) limit to the number of probe calls (default: 5000000)
    propagate.prefetch (bool) prefetch watch lists for assigned literals (default: true)
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    pull_nested_quantifiers (bool) pull nested quantifiers (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))
    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)
    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)
    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)
    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)
    qi.profile (bool) profile quantifier instantiation (default: false)
    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)
    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)
    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)
    random_freq (double) frequency of random case splits (default: 0.01)
    random_seed (unsigned int) random seed for the smt solver (default: 0)
    randomize (bool) randomize selection of a witness in nlsat. (default: true)
    refine_inj_axioms (bool) refine injectivity axioms (default: true)
    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)
    reorder (bool) reorder variables. (default: true)
    reorder.activity_scale (unsigned int) scaling factor for activity update (default: 100)
    reorder.base (unsigned int) number of conflicts per random reorder  (default: 4294967295)
    reorder.itau (double) inverse temperature for softmax (default: 4.0)
    rephase.base (unsigned int) number of conflicts per rephase  (default: 1000)
    resolution.cls_cutoff1 (unsigned int) limit1 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 100000000)
    resolution.cls_cutoff2 (unsigned int) limit2 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 700000000)
    resolution.limit (unsigned int) approx. maximum number of literals visited during variable elimination (default: 500000000)
    resolution.lit_cutoff_range1 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 700)
    resolution.lit_cutoff_range2 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 400)
    resolution.lit_cutoff_range3 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 300)
    resolution.occ_cutoff (unsigned int) first cutoff (on number of positive/negative occurrences) for Boolean variable elimination (default: 10)
    resolution.occ_cutoff_range1 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 8)
    resolution.occ_cutoff_range2 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 5)
    resolution.occ_cutoff_range3 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 3)
    restart (symbol) restart strategy: static, luby, ema or geometric (default: ema)
    restart.emafastglue (double) ema alpha factor for fast moving average (default: 0.03)
    restart.emaslowglue (double) ema alpha factor for slow moving average (default: 1e-05)
    restart.factor (double) restart increment factor for geometric strategy (default: 1.5)
    restart.fast (bool) use fast restart approach only removing less active literals. (default: true)
    restart.initial (unsigned int) initial restart (number of conflicts) (default: 2)
    restart.margin (double) margin between fast and slow restart factors. For ema (default: 1.1)
    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)
    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)
    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)
    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)
    retain_blocked_clauses (bool) retain blocked clauses as lemmas (default: true)
    rewrite_patterns (bool) rewrite patterns. (default: false)
    scc (bool) eliminate Boolean variables by computing strongly connected components (default: true)
    scc.tr (bool) apply transitive reduction, eliminate redundant binary clauses (default: true)
    search.sat.conflicts (unsigned int) period for solving for sat (in number of conflicts) (default: 400)
    search.unsat.conflicts (unsigned int) period for solving for unsat (in number of conflicts) (default: 400)
    seed (unsigned int) random seed. (default: 0)
    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)
    seq.use_derivatives (bool) dev flag (not for users) enable derivative based unfolding of regex (default: false)
    seq.use_unicode (bool) dev flag (not for users) enable unicode semantics (default: false)
    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)
    shuffle_vars (bool) use a random variable order. (default: false)
    simplify.delay (unsigned int) set initial delay of simplification by a conflict count (default: 0)
    simplify_conflicts (bool) simplify conflicts using equalities before resolving them in nlsat solver. (default: true)
    sk_hack (bool) hack for VCC (default: false)
    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations.
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
    split_factors (bool) (default: true) apply simplifications such as (= (* p1 p2) 0) --> (or (= p1 0) (= p2 0)).
    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)
    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)
    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)
    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)
    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)
    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)
    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)
    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)
    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)
    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)
    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)
    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)
    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)
    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)
    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)
    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)
    subsumption (bool) eliminate subsumed clauses (default: true)
    subsumption.limit (unsigned int) approx. maximum number of literals visited during subsumption (and subsumption resolution) (default: 100000000)
    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)
    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)
    theory_solver (bool) (default: true) use theory solvers.
    threads (unsigned int) maximal number of parallel threads. (default: 1)
    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)
    variable_decay (unsigned int) multiplier (divided by 100) for the VSIDS activity increment (default: 110)
    zero_accuracy (unsigned int) one of the most time-consuming operations in the real algebraic number module is determining the sign of a polynomial evaluated at a sample point with non-rational algebraic number values. Let k be the value of this option. If k is 0, Z3 uses precise computation. Otherwise, the result of a polynomial evaluation is considered to be 0 if Z3 can show it is inside the interval (-1/2^k, 1/2^k) (default: 0)
- qffplra (try to) solve goal using the tactic for QF_FPLRA.
    abce (bool) eliminate blocked clauses using asymmetric literals (default: false)
    acce (bool) eliminate covered clauses using asymmetric added literals (default: false)
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    anf (bool) enable ANF based simplification in-processing (default: false)
    anf.delay (unsigned int) delay ANF simplification by in-processing round (default: 2)
    anf.exlin (bool) enable extended linear simplification (default: false)
    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)
    arith.bounded_expansion (bool) box variables used in branch and bound into bound assumptions (default: false)
    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)
    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)
    arith.cheap_eqs (unsigned int) 0 - do not run, 1 - use tree, 2 - use table (default: 1)
    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)
    arith.eager_eq_axioms (bool) eager equality axioms (default: true)
    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)
    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)
    arith.ignore_int (bool) treat integer variables as real (default: false)
    arith.int_eq_branch (bool) branching using derived integer equations (default: false)
    arith.min (bool) minimize cost (default: false)
    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.branching (bool) branching on integer variables in non linear clusters, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.expp (bool) expensive patching (default: false)
    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)
    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)
    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)
    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)
    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)
    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)
    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)
    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)
    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.horner (bool) run horner's heuristic (default: true)
    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)
    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)
    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.nra (bool) call nra_solver when incremental lianirization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)
    arith.nl.order (bool) run order lemmas (default: true)
    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)
    arith.nl.tangents (bool) run tangent lemmas (default: true)
    arith.print_ext_var_names (bool) print external variable names (default: false)
    arith.print_stats (bool) print statistic (default: false)
    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)
    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine bounds (default: 2)
    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)
    arith.reflect (bool) reflect arithmetical operators to the congruence closure (default: true)
    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)
    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)
    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    array.extensional (bool) extensional array theory (default: true)
    array.weak (bool) weak array theory (default: false)
    asymm_branch (bool) asymmetric branching (default: true)
    asymm_branch.all (bool) asymmetric branching on all literals per clause (default: false)
    asymm_branch.delay (unsigned int) number of simplification rounds to wait until invoking asymmetric branch simplification (default: 1)
    asymm_branch.limit (unsigned int) approx. maximum number of literals visited during asymmetric branching (default: 100000000)
    asymm_branch.rounds (unsigned int) maximal number of rounds to run asymmetric branch simplifications if progress is made (default: 2)
    asymm_branch.sampled (bool) use sampling based asymmetric branching based on binary implication graph (default: true)
    ate (bool) asymmetric tautology elimination (default: true)
    auto_config (bool) automatically configure solver (default: true)
    backtrack.conflicts (unsigned int) number of conflicts before enabling chronological backtracking (default: 4000)
    backtrack.scopes (unsigned int) number of scopes to enable chronological backtracking (default: 100)
    bca (bool) blocked clause addition - add blocked binary clauses (default: false)
    bce (bool) eliminate blocked clauses (default: false)
    bce_at (unsigned int) eliminate blocked clauses only once at the given simplification round (default: 2)
    bce_delay (unsigned int) delay eliminate blocked clauses until simplification round (default: 2)
    binspr (bool) enable SPR inferences of binary propagation redundant clauses. This inprocessing step eliminates models (default: false)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_add (bool) (default: true) bit-blast adders.
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    blast_full (bool) (default: false) bit-blast any term with bit-vector sort, this option will make E-matching ineffective in any pattern containing bit-vector terms.
    blast_mul (bool) (default: true) bit-blast multipliers (and dividers, remainders).
    blast_quant (bool) (default: false) bit-blast quantified variables.
    blocked_clause_limit (unsigned int) maximum number of literals visited during blocked clause elimination (default: 100000000)
    branching.anti_exploration (bool) apply anti-exploration heuristic for branch selection (default: false)
    branching.heuristic (symbol) branching heuristic vsids, chb (default: vsids)
    burst_search (unsigned int) number of conflicts before first global simplification (default: 100)
    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)
    bv.reflect (bool) create enode for every bit-vector term (default: true)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    candidate_models (bool) (default: false) create candidate models even when quantifier or theory reasoning is incomplete.
    cardinality.encoding (symbol) encoding used for at-most-k constraints: grouped, bimander, ordered, unate, circuit (default: grouped)
    cardinality.solver (bool) use cardinality solver (default: true)
    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)
    cce (bool) eliminate covered clauses (default: false)
    check_lemmas (bool) check lemmas on the fly using an independent nlsat solver (default: false)
    clause_proof (bool) record a clausal proof (default: false)
    common_patterns (bool) (default: true) minimize the number of auxiliary variables during CNF encoding by identifing commonly used patterns
    complete (bool) (default: true) add constraints to make sure that any interpretation of a underspecified arithmetic operators is a function. The result will include additional uninterpreted functions/constants: /0, div0, mod0, 0^0, neg-root
    context_solve (bool) (default: false) solve equalities under disjunctions.
    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)
    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)
    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)
    core.minimize (bool) minimize unsat core produced by SMT context (default: false)
    core.minimize_partial (bool) apply partial (cheap) core minimization (default: false)
    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)
    cut (bool) enable AIG based simplification in-processing (default: false)
    cut.aig (bool) extract aigs (and ites) from cluases for cut simplification (default: false)
    cut.delay (unsigned int) delay cut simplification by in-processing round (default: 2)
    cut.dont_cares (bool) integrate dont cares with cuts (default: true)
    cut.force (bool) force redoing cut-enumeration until a fixed-point (default: false)
    cut.lut (bool) extract luts from clauses for cut simplification (default: false)
    cut.npn3 (bool) extract 3 input functions from clauses for cut simplification (default: false)
    cut.redundancies (bool) integrate redundancy checking of cuts (default: true)
    cut.xor (bool) extract xors from clauses for cut simplification (default: false)
    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)
    dack.eq (bool) enable dynamic ackermannization for transtivity of equalities (default: false)
    dack.factor (double) number of instance per conflict (default: 0.1)
    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)
    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)
    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)
    ddfw.init_clause_weight (unsigned int) initial clause weight for DDFW local search (default: 8)
    ddfw.reinit_base (unsigned int) increment basis for geometric backoff scheme of re-initialization of weights (default: 10000)
    ddfw.restart_base (unsigned int) number of flips used a starting point for hessitant restart backoff (default: 100000)
    ddfw.threads (unsigned int) number of ddfw threads to run in parallel with sat solver (default: 0)
    ddfw.use_reward_pct (unsigned int) percentage to pick highest reward variable when it has reward 0 (default: 15)
    ddfw_search (bool) use ddfw local search instead of CDCL (default: false)
    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)
    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)
    dimacs.core (bool) extract core from DIMACS benchmarks (default: false)
    distributivity (bool) (default: true) minimize the number of auxiliary variables during CNF encoding by applying distributivity over unshared subformulas
    distributivity_blowup (unsigned int) (default: 32) maximum overhead for applying distributivity during CNF encoding
    div0_ackermann_limit (unsigned int) a bound for number of congruence Ackermann lemmas for div0 modelling (default: 1000)
    drat.activity (bool) dump variable activities (default: false)
    drat.binary (bool) use Binary DRAT output format (default: false)
    drat.check_sat (bool) build up internal trace, check satisfying model (default: false)
    drat.check_unsat (bool) build up internal proof and check (default: false)
    drat.file (symbol) file to dump DRAT proofs (default: )
    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)
    dyn_sub_res (bool) dynamic subsumption resolution for minimizing learned clauses (default: true)
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_inverses (bool) (default: true) eliminate inverse trigonometric functions (asin, acos, atan).
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_root_objects (bool) (default: true) eliminate root objects.
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    elim_vars (bool) enable variable elimination using resolution during simplification (default: true)
    elim_vars_bdd (bool) enable variable elimination using BDD recompilation during simplification (default: true)
    elim_vars_bdd_delay (unsigned int) delay elimination of variables using BDDs until after simplification round (default: 3)
    ematching (bool) E-Matching based quantifier instantiation (default: true)
    enable_pre_simplify (bool) enable pre simplifications before the bounded search (default: false)
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    factor (bool) (default: true) factor polynomials.
    factor_max_prime (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step (default: 31)
    factor_num_primes (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)'s. This parameter specify the maximum number of finite factorizations to be considered, before lifiting and searching (default: 1)
    factor_search_size (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space (default: 5000)
    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    force_cleanup (bool) force cleanup to remove tautologies and simplify clauses (default: false)
    gc (symbol) garbage collection strategy: psm, glue, glue_psm, dyn_psm (default: glue_psm)
    gc.burst (bool) perform eager garbage collection during initialization (default: false)
    gc.defrag (bool) defragment clauses when garbage collecting (default: true)
    gc.increment (unsigned int) increment to the garbage collection threshold (default: 500)
    gc.initial (unsigned int) learned clauses garbage collection frequency (default: 20000)
    gc.k (unsigned int) learned clauses that are inactive for k gc rounds are permanently deleted (only used in dyn_psm) (default: 7)
    gc.small_lbd (unsigned int) learned clauses with small LBD are never deleted (only used in dyn_psm) (default: 3)
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_labels (bool) remove/ignore labels in the input formula, this option is ignored if proofs are enabled (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    induction (bool) enable generation of induction lemmas (default: false)
    inline_vars (bool) inline variables that can be isolated from equations (not supported in incremental mode) (default: false)
    inprocess.max (unsigned int) maximal number of inprocessing passes (default: 4294967295)
    inprocess.out (symbol) file to dump result of the first inprocessing step and exit (default: )
    ite_chaing (bool) (default: true) minimize the number of auxiliary variables during CNF encoding by identifing if-then-else chains
    ite_extra (bool) (default: true) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    ite_solver (bool) (default: true) use if-then-else solver.
    lazy (unsigned int) how lazy the solver is. (default: 0)
    learned (bool) (default: false) collect also learned clauses.
    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    local_search (bool) use local search instead of CDCL (default: false)
    local_search_dbg_flips (bool) write debug information for number of flips (default: false)
    local_search_mode (symbol) local search algorithm, either default wsat or qsat (default: wsat)
    local_search_threads (unsigned int) number of local search threads to find satisfiable solution (default: 0)
    log_lemmas (bool) display lemmas as self-contained SMT formulas (default: false)
    logic (symbol) logic used to setup the SMT solver (default: )
    lookahead.cube.cutoff (symbol) cutoff type used to create lookahead cubes: depth, freevars, psat, adaptive_freevars, adaptive_psat (default: depth)
    lookahead.cube.depth (unsigned int) cut-off depth to create cubes. Used when lookahead.cube.cutoff is depth. (default: 1)
    lookahead.cube.fraction (double) adaptive fraction to create lookahead cubes. Used when lookahead.cube.cutoff is adaptive_freevars or adaptive_psat (default: 0.4)
    lookahead.cube.freevars (double) cube free variable fraction. Used when lookahead.cube.cutoff is freevars (default: 0.8)
    lookahead.cube.psat.clause_base (double) clause base for PSAT cutoff (default: 2)
    lookahead.cube.psat.trigger (double) trigger value to create lookahead cubes for PSAT cutoff. Used when lookahead.cube.cutoff is psat (default: 5)
    lookahead.cube.psat.var_exp (double) free variable exponent for PSAT cutoff (default: 1)
    lookahead.delta_fraction (double) number between 0 and 1, the smaller the more literals are selected for double lookahead (default: 1.0)
    lookahead.double (bool) enable doubld lookahead (default: true)
    lookahead.global_autarky (bool) prefer to branch on variables that occur in clauses that are reduced (default: false)
    lookahead.preselect (bool) use pre-selection of subset of variables for branching (default: false)
    lookahead.reward (symbol) select lookahead heuristic: ternary, heule_schur (Heule Schur), heuleu (Heule Unit), unit, or march_cu (default: march_cu)
    lookahead.use_learned (bool) use learned clauses when selecting lookahead literal (default: false)
    lookahead_scores (bool) extract lookahead scores. A utility that can only be used from the DIMACS front-end (default: false)
    lookahead_simplify (bool) use lookahead solver during simplification (default: false)
    lookahead_simplify.bca (bool) add learned binary clauses as part of lookahead simplification (default: true)
    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)
    max_args (unsigned int) (default: 128) maximum number of arguments (per application) that will be considered by the greedy (quadratic) heuristic.
    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    max_prime (unsigned int) (default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step.
    max_rounds (unsigned int) (default: 4) maximum number of rounds.
    max_search_size (unsigned int) (default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space.
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)
    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)
    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )
    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)
    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)
    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)
    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)
    min_mag (unsigned int) Z3 represents algebraic numbers using a (square-free) polynomial p and an isolating interval (which contains one and only one root of p). This interval may be refined during the computations. This parameter specifies whether to cache the value of a refined interval or not. It says the minimal size of an interval for caching purposes is 1/2^16 (default: 16)
    minimize_conflicts (bool) minimize conflicts (default: false)
    minimize_lemmas (bool) minimize learned clauses (default: true)
    mode (symbol) NNF translation mode: skolem (skolem normal form), quantifiers (skolem normal form + quantifiers in NNF), full (default: skolem)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    nla2bv_bv_size (unsigned int) (default: 4) default bit-vector size used by nla2bv tactic.
    nla2bv_divisor (unsigned int) (default: 2) nla2bv tactic parameter.
    nla2bv_max_bv_size (unsigned int) (default: inf) maximum bit-vector size used by nla2bv tactic
    nla2bv_root (unsigned int) (default: 2) nla2bv tactic encodes reals into bit-vectors using expressions of the form a+b*sqrt(c), this parameter sets the value of c used in the encoding.
    num_primes (unsigned int) (default: 1) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)'s. This parameter specify the maximum number of finite factorizations to be considered, before lifiting and searching.
    override_incremental (bool) override incremental safety gaps. Enable elimination of blocked clauses and variables even if solver is reused (default: false)
    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)
    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)
    pb.lemma_format (symbol) generate either cardinality or pb lemmas (default: cardinality)
    pb.min_arity (unsigned int) minimal arity to compile pb/cardinality constraints to CNF (default: 9)
    pb.resolve (symbol) resolution strategy for boolean algebra solver: cardinality, rounding (default: cardinality)
    pb.solver (symbol) method for handling Pseudo-Boolean constraints: circuit (arithmetical circuit), sorting (sorting circuit), totalizer (use totalizer encoding), binary_merge, segmented, solver (use native solver) (default: solver)
    phase (symbol) phase selection strategy: always_false, always_true, basic_caching, random, caching (default: caching)
    phase.sticky (bool) use sticky phase caching (default: true)
    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)
    prob_search (bool) use probsat local search instead of CDCL (default: false)
    probing (bool) apply failed literal detection during simplification (default: true)
    probing_binary (bool) probe binary clauses (default: true)
    probing_cache (bool) add binary literals as lemmas (default: true)
    probing_cache_limit (unsigned int) cache binaries unless overall memory usage exceeds cache limit (default: 1024)
    probing_limit (unsigned int) limit to the number of probe calls (default: 5000000)
    propagate.prefetch (bool) prefetch watch lists for assigned literals (default: true)
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    pull_nested_quantifiers (bool) pull nested quantifiers (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))
    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)
    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)
    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)
    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)
    qi.profile (bool) profile quantifier instantiation (default: false)
    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)
    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)
    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)
    random_freq (double) frequency of random case splits (default: 0.01)
    random_seed (unsigned int) random seed for the smt solver (default: 0)
    randomize (bool) randomize selection of a witness in nlsat. (default: true)
    refine_inj_axioms (bool) refine injectivity axioms (default: true)
    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)
    reorder (bool) reorder variables. (default: true)
    reorder.activity_scale (unsigned int) scaling factor for activity update (default: 100)
    reorder.base (unsigned int) number of conflicts per random reorder  (default: 4294967295)
    reorder.itau (double) inverse temperature for softmax (default: 4.0)
    rephase.base (unsigned int) number of conflicts per rephase  (default: 1000)
    resolution.cls_cutoff1 (unsigned int) limit1 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 100000000)
    resolution.cls_cutoff2 (unsigned int) limit2 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 700000000)
    resolution.limit (unsigned int) approx. maximum number of literals visited during variable elimination (default: 500000000)
    resolution.lit_cutoff_range1 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 700)
    resolution.lit_cutoff_range2 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 400)
    resolution.lit_cutoff_range3 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 300)
    resolution.occ_cutoff (unsigned int) first cutoff (on number of positive/negative occurrences) for Boolean variable elimination (default: 10)
    resolution.occ_cutoff_range1 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 8)
    resolution.occ_cutoff_range2 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 5)
    resolution.occ_cutoff_range3 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 3)
    restart (symbol) restart strategy: static, luby, ema or geometric (default: ema)
    restart.emafastglue (double) ema alpha factor for fast moving average (default: 0.03)
    restart.emaslowglue (double) ema alpha factor for slow moving average (default: 1e-05)
    restart.factor (double) restart increment factor for geometric strategy (default: 1.5)
    restart.fast (bool) use fast restart approach only removing less active literals. (default: true)
    restart.initial (unsigned int) initial restart (number of conflicts) (default: 2)
    restart.margin (double) margin between fast and slow restart factors. For ema (default: 1.1)
    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)
    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)
    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)
    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)
    retain_blocked_clauses (bool) retain blocked clauses as lemmas (default: true)
    rewrite_patterns (bool) rewrite patterns. (default: false)
    scc (bool) eliminate Boolean variables by computing strongly connected components (default: true)
    scc.tr (bool) apply transitive reduction, eliminate redundant binary clauses (default: true)
    search.sat.conflicts (unsigned int) period for solving for sat (in number of conflicts) (default: 400)
    search.unsat.conflicts (unsigned int) period for solving for unsat (in number of conflicts) (default: 400)
    seed (unsigned int) random seed. (default: 0)
    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)
    seq.use_derivatives (bool) dev flag (not for users) enable derivative based unfolding of regex (default: false)
    seq.use_unicode (bool) dev flag (not for users) enable unicode semantics (default: false)
    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)
    shuffle_vars (bool) use a random variable order. (default: false)
    simplify.delay (unsigned int) set initial delay of simplification by a conflict count (default: 0)
    simplify_conflicts (bool) simplify conflicts using equalities before resolving them in nlsat solver. (default: true)
    sk_hack (bool) hack for VCC (default: false)
    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations.
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
    split_factors (bool) (default: true) apply simplifications such as (= (* p1 p2) 0) --> (or (= p1 0) (= p2 0)).
    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)
    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)
    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)
    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)
    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)
    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)
    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)
    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)
    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)
    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)
    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)
    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)
    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)
    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)
    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)
    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)
    subsumption (bool) eliminate subsumed clauses (default: true)
    subsumption.limit (unsigned int) approx. maximum number of literals visited during subsumption (and subsumption resolution) (default: 100000000)
    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)
    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)
    theory_solver (bool) (default: true) use theory solvers.
    threads (unsigned int) maximal number of parallel threads. (default: 1)
    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)
    variable_decay (unsigned int) multiplier (divided by 100) for the VSIDS activity increment (default: 110)
    zero_accuracy (unsigned int) one of the most time-consuming operations in the real algebraic number module is determining the sign of a polynomial evaluated at a sample point with non-rational algebraic number values. Let k be the value of this option. If k is 0, Z3 uses precise computation. Otherwise, the result of a polynomial evaluation is considered to be 0 if Z3 can show it is inside the interval (-1/2^k, 1/2^k) (default: 0)
- default default strategy used when no logic is specified.
    abce (bool) eliminate blocked clauses using asymmetric literals (default: false)
    acce (bool) eliminate covered clauses using asymmetric added literals (default: false)
    add_bound_lower (rational) (default: -2) lower bound to be added to unbounded variables.
    add_bound_upper (rational) (default: 2) upper bound to be added to unbounded variables.
    aig_per_assertion (bool) (default: true) process one assertion at a time.
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    anf (bool) enable ANF based simplification in-processing (default: false)
    anf.delay (unsigned int) delay ANF simplification by in-processing round (default: 2)
    anf.exlin (bool) enable extended linear simplification (default: false)
    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)
    arith.bounded_expansion (bool) box variables used in branch and bound into bound assumptions (default: false)
    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)
    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)
    arith.cheap_eqs (unsigned int) 0 - do not run, 1 - use tree, 2 - use table (default: 1)
    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)
    arith.eager_eq_axioms (bool) eager equality axioms (default: true)
    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)
    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)
    arith.ignore_int (bool) treat integer variables as real (default: false)
    arith.int_eq_branch (bool) branching using derived integer equations (default: false)
    arith.min (bool) minimize cost (default: false)
    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.branching (bool) branching on integer variables in non linear clusters, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.expp (bool) expensive patching (default: false)
    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)
    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)
    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)
    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)
    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)
    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)
    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)
    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)
    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.horner (bool) run horner's heuristic (default: true)
    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)
    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)
    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.nra (bool) call nra_solver when incremental lianirization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)
    arith.nl.order (bool) run order lemmas (default: true)
    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)
    arith.nl.tangents (bool) run tangent lemmas (default: true)
    arith.print_ext_var_names (bool) print external variable names (default: false)
    arith.print_stats (bool) print statistic (default: false)
    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)
    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine bounds (default: 2)
    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)
    arith.reflect (bool) reflect arithmetical operators to the congruence closure (default: true)
    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)
    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)
    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    array.extensional (bool) extensional array theory (default: true)
    array.weak (bool) weak array theory (default: false)
    asymm_branch (bool) asymmetric branching (default: true)
    asymm_branch.all (bool) asymmetric branching on all literals per clause (default: false)
    asymm_branch.delay (unsigned int) number of simplification rounds to wait until invoking asymmetric branch simplification (default: 1)
    asymm_branch.limit (unsigned int) approx. maximum number of literals visited during asymmetric branching (default: 100000000)
    asymm_branch.rounds (unsigned int) maximal number of rounds to run asymmetric branch simplifications if progress is made (default: 2)
    asymm_branch.sampled (bool) use sampling based asymmetric branching based on binary implication graph (default: true)
    ate (bool) asymmetric tautology elimination (default: true)
    auto_config (bool) automatically configure solver (default: true)
    backtrack.conflicts (unsigned int) number of conflicts before enabling chronological backtracking (default: 4000)
    backtrack.scopes (unsigned int) number of scopes to enable chronological backtracking (default: 100)
    bca (bool) blocked clause addition - add blocked binary clauses (default: false)
    bce (bool) eliminate blocked clauses (default: false)
    bce_at (unsigned int) eliminate blocked clauses only once at the given simplification round (default: 2)
    bce_delay (unsigned int) delay eliminate blocked clauses until simplification round (default: 2)
    binspr (bool) enable SPR inferences of binary propagation redundant clauses. This inprocessing step eliminates models (default: false)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_add (bool) (default: true) bit-blast adders.
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    blast_full (bool) (default: false) bit-blast any term with bit-vector sort, this option will make E-matching ineffective in any pattern containing bit-vector terms.
    blast_mul (bool) (default: true) bit-blast multipliers (and dividers, remainders).
    blast_quant (bool) (default: false) bit-blast quantified variables.
    blocked_clause_limit (unsigned int) maximum number of literals visited during blocked clause elimination (default: 100000000)
    branching.anti_exploration (bool) apply anti-exploration heuristic for branch selection (default: false)
    branching.heuristic (symbol) branching heuristic vsids, chb (default: vsids)
    burst_search (unsigned int) number of conflicts before first global simplification (default: 100)
    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)
    bv.reflect (bool) create enode for every bit-vector term (default: true)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    cancel_backup_file (symbol) file to save partial search state if search is canceled (default: )
    candidate_models (bool) (default: false) create candidate models even when quantifier or theory reasoning is incomplete.
    cardinality.encoding (symbol) encoding used for at-most-k constraints: grouped, bimander, ordered, unate, circuit (default: grouped)
    cardinality.solver (bool) use cardinality solver (default: true)
    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)
    cce (bool) eliminate covered clauses (default: false)
    check_lemmas (bool) check lemmas on the fly using an independent nlsat solver (default: false)
    clause_proof (bool) record a clausal proof (default: false)
    cofactor_equalities (bool) (default: true) use equalities to rewrite bodies of ite-expressions. This is potentially expensive.
    common_patterns (bool) (default: true) minimize the number of auxiliary variables during CNF encoding by identifing commonly used patterns
    compact (bool) try to compact function graph (i.e., function interpretations that are lookup tables) (default: true)
    compile_equality (bool) (default:false) compile equalities into pseudo-Boolean equality
    complete (bool) (default: true) add constraints to make sure that any interpretation of a underspecified arithmetic operators is a function. The result will include additional uninterpreted functions/constants: /0, div0, mod0, 0^0, neg-root
    completion (bool) enable/disable model completion (default: false)
    context_solve (bool) (default: false) solve equalities under disjunctions.
    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)
    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)
    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)
    core.minimize (bool) minimize computed core (default: false)
    core.minimize_partial (bool) apply partial (cheap) core minimization (default: false)
    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)
    ctrl_c (bool) enable interrupts from ctrl-c (default: true)
    cut (bool) enable AIG based simplification in-processing (default: false)
    cut.aig (bool) extract aigs (and ites) from cluases for cut simplification (default: false)
    cut.delay (unsigned int) delay cut simplification by in-processing round (default: 2)
    cut.dont_cares (bool) integrate dont cares with cuts (default: true)
    cut.force (bool) force redoing cut-enumeration until a fixed-point (default: false)
    cut.lut (bool) extract luts from clauses for cut simplification (default: false)
    cut.npn3 (bool) extract 3 input functions from clauses for cut simplification (default: false)
    cut.redundancies (bool) integrate redundancy checking of cuts (default: true)
    cut.xor (bool) extract xors from clauses for cut simplification (default: false)
    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)
    dack.eq (bool) enable dynamic ackermannization for transtivity of equalities (default: false)
    dack.factor (double) number of instance per conflict (default: 0.1)
    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)
    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)
    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)
    ddfw.init_clause_weight (unsigned int) initial clause weight for DDFW local search (default: 8)
    ddfw.reinit_base (unsigned int) increment basis for geometric backoff scheme of re-initialization of weights (default: 10000)
    ddfw.restart_base (unsigned int) number of flips used a starting point for hessitant restart backoff (default: 100000)
    ddfw.threads (unsigned int) number of ddfw threads to run in parallel with sat solver (default: 0)
    ddfw.use_reward_pct (unsigned int) percentage to pick highest reward variable when it has reward 0 (default: 15)
    ddfw_search (bool) use ddfw local search instead of CDCL (default: false)
    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)
    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)
    dimacs.core (bool) extract core from DIMACS benchmarks (default: false)
    distributivity (bool) (default: true) minimize the number of auxiliary variables during CNF encoding by applying distributivity over unshared subformulas
    distributivity_blowup (unsigned int) (default: 32) maximum overhead for applying distributivity during CNF encoding
    div0_ackermann_limit (unsigned int) a bound for number of congruence Ackermann lemmas for div0 modelling (default: 1000)
    drat.activity (bool) dump variable activities (default: false)
    drat.binary (bool) use Binary DRAT output format (default: false)
    drat.check_sat (bool) build up internal trace, check satisfying model (default: false)
    drat.check_unsat (bool) build up internal proof and check (default: false)
    drat.file (symbol) file to dump DRAT proofs (default: )
    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)
    dyn_sub_res (bool) dynamic subsumption resolution for minimizing learned clauses (default: true)
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_inverses (bool) (default: true) eliminate inverse trigonometric functions (asin, acos, atan).
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_root_objects (bool) (default: true) eliminate root objects.
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    elim_vars (bool) enable variable elimination using resolution during simplification (default: true)
    elim_vars_bdd (bool) enable variable elimination using BDD recompilation during simplification (default: true)
    elim_vars_bdd_delay (unsigned int) delay elimination of variables using BDDs until after simplification round (default: 3)
    eliminate_variables_as_block (bool) (default: true) eliminate variables as a block (true) or one at a time (false)
    ematching (bool) E-Matching based quantifier instantiation (default: true)
    enable_pre_simplify (bool) enable pre simplifications before the bounded search (default: false)
    enforce_model_conversion (bool) apply model transformation on new assertions (default: false)
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    factor (bool) (default: true) factor polynomials.
    factor_max_prime (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step (default: 31)
    factor_num_primes (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)'s. This parameter specify the maximum number of finite factorizations to be considered, before lifiting and searching (default: 1)
    factor_search_size (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space (default: 5000)
    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    force_cleanup (bool) force cleanup to remove tautologies and simplify clauses (default: false)
    gc (symbol) garbage collection strategy: psm, glue, glue_psm, dyn_psm (default: glue_psm)
    gc.burst (bool) perform eager garbage collection during initialization (default: false)
    gc.defrag (bool) defragment clauses when garbage collecting (default: true)
    gc.increment (unsigned int) increment to the garbage collection threshold (default: 500)
    gc.initial (unsigned int) learned clauses garbage collection frequency (default: 20000)
    gc.k (unsigned int) learned clauses that are inactive for k gc rounds are permanently deleted (only used in dyn_psm) (default: 7)
    gc.small_lbd (unsigned int) learned clauses with small LBD are never deleted (only used in dyn_psm) (default: 3)
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_labels (bool) remove/ignore labels in the input formula, this option is ignored if proofs are enabled (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    induction (bool) enable generation of induction lemmas (default: false)
    inline_def (bool) inline local function definitions ignoring possible expansion (default: false)
    inline_vars (bool) inline variables that can be isolated from equations (not supported in incremental mode) (default: false)
    inprocess.max (unsigned int) maximal number of inprocessing passes (default: 4294967295)
    inprocess.out (symbol) file to dump result of the first inprocessing step and exit (default: )
    ite_chaing (bool) (default: true) minimize the number of auxiliary variables during CNF encoding by identifing if-then-else chains
    ite_extra (bool) (default: true) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    ite_solver (bool) (default: true) use if-then-else solver.
    keep_cardinality_constraints (bool) (default: false) retain cardinality constraints (don't bit-blast them) and use built-in cardinality solver
    lazy (unsigned int) how lazy the solver is. (default: 0)
    learned (bool) (default: false) collect also learned clauses.
    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)
    lia2pb_max_bits (unsigned int) (default: 32) maximum number of bits to be used (per variable) in lia2pb.
    lia2pb_partial (bool) (default: false) partial lia2pb conversion.
    lia2pb_total_bits (unsigned int) (default: 2048) total number of bits to be used (per problem) in lia2pb.
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    local_search (bool) use local search instead of CDCL (default: false)
    local_search_dbg_flips (bool) write debug information for number of flips (default: false)
    local_search_mode (symbol) local search algorithm, either default wsat or qsat (default: wsat)
    local_search_threads (unsigned int) number of local search threads to find satisfiable solution (default: 0)
    log_lemmas (bool) display lemmas as self-contained SMT formulas (default: false)
    logic (symbol) logic used to setup the SMT solver (default: )
    lookahead.cube.cutoff (symbol) cutoff type used to create lookahead cubes: depth, freevars, psat, adaptive_freevars, adaptive_psat (default: depth)
    lookahead.cube.depth (unsigned int) cut-off depth to create cubes. Used when lookahead.cube.cutoff is depth. (default: 1)
    lookahead.cube.fraction (double) adaptive fraction to create lookahead cubes. Used when lookahead.cube.cutoff is adaptive_freevars or adaptive_psat (default: 0.4)
    lookahead.cube.freevars (double) cube free variable fraction. Used when lookahead.cube.cutoff is freevars (default: 0.8)
    lookahead.cube.psat.clause_base (double) clause base for PSAT cutoff (default: 2)
    lookahead.cube.psat.trigger (double) trigger value to create lookahead cubes for PSAT cutoff. Used when lookahead.cube.cutoff is psat (default: 5)
    lookahead.cube.psat.var_exp (double) free variable exponent for PSAT cutoff (default: 1)
    lookahead.delta_fraction (double) number between 0 and 1, the smaller the more literals are selected for double lookahead (default: 1.0)
    lookahead.double (bool) enable doubld lookahead (default: true)
    lookahead.global_autarky (bool) prefer to branch on variables that occur in clauses that are reduced (default: false)
    lookahead.preselect (bool) use pre-selection of subset of variables for branching (default: false)
    lookahead.reward (symbol) select lookahead heuristic: ternary, heule_schur (Heule Schur), heuleu (Heule Unit), unit, or march_cu (default: march_cu)
    lookahead.use_learned (bool) use learned clauses when selecting lookahead literal (default: false)
    lookahead_scores (bool) extract lookahead scores. A utility that can only be used from the DIMACS front-end (default: false)
    lookahead_simplify (bool) use lookahead solver during simplification (default: false)
    lookahead_simplify.bca (bool) add learned binary clauses as part of lookahead simplification (default: true)
    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)
    max_args (unsigned int) (default: 128) maximum number of arguments (per application) that will be considered by the greedy (quadratic) heuristic.
    max_conflicts (unsigned int) maximum number of conflicts (default: 4294967295)
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_depth (unsigned int) (default: 1024) maximum term depth.
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    max_prime (unsigned int) (default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step.
    max_rounds (unsigned int) (default: 4) maximum number of rounds.
    max_search_size (unsigned int) (default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space.
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)
    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)
    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )
    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)
    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)
    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)
    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)
    min_mag (unsigned int) Z3 represents algebraic numbers using a (square-free) polynomial p and an isolating interval (which contains one and only one root of p). This interval may be refined during the computations. This parameter specifies whether to cache the value of a refined interval or not. It says the minimal size of an interval for caching purposes is 1/2^16 (default: 16)
    minimize_conflicts (bool) minimize conflicts (default: false)
    minimize_lemmas (bool) minimize learned clauses (default: true)
    mode (symbol) NNF translation mode: skolem (skolem normal form), quantifiers (skolem normal form + quantifiers in NNF), full (default: skolem)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    nla2bv_bv_size (unsigned int) (default: 4) default bit-vector size used by nla2bv tactic.
    nla2bv_divisor (unsigned int) (default: 2) nla2bv tactic parameter.
    nla2bv_max_bv_size (unsigned int) (default: inf) maximum bit-vector size used by nla2bv tactic
    nla2bv_root (unsigned int) (default: 2) nla2bv tactic encodes reals into bit-vectors using expressions of the form a+b*sqrt(c), this parameter sets the value of c used in the encoding.
    norm_int_only (bool) (default: true) normalize only the bounds of integer constants.
    num_primes (unsigned int) (default: 1) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)'s. This parameter specify the maximum number of finite factorizations to be considered, before lifiting and searching.
    override_incremental (bool) override incremental safety gaps. Enable elimination of blocked clauses and variables even if solver is reused (default: false)
    partial (bool) enable/disable partial function interpretations (default: false)
    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)
    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)
    pb.lemma_format (symbol) generate either cardinality or pb lemmas (default: cardinality)
    pb.min_arity (unsigned int) minimal arity to compile pb/cardinality constraints to CNF (default: 9)
    pb.resolve (symbol) resolution strategy for boolean algebra solver: cardinality, rounding (default: cardinality)
    pb.solver (symbol) method for handling Pseudo-Boolean constraints: circuit (arithmetical circuit), sorting (sorting circuit), totalizer (use totalizer encoding), binary_merge, segmented, solver (use native solver) (default: solver)
    pb2bv_all_clauses_limit (unsigned int) (default: 8) maximum number of literals for using equivalent CNF encoding of PB constraint.
    pb2bv_cardinality_limit (unsigned int) (default: inf) limit for using arc-consistent cardinality constraint encoding.
    phase (symbol) phase selection strategy: always_false, always_true, basic_caching, random, caching (default: caching)
    phase.sticky (bool) use sticky phase caching (default: true)
    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)
    prob_search (bool) use probsat local search instead of CDCL (default: false)
    probing (bool) apply failed literal detection during simplification (default: true)
    probing_binary (bool) probe binary clauses (default: true)
    probing_cache (bool) add binary literals as lemmas (default: true)
    probing_cache_limit (unsigned int) cache binaries unless overall memory usage exceeds cache limit (default: 1024)
    probing_limit (unsigned int) limit to the number of probe calls (default: 5000000)
    produce_models (bool) (default: false) model generation.
    propagate.prefetch (bool) prefetch watch lists for assigned literals (default: true)
    propagate_eq (bool) (default: false) enable equality propagation from bounds.
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    pull_nested_quantifiers (bool) pull nested quantifiers (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    qe_nonlinear (bool) (default: false) enable virtual term substitution.
    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))
    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)
    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)
    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)
    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)
    qi.profile (bool) profile quantifier instantiation (default: false)
    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)
    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)
    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)
    random_freq (double) frequency of random case splits (default: 0.01)
    random_seed (unsigned int) random seed (default: 0)
    randomize (bool) randomize selection of a witness in nlsat. (default: true)
    refine_inj_axioms (bool) refine injectivity axioms (default: true)
    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)
    reorder (bool) reorder variables. (default: true)
    reorder.activity_scale (unsigned int) scaling factor for activity update (default: 100)
    reorder.base (unsigned int) number of conflicts per random reorder  (default: 4294967295)
    reorder.itau (double) inverse temperature for softmax (default: 4.0)
    rephase.base (unsigned int) number of conflicts per rephase  (default: 1000)
    resolution.cls_cutoff1 (unsigned int) limit1 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 100000000)
    resolution.cls_cutoff2 (unsigned int) limit2 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 700000000)
    resolution.limit (unsigned int) approx. maximum number of literals visited during variable elimination (default: 500000000)
    resolution.lit_cutoff_range1 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 700)
    resolution.lit_cutoff_range2 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 400)
    resolution.lit_cutoff_range3 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 300)
    resolution.occ_cutoff (unsigned int) first cutoff (on number of positive/negative occurrences) for Boolean variable elimination (default: 10)
    resolution.occ_cutoff_range1 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 8)
    resolution.occ_cutoff_range2 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 5)
    resolution.occ_cutoff_range3 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 3)
    restart (symbol) restart strategy: static, luby, ema or geometric (default: ema)
    restart.emafastglue (double) ema alpha factor for fast moving average (default: 0.03)
    restart.emaslowglue (double) ema alpha factor for slow moving average (default: 1e-05)
    restart.factor (double) restart increment factor for geometric strategy (default: 1.5)
    restart.fast (bool) use fast restart approach only removing less active literals. (default: true)
    restart.initial (unsigned int) initial restart (number of conflicts) (default: 2)
    restart.margin (double) margin between fast and slow restart factors. For ema (default: 1.1)
    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)
    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)
    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)
    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)
    retain_blocked_clauses (bool) retain blocked clauses as lemmas (default: true)
    rewrite_patterns (bool) rewrite patterns. (default: false)
    rlimit (unsigned int) default resource limit used for solvers. Unrestricted when set to 0. (default: 0)
    scc (bool) eliminate Boolean variables by computing strongly connected components (default: true)
    scc.tr (bool) apply transitive reduction, eliminate redundant binary clauses (default: true)
    search.sat.conflicts (unsigned int) period for solving for sat (in number of conflicts) (default: 400)
    search.unsat.conflicts (unsigned int) period for solving for unsat (in number of conflicts) (default: 400)
    seed (unsigned int) random seed. (default: 0)
    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)
    seq.use_derivatives (bool) dev flag (not for users) enable derivative based unfolding of regex (default: false)
    seq.use_unicode (bool) dev flag (not for users) enable unicode semantics (default: false)
    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)
    shuffle_vars (bool) use a random variable order. (default: false)
    simplify.delay (unsigned int) set initial delay of simplification by a conflict count (default: 0)
    simplify_conflicts (bool) simplify conflicts using equalities before resolving them in nlsat solver. (default: true)
    sk_hack (bool) hack for VCC (default: false)
    smtlib2_log (symbol) file to save solver interaction (default: )
    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations.
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
    split_factors (bool) (default: true) apply simplifications such as (= (* p1 p2) 0) --> (or (= p1 0) (= p2 0)).
    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)
    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)
    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)
    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)
    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)
    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)
    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)
    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)
    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)
    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)
    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)
    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)
    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)
    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)
    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)
    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)
    subsumption (bool) eliminate subsumed clauses (default: true)
    subsumption.limit (unsigned int) approx. maximum number of literals visited during subsumption (and subsumption resolution) (default: 100000000)
    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)
    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)
    theory_solver (bool) (default: true) use theory solvers.
    threads (unsigned int) number of parallel threads to use (default: 1)
    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)
    timeout (unsigned int) timeout on the solver object; overwrites a global timeout (default: 4294967295)
    v1 (bool) use Z3 version 1.x pretty printer (default: false)
    v2 (bool) use Z3 version 2.x (x <= 16) pretty printer (default: false)
    variable_decay (unsigned int) multiplier (divided by 100) for the VSIDS activity increment (default: 110)
    zero_accuracy (unsigned int) one of the most time-consuming operations in the real algebraic number module is determining the sign of a polynomial evaluated at a sample point with non-rational algebraic number values. Let k be the value of this option. If k is 0, Z3 uses precise computation. Otherwise, the result of a polynomial evaluation is considered to be 0 if Z3 can show it is inside the interval (-1/2^k, 1/2^k) (default: 0)
- sine-filter eliminate premises using Sine Qua Non
- qfbv-sls (try to) solve using stochastic local search for QF_BV.
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    context_solve (bool) (default: false) solve equalities under disjunctions.
    early_prune (bool) use early pruning for score prediction (default: true)
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_labels (bool) remove/ignore labels in the input formula, this option is ignored if proofs are enabled (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    ite_solver (bool) (default: true) use if-then-else solver.
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    max_args (unsigned int) (default: 128) maximum number of arguments (per application) that will be considered by the greedy (quadratic) heuristic.
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    max_restarts (unsigned int) maximum number of restarts (default: 4294967295)
    max_rounds (unsigned int) (default: 4) maximum number of rounds.
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    mode (symbol) NNF translation mode: skolem (skolem normal form), quantifiers (skolem normal form + quantifiers in NNF), full (default: skolem)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    paws_init (unsigned int) initial/minimum assertion weights (default: 40)
    paws_sp (unsigned int) smooth assertion weights with probability paws_sp / 1024 (default: 52)
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    random_offset (bool) use random offset for candidate evaluation (default: true)
    random_seed (unsigned int) random seed (default: 0)
    rescore (bool) rescore/normalize top-level score every base restart interval (default: true)
    restart_base (unsigned int) base restart interval given by moves per run (default: 100)
    restart_init (bool) initialize to 0 or random value (= 1) after restart (default: false)
    rewrite_patterns (bool) rewrite patterns. (default: false)
    scale_unsat (double) scale score of unsat expressions by this factor (default: 0.5)
    sk_hack (bool) hack for VCC (default: false)
    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations.
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
    theory_solver (bool) (default: true) use theory solvers.
    track_unsat (bool) keep a list of unsat assertions as done in SAT - currently disabled internally (default: false)
    vns_mc (unsigned int) in local minima, try Monte Carlo sampling vns_mc many 2-bit-flips per bit (default: 0)
    vns_repick (bool) in local minima, try picking a different assertion (only for walksat) (default: false)
    walksat (bool) use walksat assertion selection (instead of gsat) (default: true)
    walksat_repick (bool) repick assertion if randomizing in local minima (default: true)
    walksat_ucb (bool) use bandit heuristic for walksat assertion selection (instead of random) (default: true)
    walksat_ucb_constant (double) the ucb constant c in the term score + c * f(touched) (default: 20.0)
    walksat_ucb_forget (double) scale touched by this factor every base restart interval (default: 1.0)
    walksat_ucb_init (bool) initialize total ucb touched to formula size (default: false)
    walksat_ucb_noise (double) add noise 0 <= 256 * ucb_noise to ucb score for assertion selection (default: 0.0002)
    wp (unsigned int) random walk with probability wp / 1024 (default: 100)
- nra builtin strategy for solving NRA problems.
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)
    arith.bounded_expansion (bool) box variables used in branch and bound into bound assumptions (default: false)
    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)
    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)
    arith.cheap_eqs (unsigned int) 0 - do not run, 1 - use tree, 2 - use table (default: 1)
    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)
    arith.eager_eq_axioms (bool) eager equality axioms (default: true)
    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)
    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)
    arith.ignore_int (bool) treat integer variables as real (default: false)
    arith.int_eq_branch (bool) branching using derived integer equations (default: false)
    arith.min (bool) minimize cost (default: false)
    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.branching (bool) branching on integer variables in non linear clusters, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.expp (bool) expensive patching (default: false)
    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)
    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)
    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)
    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)
    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)
    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)
    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)
    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)
    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.horner (bool) run horner's heuristic (default: true)
    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)
    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)
    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.nra (bool) call nra_solver when incremental lianirization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)
    arith.nl.order (bool) run order lemmas (default: true)
    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)
    arith.nl.tangents (bool) run tangent lemmas (default: true)
    arith.print_ext_var_names (bool) print external variable names (default: false)
    arith.print_stats (bool) print statistic (default: false)
    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)
    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine bounds (default: 2)
    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)
    arith.reflect (bool) reflect arithmetical operators to the congruence closure (default: true)
    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)
    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)
    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    array.extensional (bool) extensional array theory (default: true)
    array.weak (bool) weak array theory (default: false)
    auto_config (bool) automatically configure solver (default: true)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)
    bv.reflect (bool) create enode for every bit-vector term (default: true)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    candidate_models (bool) (default: false) create candidate models even when quantifier or theory reasoning is incomplete.
    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)
    check_lemmas (bool) check lemmas on the fly using an independent nlsat solver (default: false)
    clause_proof (bool) record a clausal proof (default: false)
    common_patterns (bool) (default: true) minimize the number of auxiliary variables during CNF encoding by identifing commonly used patterns
    complete (bool) (default: true) add constraints to make sure that any interpretation of a underspecified arithmetic operators is a function. The result will include additional uninterpreted functions/constants: /0, div0, mod0, 0^0, neg-root
    context_solve (bool) (default: false) solve equalities under disjunctions.
    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)
    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)
    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)
    core.minimize (bool) minimize unsat core produced by SMT context (default: false)
    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)
    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)
    dack.eq (bool) enable dynamic ackermannization for transtivity of equalities (default: false)
    dack.factor (double) number of instance per conflict (default: 0.1)
    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)
    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)
    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)
    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)
    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)
    distributivity (bool) (default: true) minimize the number of auxiliary variables during CNF encoding by applying distributivity over unshared subformulas
    distributivity_blowup (unsigned int) (default: 32) maximum overhead for applying distributivity during CNF encoding
    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_inverses (bool) (default: true) eliminate inverse trigonometric functions (asin, acos, atan).
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_root_objects (bool) (default: true) eliminate root objects.
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    ematching (bool) E-Matching based quantifier instantiation (default: true)
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    factor (bool) (default: true) factor polynomials.
    factor_max_prime (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step (default: 31)
    factor_num_primes (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)'s. This parameter specify the maximum number of finite factorizations to be considered, before lifiting and searching (default: 1)
    factor_search_size (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space (default: 5000)
    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_labels (bool) remove/ignore labels in the input formula, this option is ignored if proofs are enabled (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    induction (bool) enable generation of induction lemmas (default: false)
    inline_vars (bool) inline variables that can be isolated from equations (not supported in incremental mode) (default: false)
    ite_chaing (bool) (default: true) minimize the number of auxiliary variables during CNF encoding by identifing if-then-else chains
    ite_extra (bool) (default: true) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    ite_solver (bool) (default: true) use if-then-else solver.
    lazy (unsigned int) how lazy the solver is. (default: 0)
    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    log_lemmas (bool) display lemmas as self-contained SMT formulas (default: false)
    logic (symbol) logic used to setup the SMT solver (default: )
    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)
    max_args (unsigned int) (default: 128) maximum number of arguments (per application) that will be considered by the greedy (quadratic) heuristic.
    max_conflicts (unsigned int) maximum number of conflicts. (default: 4294967295)
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    max_prime (unsigned int) (default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step.
    max_rounds (unsigned int) (default: 4) maximum number of rounds.
    max_search_size (unsigned int) (default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space.
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)
    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)
    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )
    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)
    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)
    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)
    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)
    min_mag (unsigned int) Z3 represents algebraic numbers using a (square-free) polynomial p and an isolating interval (which contains one and only one root of p). This interval may be refined during the computations. This parameter specifies whether to cache the value of a refined interval or not. It says the minimal size of an interval for caching purposes is 1/2^16 (default: 16)
    minimize_conflicts (bool) minimize conflicts (default: false)
    mode (symbol) NNF translation mode: skolem (skolem normal form), quantifiers (skolem normal form + quantifiers in NNF), full (default: skolem)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    num_primes (unsigned int) (default: 1) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)'s. This parameter specify the maximum number of finite factorizations to be considered, before lifiting and searching.
    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)
    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)
    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    pull_nested_quantifiers (bool) pull nested quantifiers (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))
    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)
    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)
    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)
    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)
    qi.profile (bool) profile quantifier instantiation (default: false)
    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)
    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)
    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)
    random_seed (unsigned int) random seed for the smt solver (default: 0)
    randomize (bool) randomize selection of a witness in nlsat. (default: true)
    refine_inj_axioms (bool) refine injectivity axioms (default: true)
    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)
    reorder (bool) reorder variables. (default: true)
    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)
    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)
    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)
    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)
    rewrite_patterns (bool) rewrite patterns. (default: false)
    seed (unsigned int) random seed. (default: 0)
    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)
    seq.use_derivatives (bool) dev flag (not for users) enable derivative based unfolding of regex (default: false)
    seq.use_unicode (bool) dev flag (not for users) enable unicode semantics (default: false)
    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)
    shuffle_vars (bool) use a random variable order. (default: false)
    simplify_conflicts (bool) simplify conflicts using equalities before resolving them in nlsat solver. (default: true)
    sk_hack (bool) hack for VCC (default: false)
    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations.
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
    split_factors (bool) (default: true) apply simplifications such as (= (* p1 p2) 0) --> (or (= p1 0) (= p2 0)).
    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)
    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)
    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)
    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)
    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)
    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)
    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)
    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)
    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)
    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)
    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)
    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)
    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)
    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)
    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)
    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)
    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)
    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)
    theory_solver (bool) (default: true) use theory solvers.
    threads (unsigned int) maximal number of parallel threads. (default: 1)
    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)
    zero_accuracy (unsigned int) one of the most time-consuming operations in the real algebraic number module is determining the sign of a polynomial evaluated at a sample point with non-rational algebraic number values. Let k be the value of this option. If k is 0, Z3 uses precise computation. Otherwise, the result of a polynomial evaluation is considered to be 0 if Z3 can show it is inside the interval (-1/2^k, 1/2^k) (default: 0)
- qfaufbv builtin strategy for solving QF_AUFBV problems.
    abce (bool) eliminate blocked clauses using asymmetric literals (default: false)
    acce (bool) eliminate covered clauses using asymmetric added literals (default: false)
    aig_per_assertion (bool) (default: true) process one assertion at a time.
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    anf (bool) enable ANF based simplification in-processing (default: false)
    anf.delay (unsigned int) delay ANF simplification by in-processing round (default: 2)
    anf.exlin (bool) enable extended linear simplification (default: false)
    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)
    arith.bounded_expansion (bool) box variables used in branch and bound into bound assumptions (default: false)
    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)
    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)
    arith.cheap_eqs (unsigned int) 0 - do not run, 1 - use tree, 2 - use table (default: 1)
    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)
    arith.eager_eq_axioms (bool) eager equality axioms (default: true)
    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)
    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)
    arith.ignore_int (bool) treat integer variables as real (default: false)
    arith.int_eq_branch (bool) branching using derived integer equations (default: false)
    arith.min (bool) minimize cost (default: false)
    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.branching (bool) branching on integer variables in non linear clusters, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.expp (bool) expensive patching (default: false)
    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)
    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)
    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)
    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)
    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)
    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)
    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)
    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)
    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.horner (bool) run horner's heuristic (default: true)
    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)
    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)
    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.nra (bool) call nra_solver when incremental lianirization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)
    arith.nl.order (bool) run order lemmas (default: true)
    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)
    arith.nl.tangents (bool) run tangent lemmas (default: true)
    arith.print_ext_var_names (bool) print external variable names (default: false)
    arith.print_stats (bool) print statistic (default: false)
    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)
    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine bounds (default: 2)
    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)
    arith.reflect (bool) reflect arithmetical operators to the congruence closure (default: true)
    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)
    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)
    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    array.extensional (bool) extensional array theory (default: true)
    array.weak (bool) weak array theory (default: false)
    asymm_branch (bool) asymmetric branching (default: true)
    asymm_branch.all (bool) asymmetric branching on all literals per clause (default: false)
    asymm_branch.delay (unsigned int) number of simplification rounds to wait until invoking asymmetric branch simplification (default: 1)
    asymm_branch.limit (unsigned int) approx. maximum number of literals visited during asymmetric branching (default: 100000000)
    asymm_branch.rounds (unsigned int) maximal number of rounds to run asymmetric branch simplifications if progress is made (default: 2)
    asymm_branch.sampled (bool) use sampling based asymmetric branching based on binary implication graph (default: true)
    ate (bool) asymmetric tautology elimination (default: true)
    auto_config (bool) automatically configure solver (default: true)
    backtrack.conflicts (unsigned int) number of conflicts before enabling chronological backtracking (default: 4000)
    backtrack.scopes (unsigned int) number of scopes to enable chronological backtracking (default: 100)
    bca (bool) blocked clause addition - add blocked binary clauses (default: false)
    bce (bool) eliminate blocked clauses (default: false)
    bce_at (unsigned int) eliminate blocked clauses only once at the given simplification round (default: 2)
    bce_delay (unsigned int) delay eliminate blocked clauses until simplification round (default: 2)
    binspr (bool) enable SPR inferences of binary propagation redundant clauses. This inprocessing step eliminates models (default: false)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_add (bool) (default: true) bit-blast adders.
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    blast_full (bool) (default: false) bit-blast any term with bit-vector sort, this option will make E-matching ineffective in any pattern containing bit-vector terms.
    blast_mul (bool) (default: true) bit-blast multipliers (and dividers, remainders).
    blast_quant (bool) (default: false) bit-blast quantified variables.
    blocked_clause_limit (unsigned int) maximum number of literals visited during blocked clause elimination (default: 100000000)
    branching.anti_exploration (bool) apply anti-exploration heuristic for branch selection (default: false)
    branching.heuristic (symbol) branching heuristic vsids, chb (default: vsids)
    burst_search (unsigned int) number of conflicts before first global simplification (default: 100)
    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)
    bv.reflect (bool) create enode for every bit-vector term (default: true)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    candidate_models (bool) (default: false) create candidate models even when quantifier or theory reasoning is incomplete.
    cardinality.encoding (symbol) encoding used for at-most-k constraints: grouped, bimander, ordered, unate, circuit (default: grouped)
    cardinality.solver (bool) use cardinality solver (default: true)
    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)
    cce (bool) eliminate covered clauses (default: false)
    clause_proof (bool) record a clausal proof (default: false)
    context_solve (bool) (default: false) solve equalities under disjunctions.
    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)
    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)
    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)
    core.minimize (bool) minimize unsat core produced by SMT context (default: false)
    core.minimize_partial (bool) apply partial (cheap) core minimization (default: false)
    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)
    cut (bool) enable AIG based simplification in-processing (default: false)
    cut.aig (bool) extract aigs (and ites) from cluases for cut simplification (default: false)
    cut.delay (unsigned int) delay cut simplification by in-processing round (default: 2)
    cut.dont_cares (bool) integrate dont cares with cuts (default: true)
    cut.force (bool) force redoing cut-enumeration until a fixed-point (default: false)
    cut.lut (bool) extract luts from clauses for cut simplification (default: false)
    cut.npn3 (bool) extract 3 input functions from clauses for cut simplification (default: false)
    cut.redundancies (bool) integrate redundancy checking of cuts (default: true)
    cut.xor (bool) extract xors from clauses for cut simplification (default: false)
    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)
    dack.eq (bool) enable dynamic ackermannization for transtivity of equalities (default: false)
    dack.factor (double) number of instance per conflict (default: 0.1)
    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)
    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)
    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)
    ddfw.init_clause_weight (unsigned int) initial clause weight for DDFW local search (default: 8)
    ddfw.reinit_base (unsigned int) increment basis for geometric backoff scheme of re-initialization of weights (default: 10000)
    ddfw.restart_base (unsigned int) number of flips used a starting point for hessitant restart backoff (default: 100000)
    ddfw.threads (unsigned int) number of ddfw threads to run in parallel with sat solver (default: 0)
    ddfw.use_reward_pct (unsigned int) percentage to pick highest reward variable when it has reward 0 (default: 15)
    ddfw_search (bool) use ddfw local search instead of CDCL (default: false)
    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)
    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)
    dimacs.core (bool) extract core from DIMACS benchmarks (default: false)
    div0_ackermann_limit (unsigned int) a bound for number of congruence Ackermann lemmas for div0 modelling (default: 1000)
    drat.activity (bool) dump variable activities (default: false)
    drat.binary (bool) use Binary DRAT output format (default: false)
    drat.check_sat (bool) build up internal trace, check satisfying model (default: false)
    drat.check_unsat (bool) build up internal proof and check (default: false)
    drat.file (symbol) file to dump DRAT proofs (default: )
    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)
    dyn_sub_res (bool) dynamic subsumption resolution for minimizing learned clauses (default: true)
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    elim_vars (bool) enable variable elimination using resolution during simplification (default: true)
    elim_vars_bdd (bool) enable variable elimination using BDD recompilation during simplification (default: true)
    elim_vars_bdd_delay (unsigned int) delay elimination of variables using BDDs until after simplification round (default: 3)
    ematching (bool) E-Matching based quantifier instantiation (default: true)
    enable_pre_simplify (bool) enable pre simplifications before the bounded search (default: false)
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    force_cleanup (bool) force cleanup to remove tautologies and simplify clauses (default: false)
    gc (symbol) garbage collection strategy: psm, glue, glue_psm, dyn_psm (default: glue_psm)
    gc.burst (bool) perform eager garbage collection during initialization (default: false)
    gc.defrag (bool) defragment clauses when garbage collecting (default: true)
    gc.increment (unsigned int) increment to the garbage collection threshold (default: 500)
    gc.initial (unsigned int) learned clauses garbage collection frequency (default: 20000)
    gc.k (unsigned int) learned clauses that are inactive for k gc rounds are permanently deleted (only used in dyn_psm) (default: 7)
    gc.small_lbd (unsigned int) learned clauses with small LBD are never deleted (only used in dyn_psm) (default: 3)
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    induction (bool) enable generation of induction lemmas (default: false)
    inprocess.max (unsigned int) maximal number of inprocessing passes (default: 4294967295)
    inprocess.out (symbol) file to dump result of the first inprocessing step and exit (default: )
    ite_extra (bool) (default: true) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    ite_solver (bool) (default: true) use if-then-else solver.
    learned (bool) (default: false) collect also learned clauses.
    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    local_search (bool) use local search instead of CDCL (default: false)
    local_search_dbg_flips (bool) write debug information for number of flips (default: false)
    local_search_mode (symbol) local search algorithm, either default wsat or qsat (default: wsat)
    local_search_threads (unsigned int) number of local search threads to find satisfiable solution (default: 0)
    logic (symbol) logic used to setup the SMT solver (default: )
    lookahead.cube.cutoff (symbol) cutoff type used to create lookahead cubes: depth, freevars, psat, adaptive_freevars, adaptive_psat (default: depth)
    lookahead.cube.depth (unsigned int) cut-off depth to create cubes. Used when lookahead.cube.cutoff is depth. (default: 1)
    lookahead.cube.fraction (double) adaptive fraction to create lookahead cubes. Used when lookahead.cube.cutoff is adaptive_freevars or adaptive_psat (default: 0.4)
    lookahead.cube.freevars (double) cube free variable fraction. Used when lookahead.cube.cutoff is freevars (default: 0.8)
    lookahead.cube.psat.clause_base (double) clause base for PSAT cutoff (default: 2)
    lookahead.cube.psat.trigger (double) trigger value to create lookahead cubes for PSAT cutoff. Used when lookahead.cube.cutoff is psat (default: 5)
    lookahead.cube.psat.var_exp (double) free variable exponent for PSAT cutoff (default: 1)
    lookahead.delta_fraction (double) number between 0 and 1, the smaller the more literals are selected for double lookahead (default: 1.0)
    lookahead.double (bool) enable doubld lookahead (default: true)
    lookahead.global_autarky (bool) prefer to branch on variables that occur in clauses that are reduced (default: false)
    lookahead.preselect (bool) use pre-selection of subset of variables for branching (default: false)
    lookahead.reward (symbol) select lookahead heuristic: ternary, heule_schur (Heule Schur), heuleu (Heule Unit), unit, or march_cu (default: march_cu)
    lookahead.use_learned (bool) use learned clauses when selecting lookahead literal (default: false)
    lookahead_scores (bool) extract lookahead scores. A utility that can only be used from the DIMACS front-end (default: false)
    lookahead_simplify (bool) use lookahead solver during simplification (default: false)
    lookahead_simplify.bca (bool) add learned binary clauses as part of lookahead simplification (default: true)
    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)
    max_args (unsigned int) (default: 128) maximum number of arguments (per application) that will be considered by the greedy (quadratic) heuristic.
    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    max_rounds (unsigned int) (default: 4) maximum number of rounds.
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)
    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)
    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )
    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)
    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)
    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)
    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)
    minimize_lemmas (bool) minimize learned clauses (default: true)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    override_incremental (bool) override incremental safety gaps. Enable elimination of blocked clauses and variables even if solver is reused (default: false)
    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)
    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)
    pb.lemma_format (symbol) generate either cardinality or pb lemmas (default: cardinality)
    pb.min_arity (unsigned int) minimal arity to compile pb/cardinality constraints to CNF (default: 9)
    pb.resolve (symbol) resolution strategy for boolean algebra solver: cardinality, rounding (default: cardinality)
    pb.solver (symbol) method for handling Pseudo-Boolean constraints: circuit (arithmetical circuit), sorting (sorting circuit), totalizer (use totalizer encoding), binary_merge, segmented, solver (use native solver) (default: solver)
    phase (symbol) phase selection strategy: always_false, always_true, basic_caching, random, caching (default: caching)
    phase.sticky (bool) use sticky phase caching (default: true)
    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)
    prob_search (bool) use probsat local search instead of CDCL (default: false)
    probing (bool) apply failed literal detection during simplification (default: true)
    probing_binary (bool) probe binary clauses (default: true)
    probing_cache (bool) add binary literals as lemmas (default: true)
    probing_cache_limit (unsigned int) cache binaries unless overall memory usage exceeds cache limit (default: 1024)
    probing_limit (unsigned int) limit to the number of probe calls (default: 5000000)
    propagate.prefetch (bool) prefetch watch lists for assigned literals (default: true)
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    pull_nested_quantifiers (bool) pull nested quantifiers (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))
    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)
    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)
    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)
    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)
    qi.profile (bool) profile quantifier instantiation (default: false)
    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)
    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)
    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)
    random_freq (double) frequency of random case splits (default: 0.01)
    random_seed (unsigned int) random seed for the smt solver (default: 0)
    refine_inj_axioms (bool) refine injectivity axioms (default: true)
    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)
    reorder.activity_scale (unsigned int) scaling factor for activity update (default: 100)
    reorder.base (unsigned int) number of conflicts per random reorder  (default: 4294967295)
    reorder.itau (double) inverse temperature for softmax (default: 4.0)
    rephase.base (unsigned int) number of conflicts per rephase  (default: 1000)
    resolution.cls_cutoff1 (unsigned int) limit1 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 100000000)
    resolution.cls_cutoff2 (unsigned int) limit2 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 700000000)
    resolution.limit (unsigned int) approx. maximum number of literals visited during variable elimination (default: 500000000)
    resolution.lit_cutoff_range1 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 700)
    resolution.lit_cutoff_range2 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 400)
    resolution.lit_cutoff_range3 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 300)
    resolution.occ_cutoff (unsigned int) first cutoff (on number of positive/negative occurrences) for Boolean variable elimination (default: 10)
    resolution.occ_cutoff_range1 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 8)
    resolution.occ_cutoff_range2 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 5)
    resolution.occ_cutoff_range3 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 3)
    restart (symbol) restart strategy: static, luby, ema or geometric (default: ema)
    restart.emafastglue (double) ema alpha factor for fast moving average (default: 0.03)
    restart.emaslowglue (double) ema alpha factor for slow moving average (default: 1e-05)
    restart.factor (double) restart increment factor for geometric strategy (default: 1.5)
    restart.fast (bool) use fast restart approach only removing less active literals. (default: true)
    restart.initial (unsigned int) initial restart (number of conflicts) (default: 2)
    restart.margin (double) margin between fast and slow restart factors. For ema (default: 1.1)
    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)
    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)
    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)
    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)
    retain_blocked_clauses (bool) retain blocked clauses as lemmas (default: true)
    rewrite_patterns (bool) rewrite patterns. (default: false)
    scc (bool) eliminate Boolean variables by computing strongly connected components (default: true)
    scc.tr (bool) apply transitive reduction, eliminate redundant binary clauses (default: true)
    search.sat.conflicts (unsigned int) period for solving for sat (in number of conflicts) (default: 400)
    search.unsat.conflicts (unsigned int) period for solving for unsat (in number of conflicts) (default: 400)
    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)
    seq.use_derivatives (bool) dev flag (not for users) enable derivative based unfolding of regex (default: false)
    seq.use_unicode (bool) dev flag (not for users) enable unicode semantics (default: false)
    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)
    simplify.delay (unsigned int) set initial delay of simplification by a conflict count (default: 0)
    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations.
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)
    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)
    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)
    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)
    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)
    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)
    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)
    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)
    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)
    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)
    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)
    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)
    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)
    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)
    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)
    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)
    subsumption (bool) eliminate subsumed clauses (default: true)
    subsumption.limit (unsigned int) approx. maximum number of literals visited during subsumption (and subsumption resolution) (default: 100000000)
    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)
    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)
    theory_solver (bool) (default: true) use theory solvers.
    threads (unsigned int) maximal number of parallel threads. (default: 1)
    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)
    variable_decay (unsigned int) multiplier (divided by 100) for the VSIDS activity increment (default: 110)
- qfauflia builtin strategy for solving QF_AUFLIA problems.
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)
    arith.bounded_expansion (bool) box variables used in branch and bound into bound assumptions (default: false)
    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)
    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)
    arith.cheap_eqs (unsigned int) 0 - do not run, 1 - use tree, 2 - use table (default: 1)
    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)
    arith.eager_eq_axioms (bool) eager equality axioms (default: true)
    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)
    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)
    arith.ignore_int (bool) treat integer variables as real (default: false)
    arith.int_eq_branch (bool) branching using derived integer equations (default: false)
    arith.min (bool) minimize cost (default: false)
    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.branching (bool) branching on integer variables in non linear clusters, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.expp (bool) expensive patching (default: false)
    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)
    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)
    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)
    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)
    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)
    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)
    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)
    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)
    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.horner (bool) run horner's heuristic (default: true)
    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)
    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)
    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.nra (bool) call nra_solver when incremental lianirization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)
    arith.nl.order (bool) run order lemmas (default: true)
    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)
    arith.nl.tangents (bool) run tangent lemmas (default: true)
    arith.print_ext_var_names (bool) print external variable names (default: false)
    arith.print_stats (bool) print statistic (default: false)
    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)
    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine bounds (default: 2)
    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)
    arith.reflect (bool) reflect arithmetical operators to the congruence closure (default: true)
    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)
    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)
    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    array.extensional (bool) extensional array theory (default: true)
    array.weak (bool) weak array theory (default: false)
    auto_config (bool) automatically configure solver (default: true)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)
    bv.reflect (bool) create enode for every bit-vector term (default: true)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    candidate_models (bool) (default: false) create candidate models even when quantifier or theory reasoning is incomplete.
    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)
    clause_proof (bool) record a clausal proof (default: false)
    context_solve (bool) (default: false) solve equalities under disjunctions.
    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)
    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)
    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)
    core.minimize (bool) minimize unsat core produced by SMT context (default: false)
    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)
    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)
    dack.eq (bool) enable dynamic ackermannization for transtivity of equalities (default: false)
    dack.factor (double) number of instance per conflict (default: 0.1)
    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)
    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)
    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)
    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)
    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)
    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    ematching (bool) E-Matching based quantifier instantiation (default: true)
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    induction (bool) enable generation of induction lemmas (default: false)
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    ite_solver (bool) (default: true) use if-then-else solver.
    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    logic (symbol) logic used to setup the SMT solver (default: )
    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)
    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    max_rounds (unsigned int) (default: 4) maximum number of rounds.
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)
    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)
    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )
    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)
    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)
    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)
    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)
    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)
    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    pull_nested_quantifiers (bool) pull nested quantifiers (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))
    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)
    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)
    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)
    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)
    qi.profile (bool) profile quantifier instantiation (default: false)
    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)
    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)
    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)
    random_seed (unsigned int) random seed for the smt solver (default: 0)
    refine_inj_axioms (bool) refine injectivity axioms (default: true)
    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)
    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)
    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)
    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)
    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)
    rewrite_patterns (bool) rewrite patterns. (default: false)
    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)
    seq.use_derivatives (bool) dev flag (not for users) enable derivative based unfolding of regex (default: false)
    seq.use_unicode (bool) dev flag (not for users) enable unicode semantics (default: false)
    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)
    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations.
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)
    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)
    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)
    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)
    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)
    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)
    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)
    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)
    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)
    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)
    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)
    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)
    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)
    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)
    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)
    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)
    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)
    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)
    theory_solver (bool) (default: true) use theory solvers.
    threads (unsigned int) maximal number of parallel threads. (default: 1)
    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)
- qfbv builtin strategy for solving QF_BV problems.
    abce (bool) eliminate blocked clauses using asymmetric literals (default: false)
    acce (bool) eliminate covered clauses using asymmetric added literals (default: false)
    aig_per_assertion (bool) (default: true) process one assertion at a time.
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    anf (bool) enable ANF based simplification in-processing (default: false)
    anf.delay (unsigned int) delay ANF simplification by in-processing round (default: 2)
    anf.exlin (bool) enable extended linear simplification (default: false)
    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)
    arith.bounded_expansion (bool) box variables used in branch and bound into bound assumptions (default: false)
    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)
    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)
    arith.cheap_eqs (unsigned int) 0 - do not run, 1 - use tree, 2 - use table (default: 1)
    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)
    arith.eager_eq_axioms (bool) eager equality axioms (default: true)
    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)
    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)
    arith.ignore_int (bool) treat integer variables as real (default: false)
    arith.int_eq_branch (bool) branching using derived integer equations (default: false)
    arith.min (bool) minimize cost (default: false)
    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.branching (bool) branching on integer variables in non linear clusters, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.expp (bool) expensive patching (default: false)
    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)
    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)
    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)
    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)
    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)
    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)
    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)
    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)
    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.horner (bool) run horner's heuristic (default: true)
    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)
    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)
    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.nra (bool) call nra_solver when incremental lianirization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)
    arith.nl.order (bool) run order lemmas (default: true)
    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)
    arith.nl.tangents (bool) run tangent lemmas (default: true)
    arith.print_ext_var_names (bool) print external variable names (default: false)
    arith.print_stats (bool) print statistic (default: false)
    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)
    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine bounds (default: 2)
    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)
    arith.reflect (bool) reflect arithmetical operators to the congruence closure (default: true)
    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)
    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)
    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    array.extensional (bool) extensional array theory (default: true)
    array.weak (bool) weak array theory (default: false)
    asymm_branch (bool) asymmetric branching (default: true)
    asymm_branch.all (bool) asymmetric branching on all literals per clause (default: false)
    asymm_branch.delay (unsigned int) number of simplification rounds to wait until invoking asymmetric branch simplification (default: 1)
    asymm_branch.limit (unsigned int) approx. maximum number of literals visited during asymmetric branching (default: 100000000)
    asymm_branch.rounds (unsigned int) maximal number of rounds to run asymmetric branch simplifications if progress is made (default: 2)
    asymm_branch.sampled (bool) use sampling based asymmetric branching based on binary implication graph (default: true)
    ate (bool) asymmetric tautology elimination (default: true)
    auto_config (bool) automatically configure solver (default: true)
    backtrack.conflicts (unsigned int) number of conflicts before enabling chronological backtracking (default: 4000)
    backtrack.scopes (unsigned int) number of scopes to enable chronological backtracking (default: 100)
    bca (bool) blocked clause addition - add blocked binary clauses (default: false)
    bce (bool) eliminate blocked clauses (default: false)
    bce_at (unsigned int) eliminate blocked clauses only once at the given simplification round (default: 2)
    bce_delay (unsigned int) delay eliminate blocked clauses until simplification round (default: 2)
    binspr (bool) enable SPR inferences of binary propagation redundant clauses. This inprocessing step eliminates models (default: false)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_add (bool) (default: true) bit-blast adders.
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    blast_full (bool) (default: false) bit-blast any term with bit-vector sort, this option will make E-matching ineffective in any pattern containing bit-vector terms.
    blast_mul (bool) (default: true) bit-blast multipliers (and dividers, remainders).
    blast_quant (bool) (default: false) bit-blast quantified variables.
    blocked_clause_limit (unsigned int) maximum number of literals visited during blocked clause elimination (default: 100000000)
    branching.anti_exploration (bool) apply anti-exploration heuristic for branch selection (default: false)
    branching.heuristic (symbol) branching heuristic vsids, chb (default: vsids)
    burst_search (unsigned int) number of conflicts before first global simplification (default: 100)
    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)
    bv.reflect (bool) create enode for every bit-vector term (default: true)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    candidate_models (bool) (default: false) create candidate models even when quantifier or theory reasoning is incomplete.
    cardinality.encoding (symbol) encoding used for at-most-k constraints: grouped, bimander, ordered, unate, circuit (default: grouped)
    cardinality.solver (bool) use cardinality solver (default: true)
    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)
    cce (bool) eliminate covered clauses (default: false)
    clause_proof (bool) record a clausal proof (default: false)
    context_solve (bool) (default: false) solve equalities under disjunctions.
    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)
    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)
    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)
    core.minimize (bool) minimize unsat core produced by SMT context (default: false)
    core.minimize_partial (bool) apply partial (cheap) core minimization (default: false)
    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)
    cut (bool) enable AIG based simplification in-processing (default: false)
    cut.aig (bool) extract aigs (and ites) from cluases for cut simplification (default: false)
    cut.delay (unsigned int) delay cut simplification by in-processing round (default: 2)
    cut.dont_cares (bool) integrate dont cares with cuts (default: true)
    cut.force (bool) force redoing cut-enumeration until a fixed-point (default: false)
    cut.lut (bool) extract luts from clauses for cut simplification (default: false)
    cut.npn3 (bool) extract 3 input functions from clauses for cut simplification (default: false)
    cut.redundancies (bool) integrate redundancy checking of cuts (default: true)
    cut.xor (bool) extract xors from clauses for cut simplification (default: false)
    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)
    dack.eq (bool) enable dynamic ackermannization for transtivity of equalities (default: false)
    dack.factor (double) number of instance per conflict (default: 0.1)
    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)
    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)
    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)
    ddfw.init_clause_weight (unsigned int) initial clause weight for DDFW local search (default: 8)
    ddfw.reinit_base (unsigned int) increment basis for geometric backoff scheme of re-initialization of weights (default: 10000)
    ddfw.restart_base (unsigned int) number of flips used a starting point for hessitant restart backoff (default: 100000)
    ddfw.threads (unsigned int) number of ddfw threads to run in parallel with sat solver (default: 0)
    ddfw.use_reward_pct (unsigned int) percentage to pick highest reward variable when it has reward 0 (default: 15)
    ddfw_search (bool) use ddfw local search instead of CDCL (default: false)
    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)
    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)
    dimacs.core (bool) extract core from DIMACS benchmarks (default: false)
    div0_ackermann_limit (unsigned int) a bound for number of congruence Ackermann lemmas for div0 modelling (default: 1000)
    drat.activity (bool) dump variable activities (default: false)
    drat.binary (bool) use Binary DRAT output format (default: false)
    drat.check_sat (bool) build up internal trace, check satisfying model (default: false)
    drat.check_unsat (bool) build up internal proof and check (default: false)
    drat.file (symbol) file to dump DRAT proofs (default: )
    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)
    dyn_sub_res (bool) dynamic subsumption resolution for minimizing learned clauses (default: true)
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    elim_vars (bool) enable variable elimination using resolution during simplification (default: true)
    elim_vars_bdd (bool) enable variable elimination using BDD recompilation during simplification (default: true)
    elim_vars_bdd_delay (unsigned int) delay elimination of variables using BDDs until after simplification round (default: 3)
    ematching (bool) E-Matching based quantifier instantiation (default: true)
    enable_pre_simplify (bool) enable pre simplifications before the bounded search (default: false)
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    force_cleanup (bool) force cleanup to remove tautologies and simplify clauses (default: false)
    gc (symbol) garbage collection strategy: psm, glue, glue_psm, dyn_psm (default: glue_psm)
    gc.burst (bool) perform eager garbage collection during initialization (default: false)
    gc.defrag (bool) defragment clauses when garbage collecting (default: true)
    gc.increment (unsigned int) increment to the garbage collection threshold (default: 500)
    gc.initial (unsigned int) learned clauses garbage collection frequency (default: 20000)
    gc.k (unsigned int) learned clauses that are inactive for k gc rounds are permanently deleted (only used in dyn_psm) (default: 7)
    gc.small_lbd (unsigned int) learned clauses with small LBD are never deleted (only used in dyn_psm) (default: 3)
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    induction (bool) enable generation of induction lemmas (default: false)
    inprocess.max (unsigned int) maximal number of inprocessing passes (default: 4294967295)
    inprocess.out (symbol) file to dump result of the first inprocessing step and exit (default: )
    ite_extra (bool) (default: true) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    ite_solver (bool) (default: true) use if-then-else solver.
    learned (bool) (default: false) collect also learned clauses.
    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    local_search (bool) use local search instead of CDCL (default: false)
    local_search_dbg_flips (bool) write debug information for number of flips (default: false)
    local_search_mode (symbol) local search algorithm, either default wsat or qsat (default: wsat)
    local_search_threads (unsigned int) number of local search threads to find satisfiable solution (default: 0)
    logic (symbol) logic used to setup the SMT solver (default: )
    lookahead.cube.cutoff (symbol) cutoff type used to create lookahead cubes: depth, freevars, psat, adaptive_freevars, adaptive_psat (default: depth)
    lookahead.cube.depth (unsigned int) cut-off depth to create cubes. Used when lookahead.cube.cutoff is depth. (default: 1)
    lookahead.cube.fraction (double) adaptive fraction to create lookahead cubes. Used when lookahead.cube.cutoff is adaptive_freevars or adaptive_psat (default: 0.4)
    lookahead.cube.freevars (double) cube free variable fraction. Used when lookahead.cube.cutoff is freevars (default: 0.8)
    lookahead.cube.psat.clause_base (double) clause base for PSAT cutoff (default: 2)
    lookahead.cube.psat.trigger (double) trigger value to create lookahead cubes for PSAT cutoff. Used when lookahead.cube.cutoff is psat (default: 5)
    lookahead.cube.psat.var_exp (double) free variable exponent for PSAT cutoff (default: 1)
    lookahead.delta_fraction (double) number between 0 and 1, the smaller the more literals are selected for double lookahead (default: 1.0)
    lookahead.double (bool) enable doubld lookahead (default: true)
    lookahead.global_autarky (bool) prefer to branch on variables that occur in clauses that are reduced (default: false)
    lookahead.preselect (bool) use pre-selection of subset of variables for branching (default: false)
    lookahead.reward (symbol) select lookahead heuristic: ternary, heule_schur (Heule Schur), heuleu (Heule Unit), unit, or march_cu (default: march_cu)
    lookahead.use_learned (bool) use learned clauses when selecting lookahead literal (default: false)
    lookahead_scores (bool) extract lookahead scores. A utility that can only be used from the DIMACS front-end (default: false)
    lookahead_simplify (bool) use lookahead solver during simplification (default: false)
    lookahead_simplify.bca (bool) add learned binary clauses as part of lookahead simplification (default: true)
    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)
    max_args (unsigned int) (default: 128) maximum number of arguments (per application) that will be considered by the greedy (quadratic) heuristic.
    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    max_rounds (unsigned int) (default: 4) maximum number of rounds.
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)
    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)
    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )
    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)
    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)
    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)
    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)
    minimize_lemmas (bool) minimize learned clauses (default: true)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    override_incremental (bool) override incremental safety gaps. Enable elimination of blocked clauses and variables even if solver is reused (default: false)
    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)
    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)
    pb.lemma_format (symbol) generate either cardinality or pb lemmas (default: cardinality)
    pb.min_arity (unsigned int) minimal arity to compile pb/cardinality constraints to CNF (default: 9)
    pb.resolve (symbol) resolution strategy for boolean algebra solver: cardinality, rounding (default: cardinality)
    pb.solver (symbol) method for handling Pseudo-Boolean constraints: circuit (arithmetical circuit), sorting (sorting circuit), totalizer (use totalizer encoding), binary_merge, segmented, solver (use native solver) (default: solver)
    phase (symbol) phase selection strategy: always_false, always_true, basic_caching, random, caching (default: caching)
    phase.sticky (bool) use sticky phase caching (default: true)
    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)
    prob_search (bool) use probsat local search instead of CDCL (default: false)
    probing (bool) apply failed literal detection during simplification (default: true)
    probing_binary (bool) probe binary clauses (default: true)
    probing_cache (bool) add binary literals as lemmas (default: true)
    probing_cache_limit (unsigned int) cache binaries unless overall memory usage exceeds cache limit (default: 1024)
    probing_limit (unsigned int) limit to the number of probe calls (default: 5000000)
    propagate.prefetch (bool) prefetch watch lists for assigned literals (default: true)
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    pull_nested_quantifiers (bool) pull nested quantifiers (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))
    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)
    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)
    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)
    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)
    qi.profile (bool) profile quantifier instantiation (default: false)
    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)
    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)
    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)
    random_freq (double) frequency of random case splits (default: 0.01)
    random_seed (unsigned int) random seed for the smt solver (default: 0)
    refine_inj_axioms (bool) refine injectivity axioms (default: true)
    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)
    reorder.activity_scale (unsigned int) scaling factor for activity update (default: 100)
    reorder.base (unsigned int) number of conflicts per random reorder  (default: 4294967295)
    reorder.itau (double) inverse temperature for softmax (default: 4.0)
    rephase.base (unsigned int) number of conflicts per rephase  (default: 1000)
    resolution.cls_cutoff1 (unsigned int) limit1 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 100000000)
    resolution.cls_cutoff2 (unsigned int) limit2 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 700000000)
    resolution.limit (unsigned int) approx. maximum number of literals visited during variable elimination (default: 500000000)
    resolution.lit_cutoff_range1 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 700)
    resolution.lit_cutoff_range2 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 400)
    resolution.lit_cutoff_range3 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 300)
    resolution.occ_cutoff (unsigned int) first cutoff (on number of positive/negative occurrences) for Boolean variable elimination (default: 10)
    resolution.occ_cutoff_range1 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 8)
    resolution.occ_cutoff_range2 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 5)
    resolution.occ_cutoff_range3 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 3)
    restart (symbol) restart strategy: static, luby, ema or geometric (default: ema)
    restart.emafastglue (double) ema alpha factor for fast moving average (default: 0.03)
    restart.emaslowglue (double) ema alpha factor for slow moving average (default: 1e-05)
    restart.factor (double) restart increment factor for geometric strategy (default: 1.5)
    restart.fast (bool) use fast restart approach only removing less active literals. (default: true)
    restart.initial (unsigned int) initial restart (number of conflicts) (default: 2)
    restart.margin (double) margin between fast and slow restart factors. For ema (default: 1.1)
    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)
    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)
    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)
    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)
    retain_blocked_clauses (bool) retain blocked clauses as lemmas (default: true)
    rewrite_patterns (bool) rewrite patterns. (default: false)
    scc (bool) eliminate Boolean variables by computing strongly connected components (default: true)
    scc.tr (bool) apply transitive reduction, eliminate redundant binary clauses (default: true)
    search.sat.conflicts (unsigned int) period for solving for sat (in number of conflicts) (default: 400)
    search.unsat.conflicts (unsigned int) period for solving for unsat (in number of conflicts) (default: 400)
    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)
    seq.use_derivatives (bool) dev flag (not for users) enable derivative based unfolding of regex (default: false)
    seq.use_unicode (bool) dev flag (not for users) enable unicode semantics (default: false)
    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)
    simplify.delay (unsigned int) set initial delay of simplification by a conflict count (default: 0)
    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations.
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)
    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)
    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)
    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)
    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)
    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)
    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)
    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)
    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)
    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)
    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)
    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)
    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)
    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)
    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)
    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)
    subsumption (bool) eliminate subsumed clauses (default: true)
    subsumption.limit (unsigned int) approx. maximum number of literals visited during subsumption (and subsumption resolution) (default: 100000000)
    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)
    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)
    theory_solver (bool) (default: true) use theory solvers.
    threads (unsigned int) maximal number of parallel threads. (default: 1)
    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)
    variable_decay (unsigned int) multiplier (divided by 100) for the VSIDS activity increment (default: 110)
- qfidl builtin strategy for solving QF_IDL problems.
    abce (bool) eliminate blocked clauses using asymmetric literals (default: false)
    acce (bool) eliminate covered clauses using asymmetric added literals (default: false)
    aig_per_assertion (bool) (default: true) process one assertion at a time.
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    anf (bool) enable ANF based simplification in-processing (default: false)
    anf.delay (unsigned int) delay ANF simplification by in-processing round (default: 2)
    anf.exlin (bool) enable extended linear simplification (default: false)
    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)
    arith.bounded_expansion (bool) box variables used in branch and bound into bound assumptions (default: false)
    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)
    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)
    arith.cheap_eqs (unsigned int) 0 - do not run, 1 - use tree, 2 - use table (default: 1)
    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)
    arith.eager_eq_axioms (bool) eager equality axioms (default: true)
    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)
    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)
    arith.ignore_int (bool) treat integer variables as real (default: false)
    arith.int_eq_branch (bool) branching using derived integer equations (default: false)
    arith.min (bool) minimize cost (default: false)
    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.branching (bool) branching on integer variables in non linear clusters, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.expp (bool) expensive patching (default: false)
    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)
    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)
    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)
    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)
    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)
    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)
    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)
    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)
    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.horner (bool) run horner's heuristic (default: true)
    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)
    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)
    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.nra (bool) call nra_solver when incremental lianirization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)
    arith.nl.order (bool) run order lemmas (default: true)
    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)
    arith.nl.tangents (bool) run tangent lemmas (default: true)
    arith.print_ext_var_names (bool) print external variable names (default: false)
    arith.print_stats (bool) print statistic (default: false)
    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)
    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine bounds (default: 2)
    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)
    arith.reflect (bool) reflect arithmetical operators to the congruence closure (default: true)
    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)
    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)
    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    array.extensional (bool) extensional array theory (default: true)
    array.weak (bool) weak array theory (default: false)
    asymm_branch (bool) asymmetric branching (default: true)
    asymm_branch.all (bool) asymmetric branching on all literals per clause (default: false)
    asymm_branch.delay (unsigned int) number of simplification rounds to wait until invoking asymmetric branch simplification (default: 1)
    asymm_branch.limit (unsigned int) approx. maximum number of literals visited during asymmetric branching (default: 100000000)
    asymm_branch.rounds (unsigned int) maximal number of rounds to run asymmetric branch simplifications if progress is made (default: 2)
    asymm_branch.sampled (bool) use sampling based asymmetric branching based on binary implication graph (default: true)
    ate (bool) asymmetric tautology elimination (default: true)
    auto_config (bool) automatically configure solver (default: true)
    backtrack.conflicts (unsigned int) number of conflicts before enabling chronological backtracking (default: 4000)
    backtrack.scopes (unsigned int) number of scopes to enable chronological backtracking (default: 100)
    bca (bool) blocked clause addition - add blocked binary clauses (default: false)
    bce (bool) eliminate blocked clauses (default: false)
    bce_at (unsigned int) eliminate blocked clauses only once at the given simplification round (default: 2)
    bce_delay (unsigned int) delay eliminate blocked clauses until simplification round (default: 2)
    binspr (bool) enable SPR inferences of binary propagation redundant clauses. This inprocessing step eliminates models (default: false)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_add (bool) (default: true) bit-blast adders.
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    blast_full (bool) (default: false) bit-blast any term with bit-vector sort, this option will make E-matching ineffective in any pattern containing bit-vector terms.
    blast_mul (bool) (default: true) bit-blast multipliers (and dividers, remainders).
    blast_quant (bool) (default: false) bit-blast quantified variables.
    blocked_clause_limit (unsigned int) maximum number of literals visited during blocked clause elimination (default: 100000000)
    branching.anti_exploration (bool) apply anti-exploration heuristic for branch selection (default: false)
    branching.heuristic (symbol) branching heuristic vsids, chb (default: vsids)
    burst_search (unsigned int) number of conflicts before first global simplification (default: 100)
    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)
    bv.reflect (bool) create enode for every bit-vector term (default: true)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    candidate_models (bool) (default: false) create candidate models even when quantifier or theory reasoning is incomplete.
    cardinality.encoding (symbol) encoding used for at-most-k constraints: grouped, bimander, ordered, unate, circuit (default: grouped)
    cardinality.solver (bool) use cardinality solver (default: true)
    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)
    cce (bool) eliminate covered clauses (default: false)
    clause_proof (bool) record a clausal proof (default: false)
    context_solve (bool) (default: false) solve equalities under disjunctions.
    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)
    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)
    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)
    core.minimize (bool) minimize computed core (default: false)
    core.minimize_partial (bool) apply partial (cheap) core minimization (default: false)
    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)
    cut (bool) enable AIG based simplification in-processing (default: false)
    cut.aig (bool) extract aigs (and ites) from cluases for cut simplification (default: false)
    cut.delay (unsigned int) delay cut simplification by in-processing round (default: 2)
    cut.dont_cares (bool) integrate dont cares with cuts (default: true)
    cut.force (bool) force redoing cut-enumeration until a fixed-point (default: false)
    cut.lut (bool) extract luts from clauses for cut simplification (default: false)
    cut.npn3 (bool) extract 3 input functions from clauses for cut simplification (default: false)
    cut.redundancies (bool) integrate redundancy checking of cuts (default: true)
    cut.xor (bool) extract xors from clauses for cut simplification (default: false)
    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)
    dack.eq (bool) enable dynamic ackermannization for transtivity of equalities (default: false)
    dack.factor (double) number of instance per conflict (default: 0.1)
    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)
    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)
    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)
    ddfw.init_clause_weight (unsigned int) initial clause weight for DDFW local search (default: 8)
    ddfw.reinit_base (unsigned int) increment basis for geometric backoff scheme of re-initialization of weights (default: 10000)
    ddfw.restart_base (unsigned int) number of flips used a starting point for hessitant restart backoff (default: 100000)
    ddfw.threads (unsigned int) number of ddfw threads to run in parallel with sat solver (default: 0)
    ddfw.use_reward_pct (unsigned int) percentage to pick highest reward variable when it has reward 0 (default: 15)
    ddfw_search (bool) use ddfw local search instead of CDCL (default: false)
    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)
    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)
    diff_neq_max_k (unsigned int) (default: 1024) maximum variable upper bound for diff neq solver.
    dimacs.core (bool) extract core from DIMACS benchmarks (default: false)
    drat.activity (bool) dump variable activities (default: false)
    drat.binary (bool) use Binary DRAT output format (default: false)
    drat.check_sat (bool) build up internal trace, check satisfying model (default: false)
    drat.check_unsat (bool) build up internal proof and check (default: false)
    drat.file (symbol) file to dump DRAT proofs (default: )
    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)
    dyn_sub_res (bool) dynamic subsumption resolution for minimizing learned clauses (default: true)
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    elim_vars (bool) enable variable elimination using resolution during simplification (default: true)
    elim_vars_bdd (bool) enable variable elimination using BDD recompilation during simplification (default: true)
    elim_vars_bdd_delay (unsigned int) delay elimination of variables using BDDs until after simplification round (default: 3)
    ematching (bool) E-Matching based quantifier instantiation (default: true)
    enable_pre_simplify (bool) enable pre simplifications before the bounded search (default: false)
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    force_cleanup (bool) force cleanup to remove tautologies and simplify clauses (default: false)
    gc (symbol) garbage collection strategy: psm, glue, glue_psm, dyn_psm (default: glue_psm)
    gc.burst (bool) perform eager garbage collection during initialization (default: false)
    gc.defrag (bool) defragment clauses when garbage collecting (default: true)
    gc.increment (unsigned int) increment to the garbage collection threshold (default: 500)
    gc.initial (unsigned int) learned clauses garbage collection frequency (default: 20000)
    gc.k (unsigned int) learned clauses that are inactive for k gc rounds are permanently deleted (only used in dyn_psm) (default: 7)
    gc.small_lbd (unsigned int) learned clauses with small LBD are never deleted (only used in dyn_psm) (default: 3)
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    induction (bool) enable generation of induction lemmas (default: false)
    inprocess.max (unsigned int) maximal number of inprocessing passes (default: 4294967295)
    inprocess.out (symbol) file to dump result of the first inprocessing step and exit (default: )
    ite_extra (bool) (default: true) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    ite_solver (bool) (default: true) use if-then-else solver.
    learned (bool) (default: false) collect also learned clauses.
    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)
    lia2pb_max_bits (unsigned int) (default: 32) maximum number of bits to be used (per variable) in lia2pb.
    lia2pb_partial (bool) (default: false) partial lia2pb conversion.
    lia2pb_total_bits (unsigned int) (default: 2048) total number of bits to be used (per problem) in lia2pb.
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    local_search (bool) use local search instead of CDCL (default: false)
    local_search_dbg_flips (bool) write debug information for number of flips (default: false)
    local_search_mode (symbol) local search algorithm, either default wsat or qsat (default: wsat)
    local_search_threads (unsigned int) number of local search threads to find satisfiable solution (default: 0)
    logic (symbol) logic used to setup the SMT solver (default: )
    lookahead.cube.cutoff (symbol) cutoff type used to create lookahead cubes: depth, freevars, psat, adaptive_freevars, adaptive_psat (default: depth)
    lookahead.cube.depth (unsigned int) cut-off depth to create cubes. Used when lookahead.cube.cutoff is depth. (default: 1)
    lookahead.cube.fraction (double) adaptive fraction to create lookahead cubes. Used when lookahead.cube.cutoff is adaptive_freevars or adaptive_psat (default: 0.4)
    lookahead.cube.freevars (double) cube free variable fraction. Used when lookahead.cube.cutoff is freevars (default: 0.8)
    lookahead.cube.psat.clause_base (double) clause base for PSAT cutoff (default: 2)
    lookahead.cube.psat.trigger (double) trigger value to create lookahead cubes for PSAT cutoff. Used when lookahead.cube.cutoff is psat (default: 5)
    lookahead.cube.psat.var_exp (double) free variable exponent for PSAT cutoff (default: 1)
    lookahead.delta_fraction (double) number between 0 and 1, the smaller the more literals are selected for double lookahead (default: 1.0)
    lookahead.double (bool) enable doubld lookahead (default: true)
    lookahead.global_autarky (bool) prefer to branch on variables that occur in clauses that are reduced (default: false)
    lookahead.preselect (bool) use pre-selection of subset of variables for branching (default: false)
    lookahead.reward (symbol) select lookahead heuristic: ternary, heule_schur (Heule Schur), heuleu (Heule Unit), unit, or march_cu (default: march_cu)
    lookahead.use_learned (bool) use learned clauses when selecting lookahead literal (default: false)
    lookahead_scores (bool) extract lookahead scores. A utility that can only be used from the DIMACS front-end (default: false)
    lookahead_simplify (bool) use lookahead solver during simplification (default: false)
    lookahead_simplify.bca (bool) add learned binary clauses as part of lookahead simplification (default: true)
    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)
    max_args (unsigned int) (default: 128) maximum number of arguments (per application) that will be considered by the greedy (quadratic) heuristic.
    max_conflicts (unsigned int) maximum number of conflicts (default: 4294967295)
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    max_rounds (unsigned int) (default: 4) maximum number of rounds.
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)
    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)
    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )
    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)
    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)
    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)
    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)
    minimize_lemmas (bool) minimize learned clauses (default: true)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    norm_int_only (bool) (default: true) normalize only the bounds of integer constants.
    override_incremental (bool) override incremental safety gaps. Enable elimination of blocked clauses and variables even if solver is reused (default: false)
    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)
    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)
    pb.lemma_format (symbol) generate either cardinality or pb lemmas (default: cardinality)
    pb.min_arity (unsigned int) minimal arity to compile pb/cardinality constraints to CNF (default: 9)
    pb.resolve (symbol) resolution strategy for boolean algebra solver: cardinality, rounding (default: cardinality)
    pb.solver (symbol) method for handling Pseudo-Boolean constraints: circuit (arithmetical circuit), sorting (sorting circuit), totalizer (use totalizer encoding), binary_merge, segmented, solver (use native solver) (default: solver)
    pb2bv_all_clauses_limit (unsigned int) (default: 8) maximum number of literals for using equivalent CNF encoding of PB constraint.
    pb2bv_cardinality_limit (unsigned int) (default: inf) limit for using arc-consistent cardinality constraint encoding.
    phase (symbol) phase selection strategy: always_false, always_true, basic_caching, random, caching (default: caching)
    phase.sticky (bool) use sticky phase caching (default: true)
    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)
    prob_search (bool) use probsat local search instead of CDCL (default: false)
    probing (bool) apply failed literal detection during simplification (default: true)
    probing_binary (bool) probe binary clauses (default: true)
    probing_cache (bool) add binary literals as lemmas (default: true)
    probing_cache_limit (unsigned int) cache binaries unless overall memory usage exceeds cache limit (default: 1024)
    probing_limit (unsigned int) limit to the number of probe calls (default: 5000000)
    produce_models (bool) (default: false) model generation.
    propagate.prefetch (bool) prefetch watch lists for assigned literals (default: true)
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    pull_nested_quantifiers (bool) pull nested quantifiers (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))
    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)
    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)
    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)
    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)
    qi.profile (bool) profile quantifier instantiation (default: false)
    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)
    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)
    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)
    random_freq (double) frequency of random case splits (default: 0.01)
    random_seed (unsigned int) random seed (default: 0)
    refine_inj_axioms (bool) refine injectivity axioms (default: true)
    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)
    reorder.activity_scale (unsigned int) scaling factor for activity update (default: 100)
    reorder.base (unsigned int) number of conflicts per random reorder  (default: 4294967295)
    reorder.itau (double) inverse temperature for softmax (default: 4.0)
    rephase.base (unsigned int) number of conflicts per rephase  (default: 1000)
    resolution.cls_cutoff1 (unsigned int) limit1 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 100000000)
    resolution.cls_cutoff2 (unsigned int) limit2 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 700000000)
    resolution.limit (unsigned int) approx. maximum number of literals visited during variable elimination (default: 500000000)
    resolution.lit_cutoff_range1 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 700)
    resolution.lit_cutoff_range2 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 400)
    resolution.lit_cutoff_range3 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 300)
    resolution.occ_cutoff (unsigned int) first cutoff (on number of positive/negative occurrences) for Boolean variable elimination (default: 10)
    resolution.occ_cutoff_range1 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 8)
    resolution.occ_cutoff_range2 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 5)
    resolution.occ_cutoff_range3 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 3)
    restart (symbol) restart strategy: static, luby, ema or geometric (default: ema)
    restart.emafastglue (double) ema alpha factor for fast moving average (default: 0.03)
    restart.emaslowglue (double) ema alpha factor for slow moving average (default: 1e-05)
    restart.factor (double) restart increment factor for geometric strategy (default: 1.5)
    restart.fast (bool) use fast restart approach only removing less active literals. (default: true)
    restart.initial (unsigned int) initial restart (number of conflicts) (default: 2)
    restart.margin (double) margin between fast and slow restart factors. For ema (default: 1.1)
    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)
    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)
    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)
    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)
    retain_blocked_clauses (bool) retain blocked clauses as lemmas (default: true)
    rewrite_patterns (bool) rewrite patterns. (default: false)
    scc (bool) eliminate Boolean variables by computing strongly connected components (default: true)
    scc.tr (bool) apply transitive reduction, eliminate redundant binary clauses (default: true)
    search.sat.conflicts (unsigned int) period for solving for sat (in number of conflicts) (default: 400)
    search.unsat.conflicts (unsigned int) period for solving for unsat (in number of conflicts) (default: 400)
    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)
    seq.use_derivatives (bool) dev flag (not for users) enable derivative based unfolding of regex (default: false)
    seq.use_unicode (bool) dev flag (not for users) enable unicode semantics (default: false)
    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)
    simplify.delay (unsigned int) set initial delay of simplification by a conflict count (default: 0)
    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations.
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)
    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)
    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)
    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)
    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)
    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)
    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)
    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)
    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)
    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)
    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)
    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)
    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)
    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)
    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)
    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)
    subsumption (bool) eliminate subsumed clauses (default: true)
    subsumption.limit (unsigned int) approx. maximum number of literals visited during subsumption (and subsumption resolution) (default: 100000000)
    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)
    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)
    theory_solver (bool) (default: true) use theory solvers.
    threads (unsigned int) number of parallel threads to use (default: 1)
    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)
    variable_decay (unsigned int) multiplier (divided by 100) for the VSIDS activity increment (default: 110)
- qflia builtin strategy for solving QF_LIA problems.
    abce (bool) eliminate blocked clauses using asymmetric literals (default: false)
    acce (bool) eliminate covered clauses using asymmetric added literals (default: false)
    add_bound_lower (rational) (default: -2) lower bound to be added to unbounded variables.
    add_bound_upper (rational) (default: 2) upper bound to be added to unbounded variables.
    aig_per_assertion (bool) (default: true) process one assertion at a time.
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    anf (bool) enable ANF based simplification in-processing (default: false)
    anf.delay (unsigned int) delay ANF simplification by in-processing round (default: 2)
    anf.exlin (bool) enable extended linear simplification (default: false)
    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)
    arith.bounded_expansion (bool) box variables used in branch and bound into bound assumptions (default: false)
    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)
    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)
    arith.cheap_eqs (unsigned int) 0 - do not run, 1 - use tree, 2 - use table (default: 1)
    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)
    arith.eager_eq_axioms (bool) eager equality axioms (default: true)
    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)
    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)
    arith.ignore_int (bool) treat integer variables as real (default: false)
    arith.int_eq_branch (bool) branching using derived integer equations (default: false)
    arith.min (bool) minimize cost (default: false)
    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.branching (bool) branching on integer variables in non linear clusters, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.expp (bool) expensive patching (default: false)
    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)
    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)
    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)
    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)
    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)
    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)
    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)
    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)
    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.horner (bool) run horner's heuristic (default: true)
    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)
    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)
    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.nra (bool) call nra_solver when incremental lianirization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)
    arith.nl.order (bool) run order lemmas (default: true)
    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)
    arith.nl.tangents (bool) run tangent lemmas (default: true)
    arith.print_ext_var_names (bool) print external variable names (default: false)
    arith.print_stats (bool) print statistic (default: false)
    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)
    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine bounds (default: 2)
    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)
    arith.reflect (bool) reflect arithmetical operators to the congruence closure (default: true)
    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)
    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)
    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    array.extensional (bool) extensional array theory (default: true)
    array.weak (bool) weak array theory (default: false)
    asymm_branch (bool) asymmetric branching (default: true)
    asymm_branch.all (bool) asymmetric branching on all literals per clause (default: false)
    asymm_branch.delay (unsigned int) number of simplification rounds to wait until invoking asymmetric branch simplification (default: 1)
    asymm_branch.limit (unsigned int) approx. maximum number of literals visited during asymmetric branching (default: 100000000)
    asymm_branch.rounds (unsigned int) maximal number of rounds to run asymmetric branch simplifications if progress is made (default: 2)
    asymm_branch.sampled (bool) use sampling based asymmetric branching based on binary implication graph (default: true)
    ate (bool) asymmetric tautology elimination (default: true)
    auto_config (bool) automatically configure solver (default: true)
    backtrack.conflicts (unsigned int) number of conflicts before enabling chronological backtracking (default: 4000)
    backtrack.scopes (unsigned int) number of scopes to enable chronological backtracking (default: 100)
    bca (bool) blocked clause addition - add blocked binary clauses (default: false)
    bce (bool) eliminate blocked clauses (default: false)
    bce_at (unsigned int) eliminate blocked clauses only once at the given simplification round (default: 2)
    bce_delay (unsigned int) delay eliminate blocked clauses until simplification round (default: 2)
    binspr (bool) enable SPR inferences of binary propagation redundant clauses. This inprocessing step eliminates models (default: false)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_add (bool) (default: true) bit-blast adders.
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    blast_full (bool) (default: false) bit-blast any term with bit-vector sort, this option will make E-matching ineffective in any pattern containing bit-vector terms.
    blast_mul (bool) (default: true) bit-blast multipliers (and dividers, remainders).
    blast_quant (bool) (default: false) bit-blast quantified variables.
    blocked_clause_limit (unsigned int) maximum number of literals visited during blocked clause elimination (default: 100000000)
    branching.anti_exploration (bool) apply anti-exploration heuristic for branch selection (default: false)
    branching.heuristic (symbol) branching heuristic vsids, chb (default: vsids)
    burst_search (unsigned int) number of conflicts before first global simplification (default: 100)
    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)
    bv.reflect (bool) create enode for every bit-vector term (default: true)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    candidate_models (bool) (default: false) create candidate models even when quantifier or theory reasoning is incomplete.
    cardinality.encoding (symbol) encoding used for at-most-k constraints: grouped, bimander, ordered, unate, circuit (default: grouped)
    cardinality.solver (bool) use cardinality solver (default: true)
    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)
    cce (bool) eliminate covered clauses (default: false)
    clause_proof (bool) record a clausal proof (default: false)
    context_solve (bool) (default: false) solve equalities under disjunctions.
    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)
    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)
    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)
    core.minimize (bool) minimize unsat core produced by SMT context (default: false)
    core.minimize_partial (bool) apply partial (cheap) core minimization (default: false)
    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)
    cut (bool) enable AIG based simplification in-processing (default: false)
    cut.aig (bool) extract aigs (and ites) from cluases for cut simplification (default: false)
    cut.delay (unsigned int) delay cut simplification by in-processing round (default: 2)
    cut.dont_cares (bool) integrate dont cares with cuts (default: true)
    cut.force (bool) force redoing cut-enumeration until a fixed-point (default: false)
    cut.lut (bool) extract luts from clauses for cut simplification (default: false)
    cut.npn3 (bool) extract 3 input functions from clauses for cut simplification (default: false)
    cut.redundancies (bool) integrate redundancy checking of cuts (default: true)
    cut.xor (bool) extract xors from clauses for cut simplification (default: false)
    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)
    dack.eq (bool) enable dynamic ackermannization for transtivity of equalities (default: false)
    dack.factor (double) number of instance per conflict (default: 0.1)
    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)
    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)
    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)
    ddfw.init_clause_weight (unsigned int) initial clause weight for DDFW local search (default: 8)
    ddfw.reinit_base (unsigned int) increment basis for geometric backoff scheme of re-initialization of weights (default: 10000)
    ddfw.restart_base (unsigned int) number of flips used a starting point for hessitant restart backoff (default: 100000)
    ddfw.threads (unsigned int) number of ddfw threads to run in parallel with sat solver (default: 0)
    ddfw.use_reward_pct (unsigned int) percentage to pick highest reward variable when it has reward 0 (default: 15)
    ddfw_search (bool) use ddfw local search instead of CDCL (default: false)
    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)
    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)
    dimacs.core (bool) extract core from DIMACS benchmarks (default: false)
    drat.activity (bool) dump variable activities (default: false)
    drat.binary (bool) use Binary DRAT output format (default: false)
    drat.check_sat (bool) build up internal trace, check satisfying model (default: false)
    drat.check_unsat (bool) build up internal proof and check (default: false)
    drat.file (symbol) file to dump DRAT proofs (default: )
    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)
    dyn_sub_res (bool) dynamic subsumption resolution for minimizing learned clauses (default: true)
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    elim_vars (bool) enable variable elimination using resolution during simplification (default: true)
    elim_vars_bdd (bool) enable variable elimination using BDD recompilation during simplification (default: true)
    elim_vars_bdd_delay (unsigned int) delay elimination of variables using BDDs until after simplification round (default: 3)
    ematching (bool) E-Matching based quantifier instantiation (default: true)
    enable_pre_simplify (bool) enable pre simplifications before the bounded search (default: false)
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    force_cleanup (bool) force cleanup to remove tautologies and simplify clauses (default: false)
    gc (symbol) garbage collection strategy: psm, glue, glue_psm, dyn_psm (default: glue_psm)
    gc.burst (bool) perform eager garbage collection during initialization (default: false)
    gc.defrag (bool) defragment clauses when garbage collecting (default: true)
    gc.increment (unsigned int) increment to the garbage collection threshold (default: 500)
    gc.initial (unsigned int) learned clauses garbage collection frequency (default: 20000)
    gc.k (unsigned int) learned clauses that are inactive for k gc rounds are permanently deleted (only used in dyn_psm) (default: 7)
    gc.small_lbd (unsigned int) learned clauses with small LBD are never deleted (only used in dyn_psm) (default: 3)
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    induction (bool) enable generation of induction lemmas (default: false)
    inprocess.max (unsigned int) maximal number of inprocessing passes (default: 4294967295)
    inprocess.out (symbol) file to dump result of the first inprocessing step and exit (default: )
    ite_extra (bool) (default: true) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    ite_solver (bool) (default: true) use if-then-else solver.
    learned (bool) (default: false) collect also learned clauses.
    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)
    lia2pb_max_bits (unsigned int) (default: 32) maximum number of bits to be used (per variable) in lia2pb.
    lia2pb_partial (bool) (default: false) partial lia2pb conversion.
    lia2pb_total_bits (unsigned int) (default: 2048) total number of bits to be used (per problem) in lia2pb.
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    local_search (bool) use local search instead of CDCL (default: false)
    local_search_dbg_flips (bool) write debug information for number of flips (default: false)
    local_search_mode (symbol) local search algorithm, either default wsat or qsat (default: wsat)
    local_search_threads (unsigned int) number of local search threads to find satisfiable solution (default: 0)
    logic (symbol) logic used to setup the SMT solver (default: )
    lookahead.cube.cutoff (symbol) cutoff type used to create lookahead cubes: depth, freevars, psat, adaptive_freevars, adaptive_psat (default: depth)
    lookahead.cube.depth (unsigned int) cut-off depth to create cubes. Used when lookahead.cube.cutoff is depth. (default: 1)
    lookahead.cube.fraction (double) adaptive fraction to create lookahead cubes. Used when lookahead.cube.cutoff is adaptive_freevars or adaptive_psat (default: 0.4)
    lookahead.cube.freevars (double) cube free variable fraction. Used when lookahead.cube.cutoff is freevars (default: 0.8)
    lookahead.cube.psat.clause_base (double) clause base for PSAT cutoff (default: 2)
    lookahead.cube.psat.trigger (double) trigger value to create lookahead cubes for PSAT cutoff. Used when lookahead.cube.cutoff is psat (default: 5)
    lookahead.cube.psat.var_exp (double) free variable exponent for PSAT cutoff (default: 1)
    lookahead.delta_fraction (double) number between 0 and 1, the smaller the more literals are selected for double lookahead (default: 1.0)
    lookahead.double (bool) enable doubld lookahead (default: true)
    lookahead.global_autarky (bool) prefer to branch on variables that occur in clauses that are reduced (default: false)
    lookahead.preselect (bool) use pre-selection of subset of variables for branching (default: false)
    lookahead.reward (symbol) select lookahead heuristic: ternary, heule_schur (Heule Schur), heuleu (Heule Unit), unit, or march_cu (default: march_cu)
    lookahead.use_learned (bool) use learned clauses when selecting lookahead literal (default: false)
    lookahead_scores (bool) extract lookahead scores. A utility that can only be used from the DIMACS front-end (default: false)
    lookahead_simplify (bool) use lookahead solver during simplification (default: false)
    lookahead_simplify.bca (bool) add learned binary clauses as part of lookahead simplification (default: true)
    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)
    max_args (unsigned int) (default: 128) maximum number of arguments (per application) that will be considered by the greedy (quadratic) heuristic.
    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_depth (unsigned int) (default: 1024) maximum term depth.
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    max_rounds (unsigned int) (default: 4) maximum number of rounds.
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)
    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)
    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )
    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)
    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)
    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)
    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)
    minimize_lemmas (bool) minimize learned clauses (default: true)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    norm_int_only (bool) (default: true) normalize only the bounds of integer constants.
    override_incremental (bool) override incremental safety gaps. Enable elimination of blocked clauses and variables even if solver is reused (default: false)
    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)
    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)
    pb.lemma_format (symbol) generate either cardinality or pb lemmas (default: cardinality)
    pb.min_arity (unsigned int) minimal arity to compile pb/cardinality constraints to CNF (default: 9)
    pb.resolve (symbol) resolution strategy for boolean algebra solver: cardinality, rounding (default: cardinality)
    pb.solver (symbol) method for handling Pseudo-Boolean constraints: circuit (arithmetical circuit), sorting (sorting circuit), totalizer (use totalizer encoding), binary_merge, segmented, solver (use native solver) (default: solver)
    pb2bv_all_clauses_limit (unsigned int) (default: 8) maximum number of literals for using equivalent CNF encoding of PB constraint.
    pb2bv_cardinality_limit (unsigned int) (default: inf) limit for using arc-consistent cardinality constraint encoding.
    phase (symbol) phase selection strategy: always_false, always_true, basic_caching, random, caching (default: caching)
    phase.sticky (bool) use sticky phase caching (default: true)
    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)
    prob_search (bool) use probsat local search instead of CDCL (default: false)
    probing (bool) apply failed literal detection during simplification (default: true)
    probing_binary (bool) probe binary clauses (default: true)
    probing_cache (bool) add binary literals as lemmas (default: true)
    probing_cache_limit (unsigned int) cache binaries unless overall memory usage exceeds cache limit (default: 1024)
    probing_limit (unsigned int) limit to the number of probe calls (default: 5000000)
    produce_models (bool) (default: false) model generation.
    propagate.prefetch (bool) prefetch watch lists for assigned literals (default: true)
    propagate_eq (bool) (default: false) enable equality propagation from bounds.
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    pull_nested_quantifiers (bool) pull nested quantifiers (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))
    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)
    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)
    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)
    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)
    qi.profile (bool) profile quantifier instantiation (default: false)
    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)
    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)
    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)
    random_freq (double) frequency of random case splits (default: 0.01)
    random_seed (unsigned int) random seed for the smt solver (default: 0)
    refine_inj_axioms (bool) refine injectivity axioms (default: true)
    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)
    reorder.activity_scale (unsigned int) scaling factor for activity update (default: 100)
    reorder.base (unsigned int) number of conflicts per random reorder  (default: 4294967295)
    reorder.itau (double) inverse temperature for softmax (default: 4.0)
    rephase.base (unsigned int) number of conflicts per rephase  (default: 1000)
    resolution.cls_cutoff1 (unsigned int) limit1 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 100000000)
    resolution.cls_cutoff2 (unsigned int) limit2 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 700000000)
    resolution.limit (unsigned int) approx. maximum number of literals visited during variable elimination (default: 500000000)
    resolution.lit_cutoff_range1 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 700)
    resolution.lit_cutoff_range2 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 400)
    resolution.lit_cutoff_range3 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 300)
    resolution.occ_cutoff (unsigned int) first cutoff (on number of positive/negative occurrences) for Boolean variable elimination (default: 10)
    resolution.occ_cutoff_range1 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 8)
    resolution.occ_cutoff_range2 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 5)
    resolution.occ_cutoff_range3 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 3)
    restart (symbol) restart strategy: static, luby, ema or geometric (default: ema)
    restart.emafastglue (double) ema alpha factor for fast moving average (default: 0.03)
    restart.emaslowglue (double) ema alpha factor for slow moving average (default: 1e-05)
    restart.factor (double) restart increment factor for geometric strategy (default: 1.5)
    restart.fast (bool) use fast restart approach only removing less active literals. (default: true)
    restart.initial (unsigned int) initial restart (number of conflicts) (default: 2)
    restart.margin (double) margin between fast and slow restart factors. For ema (default: 1.1)
    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)
    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)
    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)
    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)
    retain_blocked_clauses (bool) retain blocked clauses as lemmas (default: true)
    rewrite_patterns (bool) rewrite patterns. (default: false)
    scc (bool) eliminate Boolean variables by computing strongly connected components (default: true)
    scc.tr (bool) apply transitive reduction, eliminate redundant binary clauses (default: true)
    search.sat.conflicts (unsigned int) period for solving for sat (in number of conflicts) (default: 400)
    search.unsat.conflicts (unsigned int) period for solving for unsat (in number of conflicts) (default: 400)
    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)
    seq.use_derivatives (bool) dev flag (not for users) enable derivative based unfolding of regex (default: false)
    seq.use_unicode (bool) dev flag (not for users) enable unicode semantics (default: false)
    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)
    simplify.delay (unsigned int) set initial delay of simplification by a conflict count (default: 0)
    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations.
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)
    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)
    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)
    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)
    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)
    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)
    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)
    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)
    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)
    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)
    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)
    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)
    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)
    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)
    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)
    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)
    subsumption (bool) eliminate subsumed clauses (default: true)
    subsumption.limit (unsigned int) approx. maximum number of literals visited during subsumption (and subsumption resolution) (default: 100000000)
    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)
    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)
    theory_solver (bool) (default: true) use theory solvers.
    threads (unsigned int) maximal number of parallel threads. (default: 1)
    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)
    variable_decay (unsigned int) multiplier (divided by 100) for the VSIDS activity increment (default: 110)
- qflra builtin strategy for solving QF_LRA problems.
    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)
    arith.bounded_expansion (bool) box variables used in branch and bound into bound assumptions (default: false)
    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)
    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)
    arith.cheap_eqs (unsigned int) 0 - do not run, 1 - use tree, 2 - use table (default: 1)
    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)
    arith.eager_eq_axioms (bool) eager equality axioms (default: true)
    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)
    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)
    arith.ignore_int (bool) treat integer variables as real (default: false)
    arith.int_eq_branch (bool) branching using derived integer equations (default: false)
    arith.min (bool) minimize cost (default: false)
    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.branching (bool) branching on integer variables in non linear clusters, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.expp (bool) expensive patching (default: false)
    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)
    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)
    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)
    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)
    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)
    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)
    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)
    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)
    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.horner (bool) run horner's heuristic (default: true)
    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)
    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)
    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.nra (bool) call nra_solver when incremental lianirization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)
    arith.nl.order (bool) run order lemmas (default: true)
    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)
    arith.nl.tangents (bool) run tangent lemmas (default: true)
    arith.print_ext_var_names (bool) print external variable names (default: false)
    arith.print_stats (bool) print statistic (default: false)
    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)
    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine bounds (default: 2)
    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)
    arith.reflect (bool) reflect arithmetical operators to the congruence closure (default: true)
    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)
    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)
    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)
    array.extensional (bool) extensional array theory (default: true)
    array.weak (bool) weak array theory (default: false)
    auto_config (bool) automatically configure solver (default: true)
    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)
    bv.reflect (bool) create enode for every bit-vector term (default: true)
    candidate_models (bool) (default: false) create candidate models even when quantifier or theory reasoning is incomplete.
    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)
    clause_proof (bool) record a clausal proof (default: false)
    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)
    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)
    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)
    core.minimize (bool) minimize unsat core produced by SMT context (default: false)
    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)
    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)
    dack.eq (bool) enable dynamic ackermannization for transtivity of equalities (default: false)
    dack.factor (double) number of instance per conflict (default: 0.1)
    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)
    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)
    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)
    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)
    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)
    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)
    ematching (bool) E-Matching based quantifier instantiation (default: true)
    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.
    induction (bool) enable generation of induction lemmas (default: false)
    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)
    logic (symbol) logic used to setup the SMT solver (default: )
    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)
    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)
    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)
    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)
    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )
    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)
    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)
    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)
    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)
    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)
    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)
    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)
    pull_nested_quantifiers (bool) pull nested quantifiers (default: false)
    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))
    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)
    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)
    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)
    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)
    qi.profile (bool) profile quantifier instantiation (default: false)
    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)
    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)
    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)
    random_seed (unsigned int) random seed for the smt solver (default: 0)
    refine_inj_axioms (bool) refine injectivity axioms (default: true)
    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)
    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)
    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)
    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)
    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)
    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)
    seq.use_derivatives (bool) dev flag (not for users) enable derivative based unfolding of regex (default: false)
    seq.use_unicode (bool) dev flag (not for users) enable unicode semantics (default: false)
    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)
    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)
    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)
    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)
    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)
    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)
    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)
    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)
    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)
    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)
    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)
    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)
    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)
    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)
    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)
    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)
    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)
    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)
    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)
    threads (unsigned int) maximal number of parallel threads. (default: 1)
    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)
- qfnia builtin strategy for solving QF_NIA problems.
    abce (bool) eliminate blocked clauses using asymmetric literals (default: false)
    acce (bool) eliminate covered clauses using asymmetric added literals (default: false)
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    anf (bool) enable ANF based simplification in-processing (default: false)
    anf.delay (unsigned int) delay ANF simplification by in-processing round (default: 2)
    anf.exlin (bool) enable extended linear simplification (default: false)
    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)
    arith.bounded_expansion (bool) box variables used in branch and bound into bound assumptions (default: false)
    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)
    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)
    arith.cheap_eqs (unsigned int) 0 - do not run, 1 - use tree, 2 - use table (default: 1)
    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)
    arith.eager_eq_axioms (bool) eager equality axioms (default: true)
    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)
    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)
    arith.ignore_int (bool) treat integer variables as real (default: false)
    arith.int_eq_branch (bool) branching using derived integer equations (default: false)
    arith.min (bool) minimize cost (default: false)
    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.branching (bool) branching on integer variables in non linear clusters, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.expp (bool) expensive patching (default: false)
    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)
    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)
    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)
    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)
    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)
    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)
    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)
    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)
    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.horner (bool) run horner's heuristic (default: true)
    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)
    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)
    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.nra (bool) call nra_solver when incremental lianirization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)
    arith.nl.order (bool) run order lemmas (default: true)
    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)
    arith.nl.tangents (bool) run tangent lemmas (default: true)
    arith.print_ext_var_names (bool) print external variable names (default: false)
    arith.print_stats (bool) print statistic (default: false)
    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)
    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine bounds (default: 2)
    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)
    arith.reflect (bool) reflect arithmetical operators to the congruence closure (default: true)
    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)
    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)
    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    array.extensional (bool) extensional array theory (default: true)
    array.weak (bool) weak array theory (default: false)
    asymm_branch (bool) asymmetric branching (default: true)
    asymm_branch.all (bool) asymmetric branching on all literals per clause (default: false)
    asymm_branch.delay (unsigned int) number of simplification rounds to wait until invoking asymmetric branch simplification (default: 1)
    asymm_branch.limit (unsigned int) approx. maximum number of literals visited during asymmetric branching (default: 100000000)
    asymm_branch.rounds (unsigned int) maximal number of rounds to run asymmetric branch simplifications if progress is made (default: 2)
    asymm_branch.sampled (bool) use sampling based asymmetric branching based on binary implication graph (default: true)
    ate (bool) asymmetric tautology elimination (default: true)
    auto_config (bool) automatically configure solver (default: true)
    backtrack.conflicts (unsigned int) number of conflicts before enabling chronological backtracking (default: 4000)
    backtrack.scopes (unsigned int) number of scopes to enable chronological backtracking (default: 100)
    bca (bool) blocked clause addition - add blocked binary clauses (default: false)
    bce (bool) eliminate blocked clauses (default: false)
    bce_at (unsigned int) eliminate blocked clauses only once at the given simplification round (default: 2)
    bce_delay (unsigned int) delay eliminate blocked clauses until simplification round (default: 2)
    binspr (bool) enable SPR inferences of binary propagation redundant clauses. This inprocessing step eliminates models (default: false)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_add (bool) (default: true) bit-blast adders.
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    blast_full (bool) (default: false) bit-blast any term with bit-vector sort, this option will make E-matching ineffective in any pattern containing bit-vector terms.
    blast_mul (bool) (default: true) bit-blast multipliers (and dividers, remainders).
    blast_quant (bool) (default: false) bit-blast quantified variables.
    blocked_clause_limit (unsigned int) maximum number of literals visited during blocked clause elimination (default: 100000000)
    branching.anti_exploration (bool) apply anti-exploration heuristic for branch selection (default: false)
    branching.heuristic (symbol) branching heuristic vsids, chb (default: vsids)
    burst_search (unsigned int) number of conflicts before first global simplification (default: 100)
    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)
    bv.reflect (bool) create enode for every bit-vector term (default: true)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    candidate_models (bool) (default: false) create candidate models even when quantifier or theory reasoning is incomplete.
    cardinality.encoding (symbol) encoding used for at-most-k constraints: grouped, bimander, ordered, unate, circuit (default: grouped)
    cardinality.solver (bool) use cardinality solver (default: true)
    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)
    cce (bool) eliminate covered clauses (default: false)
    check_lemmas (bool) check lemmas on the fly using an independent nlsat solver (default: false)
    clause_proof (bool) record a clausal proof (default: false)
    cofactor_equalities (bool) (default: true) use equalities to rewrite bodies of ite-expressions. This is potentially expensive.
    common_patterns (bool) (default: true) minimize the number of auxiliary variables during CNF encoding by identifing commonly used patterns
    compile_equality (bool) (default:false) compile equalities into pseudo-Boolean equality
    complete (bool) (default: true) add constraints to make sure that any interpretation of a underspecified arithmetic operators is a function. The result will include additional uninterpreted functions/constants: /0, div0, mod0, 0^0, neg-root
    context_solve (bool) (default: false) solve equalities under disjunctions.
    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)
    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)
    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)
    core.minimize (bool) minimize computed core (default: false)
    core.minimize_partial (bool) apply partial (cheap) core minimization (default: false)
    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)
    cut (bool) enable AIG based simplification in-processing (default: false)
    cut.aig (bool) extract aigs (and ites) from cluases for cut simplification (default: false)
    cut.delay (unsigned int) delay cut simplification by in-processing round (default: 2)
    cut.dont_cares (bool) integrate dont cares with cuts (default: true)
    cut.force (bool) force redoing cut-enumeration until a fixed-point (default: false)
    cut.lut (bool) extract luts from clauses for cut simplification (default: false)
    cut.npn3 (bool) extract 3 input functions from clauses for cut simplification (default: false)
    cut.redundancies (bool) integrate redundancy checking of cuts (default: true)
    cut.xor (bool) extract xors from clauses for cut simplification (default: false)
    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)
    dack.eq (bool) enable dynamic ackermannization for transtivity of equalities (default: false)
    dack.factor (double) number of instance per conflict (default: 0.1)
    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)
    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)
    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)
    ddfw.init_clause_weight (unsigned int) initial clause weight for DDFW local search (default: 8)
    ddfw.reinit_base (unsigned int) increment basis for geometric backoff scheme of re-initialization of weights (default: 10000)
    ddfw.restart_base (unsigned int) number of flips used a starting point for hessitant restart backoff (default: 100000)
    ddfw.threads (unsigned int) number of ddfw threads to run in parallel with sat solver (default: 0)
    ddfw.use_reward_pct (unsigned int) percentage to pick highest reward variable when it has reward 0 (default: 15)
    ddfw_search (bool) use ddfw local search instead of CDCL (default: false)
    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)
    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)
    dimacs.core (bool) extract core from DIMACS benchmarks (default: false)
    distributivity (bool) (default: true) minimize the number of auxiliary variables during CNF encoding by applying distributivity over unshared subformulas
    distributivity_blowup (unsigned int) (default: 32) maximum overhead for applying distributivity during CNF encoding
    drat.activity (bool) dump variable activities (default: false)
    drat.binary (bool) use Binary DRAT output format (default: false)
    drat.check_sat (bool) build up internal trace, check satisfying model (default: false)
    drat.check_unsat (bool) build up internal proof and check (default: false)
    drat.file (symbol) file to dump DRAT proofs (default: )
    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)
    dyn_sub_res (bool) dynamic subsumption resolution for minimizing learned clauses (default: true)
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_inverses (bool) (default: true) eliminate inverse trigonometric functions (asin, acos, atan).
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_root_objects (bool) (default: true) eliminate root objects.
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    elim_vars (bool) enable variable elimination using resolution during simplification (default: true)
    elim_vars_bdd (bool) enable variable elimination using BDD recompilation during simplification (default: true)
    elim_vars_bdd_delay (unsigned int) delay elimination of variables using BDDs until after simplification round (default: 3)
    ematching (bool) E-Matching based quantifier instantiation (default: true)
    enable_pre_simplify (bool) enable pre simplifications before the bounded search (default: false)
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    factor (bool) (default: true) factor polynomials.
    factor_max_prime (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step (default: 31)
    factor_num_primes (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)'s. This parameter specify the maximum number of finite factorizations to be considered, before lifiting and searching (default: 1)
    factor_search_size (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space (default: 5000)
    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    force_cleanup (bool) force cleanup to remove tautologies and simplify clauses (default: false)
    gc (symbol) garbage collection strategy: psm, glue, glue_psm, dyn_psm (default: glue_psm)
    gc.burst (bool) perform eager garbage collection during initialization (default: false)
    gc.defrag (bool) defragment clauses when garbage collecting (default: true)
    gc.increment (unsigned int) increment to the garbage collection threshold (default: 500)
    gc.initial (unsigned int) learned clauses garbage collection frequency (default: 20000)
    gc.k (unsigned int) learned clauses that are inactive for k gc rounds are permanently deleted (only used in dyn_psm) (default: 7)
    gc.small_lbd (unsigned int) learned clauses with small LBD are never deleted (only used in dyn_psm) (default: 3)
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_labels (bool) remove/ignore labels in the input formula, this option is ignored if proofs are enabled (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    induction (bool) enable generation of induction lemmas (default: false)
    inline_vars (bool) inline variables that can be isolated from equations (not supported in incremental mode) (default: false)
    inprocess.max (unsigned int) maximal number of inprocessing passes (default: 4294967295)
    inprocess.out (symbol) file to dump result of the first inprocessing step and exit (default: )
    ite_chaing (bool) (default: true) minimize the number of auxiliary variables during CNF encoding by identifing if-then-else chains
    ite_extra (bool) (default: true) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    ite_solver (bool) (default: true) use if-then-else solver.
    keep_cardinality_constraints (bool) (default: true) retain cardinality constraints for solver
    lazy (unsigned int) how lazy the solver is. (default: 0)
    learned (bool) (default: false) collect also learned clauses.
    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    local_search (bool) use local search instead of CDCL (default: false)
    local_search_dbg_flips (bool) write debug information for number of flips (default: false)
    local_search_mode (symbol) local search algorithm, either default wsat or qsat (default: wsat)
    local_search_threads (unsigned int) number of local search threads to find satisfiable solution (default: 0)
    log_lemmas (bool) display lemmas as self-contained SMT formulas (default: false)
    logic (symbol) logic used to setup the SMT solver (default: )
    lookahead.cube.cutoff (symbol) cutoff type used to create lookahead cubes: depth, freevars, psat, adaptive_freevars, adaptive_psat (default: depth)
    lookahead.cube.depth (unsigned int) cut-off depth to create cubes. Used when lookahead.cube.cutoff is depth. (default: 1)
    lookahead.cube.fraction (double) adaptive fraction to create lookahead cubes. Used when lookahead.cube.cutoff is adaptive_freevars or adaptive_psat (default: 0.4)
    lookahead.cube.freevars (double) cube free variable fraction. Used when lookahead.cube.cutoff is freevars (default: 0.8)
    lookahead.cube.psat.clause_base (double) clause base for PSAT cutoff (default: 2)
    lookahead.cube.psat.trigger (double) trigger value to create lookahead cubes for PSAT cutoff. Used when lookahead.cube.cutoff is psat (default: 5)
    lookahead.cube.psat.var_exp (double) free variable exponent for PSAT cutoff (default: 1)
    lookahead.delta_fraction (double) number between 0 and 1, the smaller the more literals are selected for double lookahead (default: 1.0)
    lookahead.double (bool) enable doubld lookahead (default: true)
    lookahead.global_autarky (bool) prefer to branch on variables that occur in clauses that are reduced (default: false)
    lookahead.preselect (bool) use pre-selection of subset of variables for branching (default: false)
    lookahead.reward (symbol) select lookahead heuristic: ternary, heule_schur (Heule Schur), heuleu (Heule Unit), unit, or march_cu (default: march_cu)
    lookahead.use_learned (bool) use learned clauses when selecting lookahead literal (default: false)
    lookahead_scores (bool) extract lookahead scores. A utility that can only be used from the DIMACS front-end (default: false)
    lookahead_simplify (bool) use lookahead solver during simplification (default: false)
    lookahead_simplify.bca (bool) add learned binary clauses as part of lookahead simplification (default: true)
    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)
    max_args (unsigned int) (default: 128) maximum number of arguments (per application) that will be considered by the greedy (quadratic) heuristic.
    max_conflicts (unsigned int) maximum number of conflicts (default: 4294967295)
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_depth (unsigned int) (default: 1024) maximum term depth.
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    max_prime (unsigned int) (default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step.
    max_rounds (unsigned int) (default: 4) maximum number of rounds.
    max_search_size (unsigned int) (default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space.
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)
    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)
    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )
    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)
    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)
    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)
    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)
    min_mag (unsigned int) Z3 represents algebraic numbers using a (square-free) polynomial p and an isolating interval (which contains one and only one root of p). This interval may be refined during the computations. This parameter specifies whether to cache the value of a refined interval or not. It says the minimal size of an interval for caching purposes is 1/2^16 (default: 16)
    minimize_conflicts (bool) minimize conflicts (default: false)
    minimize_lemmas (bool) minimize learned clauses (default: true)
    mode (symbol) NNF translation mode: skolem (skolem normal form), quantifiers (skolem normal form + quantifiers in NNF), full (default: skolem)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    nla2bv_bv_size (unsigned int) (default: 4) default bit-vector size used by nla2bv tactic.
    nla2bv_divisor (unsigned int) (default: 2) nla2bv tactic parameter.
    nla2bv_max_bv_size (unsigned int) (default: inf) maximum bit-vector size used by nla2bv tactic
    nla2bv_root (unsigned int) (default: 2) nla2bv tactic encodes reals into bit-vectors using expressions of the form a+b*sqrt(c), this parameter sets the value of c used in the encoding.
    num_primes (unsigned int) (default: 1) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)'s. This parameter specify the maximum number of finite factorizations to be considered, before lifiting and searching.
    override_incremental (bool) override incremental safety gaps. Enable elimination of blocked clauses and variables even if solver is reused (default: false)
    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)
    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)
    pb.lemma_format (symbol) generate either cardinality or pb lemmas (default: cardinality)
    pb.min_arity (unsigned int) minimal arity to compile pb/cardinality constraints to CNF (default: 9)
    pb.resolve (symbol) resolution strategy for boolean algebra solver: cardinality, rounding (default: cardinality)
    pb.solver (symbol) method for handling Pseudo-Boolean constraints: circuit (arithmetical circuit), sorting (sorting circuit), totalizer (use totalizer encoding), binary_merge, segmented, solver (use native solver) (default: solver)
    phase (symbol) phase selection strategy: always_false, always_true, basic_caching, random, caching (default: caching)
    phase.sticky (bool) use sticky phase caching (default: true)
    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)
    prob_search (bool) use probsat local search instead of CDCL (default: false)
    probing (bool) apply failed literal detection during simplification (default: true)
    probing_binary (bool) probe binary clauses (default: true)
    probing_cache (bool) add binary literals as lemmas (default: true)
    probing_cache_limit (unsigned int) cache binaries unless overall memory usage exceeds cache limit (default: 1024)
    probing_limit (unsigned int) limit to the number of probe calls (default: 5000000)
    propagate.prefetch (bool) prefetch watch lists for assigned literals (default: true)
    propagate_eq (bool) (default: false) enable equality propagation from bounds.
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    pull_nested_quantifiers (bool) pull nested quantifiers (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))
    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)
    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)
    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)
    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)
    qi.profile (bool) profile quantifier instantiation (default: false)
    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)
    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)
    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)
    random_freq (double) frequency of random case splits (default: 0.01)
    random_seed (unsigned int) random seed (default: 0)
    randomize (bool) randomize selection of a witness in nlsat. (default: true)
    refine_inj_axioms (bool) refine injectivity axioms (default: true)
    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)
    reorder (bool) reorder variables. (default: true)
    reorder.activity_scale (unsigned int) scaling factor for activity update (default: 100)
    reorder.base (unsigned int) number of conflicts per random reorder  (default: 4294967295)
    reorder.itau (double) inverse temperature for softmax (default: 4.0)
    rephase.base (unsigned int) number of conflicts per rephase  (default: 1000)
    resolution.cls_cutoff1 (unsigned int) limit1 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 100000000)
    resolution.cls_cutoff2 (unsigned int) limit2 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 700000000)
    resolution.limit (unsigned int) approx. maximum number of literals visited during variable elimination (default: 500000000)
    resolution.lit_cutoff_range1 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 700)
    resolution.lit_cutoff_range2 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 400)
    resolution.lit_cutoff_range3 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 300)
    resolution.occ_cutoff (unsigned int) first cutoff (on number of positive/negative occurrences) for Boolean variable elimination (default: 10)
    resolution.occ_cutoff_range1 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 8)
    resolution.occ_cutoff_range2 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 5)
    resolution.occ_cutoff_range3 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 3)
    restart (symbol) restart strategy: static, luby, ema or geometric (default: ema)
    restart.emafastglue (double) ema alpha factor for fast moving average (default: 0.03)
    restart.emaslowglue (double) ema alpha factor for slow moving average (default: 1e-05)
    restart.factor (double) restart increment factor for geometric strategy (default: 1.5)
    restart.fast (bool) use fast restart approach only removing less active literals. (default: true)
    restart.initial (unsigned int) initial restart (number of conflicts) (default: 2)
    restart.margin (double) margin between fast and slow restart factors. For ema (default: 1.1)
    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)
    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)
    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)
    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)
    retain_blocked_clauses (bool) retain blocked clauses as lemmas (default: true)
    rewrite_patterns (bool) rewrite patterns. (default: false)
    scc (bool) eliminate Boolean variables by computing strongly connected components (default: true)
    scc.tr (bool) apply transitive reduction, eliminate redundant binary clauses (default: true)
    search.sat.conflicts (unsigned int) period for solving for sat (in number of conflicts) (default: 400)
    search.unsat.conflicts (unsigned int) period for solving for unsat (in number of conflicts) (default: 400)
    seed (unsigned int) random seed. (default: 0)
    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)
    seq.use_derivatives (bool) dev flag (not for users) enable derivative based unfolding of regex (default: false)
    seq.use_unicode (bool) dev flag (not for users) enable unicode semantics (default: false)
    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)
    shuffle_vars (bool) use a random variable order. (default: false)
    simplify.delay (unsigned int) set initial delay of simplification by a conflict count (default: 0)
    simplify_conflicts (bool) simplify conflicts using equalities before resolving them in nlsat solver. (default: true)
    sk_hack (bool) hack for VCC (default: false)
    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations.
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)
    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)
    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)
    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)
    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)
    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)
    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)
    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)
    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)
    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)
    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)
    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)
    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)
    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)
    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)
    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)
    subsumption (bool) eliminate subsumed clauses (default: true)
    subsumption.limit (unsigned int) approx. maximum number of literals visited during subsumption (and subsumption resolution) (default: 100000000)
    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)
    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)
    theory_solver (bool) (default: true) use theory solvers.
    threads (unsigned int) number of parallel threads to use (default: 1)
    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)
    variable_decay (unsigned int) multiplier (divided by 100) for the VSIDS activity increment (default: 110)
    zero_accuracy (unsigned int) one of the most time-consuming operations in the real algebraic number module is determining the sign of a polynomial evaluated at a sample point with non-rational algebraic number values. Let k be the value of this option. If k is 0, Z3 uses precise computation. Otherwise, the result of a polynomial evaluation is considered to be 0 if Z3 can show it is inside the interval (-1/2^k, 1/2^k) (default: 0)
- qfnra builtin strategy for solving QF_NRA problems.
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)
    arith.bounded_expansion (bool) box variables used in branch and bound into bound assumptions (default: false)
    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)
    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)
    arith.cheap_eqs (unsigned int) 0 - do not run, 1 - use tree, 2 - use table (default: 1)
    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)
    arith.eager_eq_axioms (bool) eager equality axioms (default: true)
    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)
    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)
    arith.ignore_int (bool) treat integer variables as real (default: false)
    arith.int_eq_branch (bool) branching using derived integer equations (default: false)
    arith.min (bool) minimize cost (default: false)
    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.branching (bool) branching on integer variables in non linear clusters, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.expp (bool) expensive patching (default: false)
    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)
    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)
    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)
    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)
    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)
    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)
    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)
    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)
    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.horner (bool) run horner's heuristic (default: true)
    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)
    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)
    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.nra (bool) call nra_solver when incremental lianirization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)
    arith.nl.order (bool) run order lemmas (default: true)
    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)
    arith.nl.tangents (bool) run tangent lemmas (default: true)
    arith.print_ext_var_names (bool) print external variable names (default: false)
    arith.print_stats (bool) print statistic (default: false)
    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)
    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine bounds (default: 2)
    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)
    arith.reflect (bool) reflect arithmetical operators to the congruence closure (default: true)
    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)
    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)
    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    array.extensional (bool) extensional array theory (default: true)
    array.weak (bool) weak array theory (default: false)
    auto_config (bool) automatically configure solver (default: true)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)
    bv.reflect (bool) create enode for every bit-vector term (default: true)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    candidate_models (bool) (default: false) create candidate models even when quantifier or theory reasoning is incomplete.
    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)
    check_lemmas (bool) check lemmas on the fly using an independent nlsat solver (default: false)
    clause_proof (bool) record a clausal proof (default: false)
    common_patterns (bool) (default: true) minimize the number of auxiliary variables during CNF encoding by identifing commonly used patterns
    complete (bool) (default: true) add constraints to make sure that any interpretation of a underspecified arithmetic operators is a function. The result will include additional uninterpreted functions/constants: /0, div0, mod0, 0^0, neg-root
    context_solve (bool) (default: false) solve equalities under disjunctions.
    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)
    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)
    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)
    core.minimize (bool) minimize unsat core produced by SMT context (default: false)
    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)
    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)
    dack.eq (bool) enable dynamic ackermannization for transtivity of equalities (default: false)
    dack.factor (double) number of instance per conflict (default: 0.1)
    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)
    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)
    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)
    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)
    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)
    distributivity (bool) (default: true) minimize the number of auxiliary variables during CNF encoding by applying distributivity over unshared subformulas
    distributivity_blowup (unsigned int) (default: 32) maximum overhead for applying distributivity during CNF encoding
    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_inverses (bool) (default: true) eliminate inverse trigonometric functions (asin, acos, atan).
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_root_objects (bool) (default: true) eliminate root objects.
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    ematching (bool) E-Matching based quantifier instantiation (default: true)
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    factor (bool) (default: true) factor polynomials.
    factor_max_prime (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step (default: 31)
    factor_num_primes (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)'s. This parameter specify the maximum number of finite factorizations to be considered, before lifiting and searching (default: 1)
    factor_search_size (unsigned int) parameter for the polynomial factorization procedure in the algebraic number module. Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space (default: 5000)
    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_labels (bool) remove/ignore labels in the input formula, this option is ignored if proofs are enabled (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    induction (bool) enable generation of induction lemmas (default: false)
    inline_vars (bool) inline variables that can be isolated from equations (not supported in incremental mode) (default: false)
    ite_chaing (bool) (default: true) minimize the number of auxiliary variables during CNF encoding by identifing if-then-else chains
    ite_extra (bool) (default: true) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    ite_solver (bool) (default: true) use if-then-else solver.
    lazy (unsigned int) how lazy the solver is. (default: 0)
    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    log_lemmas (bool) display lemmas as self-contained SMT formulas (default: false)
    logic (symbol) logic used to setup the SMT solver (default: )
    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)
    max_args (unsigned int) (default: 128) maximum number of arguments (per application) that will be considered by the greedy (quadratic) heuristic.
    max_conflicts (unsigned int) maximum number of conflicts. (default: 4294967295)
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    max_prime (unsigned int) (default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter limits the maximum prime number p to be used in the first step.
    max_rounds (unsigned int) (default: 4) maximum number of rounds.
    max_search_size (unsigned int) (default: infty) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. This parameter can be used to limit the search space.
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)
    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)
    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )
    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)
    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)
    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)
    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)
    min_mag (unsigned int) Z3 represents algebraic numbers using a (square-free) polynomial p and an isolating interval (which contains one and only one root of p). This interval may be refined during the computations. This parameter specifies whether to cache the value of a refined interval or not. It says the minimal size of an interval for caching purposes is 1/2^16 (default: 16)
    minimize_conflicts (bool) minimize conflicts (default: false)
    mode (symbol) NNF translation mode: skolem (skolem normal form), quantifiers (skolem normal form + quantifiers in NNF), full (default: skolem)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    nla2bv_bv_size (unsigned int) (default: 4) default bit-vector size used by nla2bv tactic.
    nla2bv_divisor (unsigned int) (default: 2) nla2bv tactic parameter.
    nla2bv_max_bv_size (unsigned int) (default: inf) maximum bit-vector size used by nla2bv tactic
    nla2bv_root (unsigned int) (default: 2) nla2bv tactic encodes reals into bit-vectors using expressions of the form a+b*sqrt(c), this parameter sets the value of c used in the encoding.
    num_primes (unsigned int) (default: 1) Z3 polynomial factorization is composed of three steps: factorization in GF(p), lifting and search. The search space may be reduced by factoring the polynomial in different GF(p)'s. This parameter specify the maximum number of finite factorizations to be considered, before lifiting and searching.
    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)
    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)
    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    pull_nested_quantifiers (bool) pull nested quantifiers (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))
    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)
    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)
    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)
    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)
    qi.profile (bool) profile quantifier instantiation (default: false)
    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)
    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)
    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)
    random_seed (unsigned int) random seed for the smt solver (default: 0)
    randomize (bool) randomize selection of a witness in nlsat. (default: true)
    refine_inj_axioms (bool) refine injectivity axioms (default: true)
    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)
    reorder (bool) reorder variables. (default: true)
    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)
    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)
    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)
    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)
    rewrite_patterns (bool) rewrite patterns. (default: false)
    seed (unsigned int) random seed. (default: 0)
    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)
    seq.use_derivatives (bool) dev flag (not for users) enable derivative based unfolding of regex (default: false)
    seq.use_unicode (bool) dev flag (not for users) enable unicode semantics (default: false)
    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)
    shuffle_vars (bool) use a random variable order. (default: false)
    simplify_conflicts (bool) simplify conflicts using equalities before resolving them in nlsat solver. (default: true)
    sk_hack (bool) hack for VCC (default: false)
    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations.
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
    split_factors (bool) (default: true) apply simplifications such as (= (* p1 p2) 0) --> (or (= p1 0) (= p2 0)).
    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)
    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)
    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)
    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)
    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)
    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)
    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)
    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)
    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)
    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)
    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)
    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)
    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)
    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)
    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)
    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)
    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)
    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)
    theory_solver (bool) (default: true) use theory solvers.
    threads (unsigned int) maximal number of parallel threads. (default: 1)
    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)
    zero_accuracy (unsigned int) one of the most time-consuming operations in the real algebraic number module is determining the sign of a polynomial evaluated at a sample point with non-rational algebraic number values. Let k be the value of this option. If k is 0, Z3 uses precise computation. Otherwise, the result of a polynomial evaluation is considered to be 0 if Z3 can show it is inside the interval (-1/2^k, 1/2^k) (default: 0)
- qfuf builtin strategy for solving QF_UF problems.
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)
    arith.bounded_expansion (bool) box variables used in branch and bound into bound assumptions (default: false)
    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)
    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)
    arith.cheap_eqs (unsigned int) 0 - do not run, 1 - use tree, 2 - use table (default: 1)
    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)
    arith.eager_eq_axioms (bool) eager equality axioms (default: true)
    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)
    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)
    arith.ignore_int (bool) treat integer variables as real (default: false)
    arith.int_eq_branch (bool) branching using derived integer equations (default: false)
    arith.min (bool) minimize cost (default: false)
    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.branching (bool) branching on integer variables in non linear clusters, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.expp (bool) expensive patching (default: false)
    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)
    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)
    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)
    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)
    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)
    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)
    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)
    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)
    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.horner (bool) run horner's heuristic (default: true)
    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)
    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)
    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.nra (bool) call nra_solver when incremental lianirization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)
    arith.nl.order (bool) run order lemmas (default: true)
    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)
    arith.nl.tangents (bool) run tangent lemmas (default: true)
    arith.print_ext_var_names (bool) print external variable names (default: false)
    arith.print_stats (bool) print statistic (default: false)
    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)
    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine bounds (default: 2)
    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)
    arith.reflect (bool) reflect arithmetical operators to the congruence closure (default: true)
    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)
    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)
    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    array.extensional (bool) extensional array theory (default: true)
    array.weak (bool) weak array theory (default: false)
    auto_config (bool) automatically configure solver (default: true)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)
    bv.reflect (bool) create enode for every bit-vector term (default: true)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    candidate_models (bool) (default: false) create candidate models even when quantifier or theory reasoning is incomplete.
    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)
    clause_proof (bool) record a clausal proof (default: false)
    context_solve (bool) (default: false) solve equalities under disjunctions.
    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)
    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)
    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)
    core.minimize (bool) minimize unsat core produced by SMT context (default: false)
    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)
    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)
    dack.eq (bool) enable dynamic ackermannization for transtivity of equalities (default: false)
    dack.factor (double) number of instance per conflict (default: 0.1)
    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)
    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)
    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)
    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)
    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)
    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    ematching (bool) E-Matching based quantifier instantiation (default: true)
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    induction (bool) enable generation of induction lemmas (default: false)
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    ite_solver (bool) (default: true) use if-then-else solver.
    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    logic (symbol) logic used to setup the SMT solver (default: )
    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)
    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    max_rounds (unsigned int) (default: 4) maximum number of rounds.
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)
    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)
    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )
    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)
    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)
    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)
    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)
    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)
    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    pull_nested_quantifiers (bool) pull nested quantifiers (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))
    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)
    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)
    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)
    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)
    qi.profile (bool) profile quantifier instantiation (default: false)
    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)
    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)
    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)
    random_seed (unsigned int) random seed for the smt solver (default: 0)
    refine_inj_axioms (bool) refine injectivity axioms (default: true)
    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)
    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)
    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)
    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)
    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)
    rewrite_patterns (bool) rewrite patterns. (default: false)
    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)
    seq.use_derivatives (bool) dev flag (not for users) enable derivative based unfolding of regex (default: false)
    seq.use_unicode (bool) dev flag (not for users) enable unicode semantics (default: false)
    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)
    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations.
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)
    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)
    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)
    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)
    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)
    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)
    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)
    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)
    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)
    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)
    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)
    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)
    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)
    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)
    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)
    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)
    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)
    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)
    theory_solver (bool) (default: true) use theory solvers.
    threads (unsigned int) maximal number of parallel threads. (default: 1)
    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)
- qfufbv builtin strategy for solving QF_UFBV problems.
    abce (bool) eliminate blocked clauses using asymmetric literals (default: false)
    acce (bool) eliminate covered clauses using asymmetric added literals (default: false)
    aig_per_assertion (bool) (default: true) process one assertion at a time.
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    anf (bool) enable ANF based simplification in-processing (default: false)
    anf.delay (unsigned int) delay ANF simplification by in-processing round (default: 2)
    anf.exlin (bool) enable extended linear simplification (default: false)
    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)
    arith.bounded_expansion (bool) box variables used in branch and bound into bound assumptions (default: false)
    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)
    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)
    arith.cheap_eqs (unsigned int) 0 - do not run, 1 - use tree, 2 - use table (default: 1)
    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)
    arith.eager_eq_axioms (bool) eager equality axioms (default: true)
    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)
    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)
    arith.ignore_int (bool) treat integer variables as real (default: false)
    arith.int_eq_branch (bool) branching using derived integer equations (default: false)
    arith.min (bool) minimize cost (default: false)
    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.branching (bool) branching on integer variables in non linear clusters, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.expp (bool) expensive patching (default: false)
    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)
    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)
    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)
    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)
    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)
    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)
    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)
    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)
    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.horner (bool) run horner's heuristic (default: true)
    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)
    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)
    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.nra (bool) call nra_solver when incremental lianirization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)
    arith.nl.order (bool) run order lemmas (default: true)
    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)
    arith.nl.tangents (bool) run tangent lemmas (default: true)
    arith.print_ext_var_names (bool) print external variable names (default: false)
    arith.print_stats (bool) print statistic (default: false)
    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)
    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine bounds (default: 2)
    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)
    arith.reflect (bool) reflect arithmetical operators to the congruence closure (default: true)
    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)
    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)
    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    array.extensional (bool) extensional array theory (default: true)
    array.weak (bool) weak array theory (default: false)
    asymm_branch (bool) asymmetric branching (default: true)
    asymm_branch.all (bool) asymmetric branching on all literals per clause (default: false)
    asymm_branch.delay (unsigned int) number of simplification rounds to wait until invoking asymmetric branch simplification (default: 1)
    asymm_branch.limit (unsigned int) approx. maximum number of literals visited during asymmetric branching (default: 100000000)
    asymm_branch.rounds (unsigned int) maximal number of rounds to run asymmetric branch simplifications if progress is made (default: 2)
    asymm_branch.sampled (bool) use sampling based asymmetric branching based on binary implication graph (default: true)
    ate (bool) asymmetric tautology elimination (default: true)
    auto_config (bool) automatically configure solver (default: true)
    backtrack.conflicts (unsigned int) number of conflicts before enabling chronological backtracking (default: 4000)
    backtrack.scopes (unsigned int) number of scopes to enable chronological backtracking (default: 100)
    bca (bool) blocked clause addition - add blocked binary clauses (default: false)
    bce (bool) eliminate blocked clauses (default: false)
    bce_at (unsigned int) eliminate blocked clauses only once at the given simplification round (default: 2)
    bce_delay (unsigned int) delay eliminate blocked clauses until simplification round (default: 2)
    binspr (bool) enable SPR inferences of binary propagation redundant clauses. This inprocessing step eliminates models (default: false)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_add (bool) (default: true) bit-blast adders.
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    blast_full (bool) (default: false) bit-blast any term with bit-vector sort, this option will make E-matching ineffective in any pattern containing bit-vector terms.
    blast_mul (bool) (default: true) bit-blast multipliers (and dividers, remainders).
    blast_quant (bool) (default: false) bit-blast quantified variables.
    blocked_clause_limit (unsigned int) maximum number of literals visited during blocked clause elimination (default: 100000000)
    branching.anti_exploration (bool) apply anti-exploration heuristic for branch selection (default: false)
    branching.heuristic (symbol) branching heuristic vsids, chb (default: vsids)
    burst_search (unsigned int) number of conflicts before first global simplification (default: 100)
    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)
    bv.reflect (bool) create enode for every bit-vector term (default: true)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    candidate_models (bool) (default: false) create candidate models even when quantifier or theory reasoning is incomplete.
    cardinality.encoding (symbol) encoding used for at-most-k constraints: grouped, bimander, ordered, unate, circuit (default: grouped)
    cardinality.solver (bool) use cardinality solver (default: true)
    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)
    cce (bool) eliminate covered clauses (default: false)
    clause_proof (bool) record a clausal proof (default: false)
    context_solve (bool) (default: false) solve equalities under disjunctions.
    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)
    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)
    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)
    core.minimize (bool) minimize unsat core produced by SMT context (default: false)
    core.minimize_partial (bool) apply partial (cheap) core minimization (default: false)
    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)
    cut (bool) enable AIG based simplification in-processing (default: false)
    cut.aig (bool) extract aigs (and ites) from cluases for cut simplification (default: false)
    cut.delay (unsigned int) delay cut simplification by in-processing round (default: 2)
    cut.dont_cares (bool) integrate dont cares with cuts (default: true)
    cut.force (bool) force redoing cut-enumeration until a fixed-point (default: false)
    cut.lut (bool) extract luts from clauses for cut simplification (default: false)
    cut.npn3 (bool) extract 3 input functions from clauses for cut simplification (default: false)
    cut.redundancies (bool) integrate redundancy checking of cuts (default: true)
    cut.xor (bool) extract xors from clauses for cut simplification (default: false)
    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)
    dack.eq (bool) enable dynamic ackermannization for transtivity of equalities (default: false)
    dack.factor (double) number of instance per conflict (default: 0.1)
    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)
    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)
    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)
    ddfw.init_clause_weight (unsigned int) initial clause weight for DDFW local search (default: 8)
    ddfw.reinit_base (unsigned int) increment basis for geometric backoff scheme of re-initialization of weights (default: 10000)
    ddfw.restart_base (unsigned int) number of flips used a starting point for hessitant restart backoff (default: 100000)
    ddfw.threads (unsigned int) number of ddfw threads to run in parallel with sat solver (default: 0)
    ddfw.use_reward_pct (unsigned int) percentage to pick highest reward variable when it has reward 0 (default: 15)
    ddfw_search (bool) use ddfw local search instead of CDCL (default: false)
    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)
    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)
    dimacs.core (bool) extract core from DIMACS benchmarks (default: false)
    div0_ackermann_limit (unsigned int) a bound for number of congruence Ackermann lemmas for div0 modelling (default: 1000)
    drat.activity (bool) dump variable activities (default: false)
    drat.binary (bool) use Binary DRAT output format (default: false)
    drat.check_sat (bool) build up internal trace, check satisfying model (default: false)
    drat.check_unsat (bool) build up internal proof and check (default: false)
    drat.file (symbol) file to dump DRAT proofs (default: )
    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)
    dyn_sub_res (bool) dynamic subsumption resolution for minimizing learned clauses (default: true)
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    elim_vars (bool) enable variable elimination using resolution during simplification (default: true)
    elim_vars_bdd (bool) enable variable elimination using BDD recompilation during simplification (default: true)
    elim_vars_bdd_delay (unsigned int) delay elimination of variables using BDDs until after simplification round (default: 3)
    ematching (bool) E-Matching based quantifier instantiation (default: true)
    enable_pre_simplify (bool) enable pre simplifications before the bounded search (default: false)
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    force_cleanup (bool) force cleanup to remove tautologies and simplify clauses (default: false)
    gc (symbol) garbage collection strategy: psm, glue, glue_psm, dyn_psm (default: glue_psm)
    gc.burst (bool) perform eager garbage collection during initialization (default: false)
    gc.defrag (bool) defragment clauses when garbage collecting (default: true)
    gc.increment (unsigned int) increment to the garbage collection threshold (default: 500)
    gc.initial (unsigned int) learned clauses garbage collection frequency (default: 20000)
    gc.k (unsigned int) learned clauses that are inactive for k gc rounds are permanently deleted (only used in dyn_psm) (default: 7)
    gc.small_lbd (unsigned int) learned clauses with small LBD are never deleted (only used in dyn_psm) (default: 3)
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    induction (bool) enable generation of induction lemmas (default: false)
    inprocess.max (unsigned int) maximal number of inprocessing passes (default: 4294967295)
    inprocess.out (symbol) file to dump result of the first inprocessing step and exit (default: )
    ite_extra (bool) (default: true) add redundant clauses (that improve unit propagation) when encoding if-then-else formulas
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    ite_solver (bool) (default: true) use if-then-else solver.
    learned (bool) (default: false) collect also learned clauses.
    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    local_search (bool) use local search instead of CDCL (default: false)
    local_search_dbg_flips (bool) write debug information for number of flips (default: false)
    local_search_mode (symbol) local search algorithm, either default wsat or qsat (default: wsat)
    local_search_threads (unsigned int) number of local search threads to find satisfiable solution (default: 0)
    logic (symbol) logic used to setup the SMT solver (default: )
    lookahead.cube.cutoff (symbol) cutoff type used to create lookahead cubes: depth, freevars, psat, adaptive_freevars, adaptive_psat (default: depth)
    lookahead.cube.depth (unsigned int) cut-off depth to create cubes. Used when lookahead.cube.cutoff is depth. (default: 1)
    lookahead.cube.fraction (double) adaptive fraction to create lookahead cubes. Used when lookahead.cube.cutoff is adaptive_freevars or adaptive_psat (default: 0.4)
    lookahead.cube.freevars (double) cube free variable fraction. Used when lookahead.cube.cutoff is freevars (default: 0.8)
    lookahead.cube.psat.clause_base (double) clause base for PSAT cutoff (default: 2)
    lookahead.cube.psat.trigger (double) trigger value to create lookahead cubes for PSAT cutoff. Used when lookahead.cube.cutoff is psat (default: 5)
    lookahead.cube.psat.var_exp (double) free variable exponent for PSAT cutoff (default: 1)
    lookahead.delta_fraction (double) number between 0 and 1, the smaller the more literals are selected for double lookahead (default: 1.0)
    lookahead.double (bool) enable doubld lookahead (default: true)
    lookahead.global_autarky (bool) prefer to branch on variables that occur in clauses that are reduced (default: false)
    lookahead.preselect (bool) use pre-selection of subset of variables for branching (default: false)
    lookahead.reward (symbol) select lookahead heuristic: ternary, heule_schur (Heule Schur), heuleu (Heule Unit), unit, or march_cu (default: march_cu)
    lookahead.use_learned (bool) use learned clauses when selecting lookahead literal (default: false)
    lookahead_scores (bool) extract lookahead scores. A utility that can only be used from the DIMACS front-end (default: false)
    lookahead_simplify (bool) use lookahead solver during simplification (default: false)
    lookahead_simplify.bca (bool) add learned binary clauses as part of lookahead simplification (default: true)
    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)
    max_args (unsigned int) (default: 128) maximum number of arguments (per application) that will be considered by the greedy (quadratic) heuristic.
    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    max_rounds (unsigned int) (default: 4) maximum number of rounds.
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)
    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)
    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )
    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)
    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)
    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)
    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)
    minimize_lemmas (bool) minimize learned clauses (default: true)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    override_incremental (bool) override incremental safety gaps. Enable elimination of blocked clauses and variables even if solver is reused (default: false)
    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)
    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)
    pb.lemma_format (symbol) generate either cardinality or pb lemmas (default: cardinality)
    pb.min_arity (unsigned int) minimal arity to compile pb/cardinality constraints to CNF (default: 9)
    pb.resolve (symbol) resolution strategy for boolean algebra solver: cardinality, rounding (default: cardinality)
    pb.solver (symbol) method for handling Pseudo-Boolean constraints: circuit (arithmetical circuit), sorting (sorting circuit), totalizer (use totalizer encoding), binary_merge, segmented, solver (use native solver) (default: solver)
    phase (symbol) phase selection strategy: always_false, always_true, basic_caching, random, caching (default: caching)
    phase.sticky (bool) use sticky phase caching (default: true)
    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)
    prob_search (bool) use probsat local search instead of CDCL (default: false)
    probing (bool) apply failed literal detection during simplification (default: true)
    probing_binary (bool) probe binary clauses (default: true)
    probing_cache (bool) add binary literals as lemmas (default: true)
    probing_cache_limit (unsigned int) cache binaries unless overall memory usage exceeds cache limit (default: 1024)
    probing_limit (unsigned int) limit to the number of probe calls (default: 5000000)
    propagate.prefetch (bool) prefetch watch lists for assigned literals (default: true)
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    pull_nested_quantifiers (bool) pull nested quantifiers (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))
    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)
    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)
    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)
    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)
    qi.profile (bool) profile quantifier instantiation (default: false)
    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)
    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)
    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)
    random_freq (double) frequency of random case splits (default: 0.01)
    random_seed (unsigned int) random seed for the smt solver (default: 0)
    refine_inj_axioms (bool) refine injectivity axioms (default: true)
    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)
    reorder.activity_scale (unsigned int) scaling factor for activity update (default: 100)
    reorder.base (unsigned int) number of conflicts per random reorder  (default: 4294967295)
    reorder.itau (double) inverse temperature for softmax (default: 4.0)
    rephase.base (unsigned int) number of conflicts per rephase  (default: 1000)
    resolution.cls_cutoff1 (unsigned int) limit1 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 100000000)
    resolution.cls_cutoff2 (unsigned int) limit2 - total number of problems clauses for the second cutoff of Boolean variable elimination (default: 700000000)
    resolution.limit (unsigned int) approx. maximum number of literals visited during variable elimination (default: 500000000)
    resolution.lit_cutoff_range1 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 700)
    resolution.lit_cutoff_range2 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 400)
    resolution.lit_cutoff_range3 (unsigned int) second cutoff (total number of literals) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 300)
    resolution.occ_cutoff (unsigned int) first cutoff (on number of positive/negative occurrences) for Boolean variable elimination (default: 10)
    resolution.occ_cutoff_range1 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing less than res_cls_cutoff1 clauses (default: 8)
    resolution.occ_cutoff_range2 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff1 and less than res_cls_cutoff2 (default: 5)
    resolution.occ_cutoff_range3 (unsigned int) second cutoff (number of positive/negative occurrences) for Boolean variable elimination, for problems containing more than res_cls_cutoff2 (default: 3)
    restart (symbol) restart strategy: static, luby, ema or geometric (default: ema)
    restart.emafastglue (double) ema alpha factor for fast moving average (default: 0.03)
    restart.emaslowglue (double) ema alpha factor for slow moving average (default: 1e-05)
    restart.factor (double) restart increment factor for geometric strategy (default: 1.5)
    restart.fast (bool) use fast restart approach only removing less active literals. (default: true)
    restart.initial (unsigned int) initial restart (number of conflicts) (default: 2)
    restart.margin (double) margin between fast and slow restart factors. For ema (default: 1.1)
    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)
    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)
    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)
    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)
    retain_blocked_clauses (bool) retain blocked clauses as lemmas (default: true)
    rewrite_patterns (bool) rewrite patterns. (default: false)
    scc (bool) eliminate Boolean variables by computing strongly connected components (default: true)
    scc.tr (bool) apply transitive reduction, eliminate redundant binary clauses (default: true)
    search.sat.conflicts (unsigned int) period for solving for sat (in number of conflicts) (default: 400)
    search.unsat.conflicts (unsigned int) period for solving for unsat (in number of conflicts) (default: 400)
    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)
    seq.use_derivatives (bool) dev flag (not for users) enable derivative based unfolding of regex (default: false)
    seq.use_unicode (bool) dev flag (not for users) enable unicode semantics (default: false)
    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)
    simplify.delay (unsigned int) set initial delay of simplification by a conflict count (default: 0)
    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations.
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)
    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)
    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)
    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)
    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)
    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)
    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)
    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)
    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)
    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)
    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)
    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)
    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)
    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)
    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)
    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)
    subsumption (bool) eliminate subsumed clauses (default: true)
    subsumption.limit (unsigned int) approx. maximum number of literals visited during subsumption (and subsumption resolution) (default: 100000000)
    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)
    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)
    theory_solver (bool) (default: true) use theory solvers.
    threads (unsigned int) maximal number of parallel threads. (default: 1)
    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)
    variable_decay (unsigned int) multiplier (divided by 100) for the VSIDS activity increment (default: 110)
- qfufbv_ackr A tactic for solving QF_UFBV based on Ackermannization.
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)
    arith.bounded_expansion (bool) box variables used in branch and bound into bound assumptions (default: false)
    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)
    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)
    arith.cheap_eqs (unsigned int) 0 - do not run, 1 - use tree, 2 - use table (default: 1)
    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)
    arith.eager_eq_axioms (bool) eager equality axioms (default: true)
    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)
    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)
    arith.ignore_int (bool) treat integer variables as real (default: false)
    arith.int_eq_branch (bool) branching using derived integer equations (default: false)
    arith.min (bool) minimize cost (default: false)
    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.branching (bool) branching on integer variables in non linear clusters, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.expp (bool) expensive patching (default: false)
    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)
    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)
    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)
    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)
    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)
    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)
    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)
    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)
    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.horner (bool) run horner's heuristic (default: true)
    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)
    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)
    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.nra (bool) call nra_solver when incremental lianirization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)
    arith.nl.order (bool) run order lemmas (default: true)
    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)
    arith.nl.tangents (bool) run tangent lemmas (default: true)
    arith.print_ext_var_names (bool) print external variable names (default: false)
    arith.print_stats (bool) print statistic (default: false)
    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)
    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine bounds (default: 2)
    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)
    arith.reflect (bool) reflect arithmetical operators to the congruence closure (default: true)
    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)
    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)
    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    array.extensional (bool) extensional array theory (default: true)
    array.weak (bool) weak array theory (default: false)
    auto_config (bool) automatically configure solver (default: true)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)
    bv.reflect (bool) create enode for every bit-vector term (default: true)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    candidate_models (bool) (default: false) create candidate models even when quantifier or theory reasoning is incomplete.
    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)
    clause_proof (bool) record a clausal proof (default: false)
    context_solve (bool) (default: false) solve equalities under disjunctions.
    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)
    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)
    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)
    core.minimize (bool) minimize unsat core produced by SMT context (default: false)
    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)
    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)
    dack.eq (bool) enable dynamic ackermannization for transtivity of equalities (default: false)
    dack.factor (double) number of instance per conflict (default: 0.1)
    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)
    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)
    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)
    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)
    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)
    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    ematching (bool) E-Matching based quantifier instantiation (default: true)
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    induction (bool) enable generation of induction lemmas (default: false)
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    ite_solver (bool) (default: true) use if-then-else solver.
    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    logic (symbol) logic used to setup the SMT solver (default: )
    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)
    max_args (unsigned int) (default: 128) maximum number of arguments (per application) that will be considered by the greedy (quadratic) heuristic.
    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    max_rounds (unsigned int) (default: 4) maximum number of rounds.
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)
    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)
    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )
    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)
    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)
    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)
    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)
    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)
    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    pull_nested_quantifiers (bool) pull nested quantifiers (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))
    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)
    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)
    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)
    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)
    qi.profile (bool) profile quantifier instantiation (default: false)
    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)
    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)
    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)
    random_seed (unsigned int) random seed for the smt solver (default: 0)
    refine_inj_axioms (bool) refine injectivity axioms (default: true)
    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)
    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)
    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)
    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)
    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)
    rewrite_patterns (bool) rewrite patterns. (default: false)
    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)
    seq.use_derivatives (bool) dev flag (not for users) enable derivative based unfolding of regex (default: false)
    seq.use_unicode (bool) dev flag (not for users) enable unicode semantics (default: false)
    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)
    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations.
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)
    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)
    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)
    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)
    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)
    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)
    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)
    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)
    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)
    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)
    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)
    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)
    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)
    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)
    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)
    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)
    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)
    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)
    theory_solver (bool) (default: true) use theory solvers.
    threads (unsigned int) maximal number of parallel threads. (default: 1)
    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)
- ufnia builtin strategy for solving UFNIA problems.
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)
    arith.bounded_expansion (bool) box variables used in branch and bound into bound assumptions (default: false)
    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)
    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)
    arith.cheap_eqs (unsigned int) 0 - do not run, 1 - use tree, 2 - use table (default: 1)
    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)
    arith.eager_eq_axioms (bool) eager equality axioms (default: true)
    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)
    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)
    arith.ignore_int (bool) treat integer variables as real (default: false)
    arith.int_eq_branch (bool) branching using derived integer equations (default: false)
    arith.min (bool) minimize cost (default: false)
    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.branching (bool) branching on integer variables in non linear clusters, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.expp (bool) expensive patching (default: false)
    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)
    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)
    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)
    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)
    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)
    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)
    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)
    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)
    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.horner (bool) run horner's heuristic (default: true)
    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)
    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)
    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.nra (bool) call nra_solver when incremental lianirization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)
    arith.nl.order (bool) run order lemmas (default: true)
    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)
    arith.nl.tangents (bool) run tangent lemmas (default: true)
    arith.print_ext_var_names (bool) print external variable names (default: false)
    arith.print_stats (bool) print statistic (default: false)
    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)
    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine bounds (default: 2)
    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)
    arith.reflect (bool) reflect arithmetical operators to the congruence closure (default: true)
    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)
    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)
    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    array.extensional (bool) extensional array theory (default: true)
    array.weak (bool) weak array theory (default: false)
    auto_config (bool) automatically configure solver (default: true)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)
    bv.reflect (bool) create enode for every bit-vector term (default: true)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    candidate_models (bool) (default: false) create candidate models even when quantifier or theory reasoning is incomplete.
    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)
    clause_proof (bool) record a clausal proof (default: false)
    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)
    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)
    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)
    core.minimize (bool) minimize unsat core produced by SMT context (default: false)
    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)
    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)
    dack.eq (bool) enable dynamic ackermannization for transtivity of equalities (default: false)
    dack.factor (double) number of instance per conflict (default: 0.1)
    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)
    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)
    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)
    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)
    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)
    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    ematching (bool) E-Matching based quantifier instantiation (default: true)
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    induction (bool) enable generation of induction lemmas (default: false)
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    logic (symbol) logic used to setup the SMT solver (default: )
    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)
    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_depth (unsigned int) (default: 1024) maximum term depth.
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    max_rounds (unsigned int) (default: 4) maximum number of rounds.
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)
    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)
    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )
    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)
    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)
    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)
    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)
    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)
    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)
    propagate_eq (bool) (default: false) enable equality propagation from bounds.
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    pull_nested_quantifiers (bool) pull nested quantifiers (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))
    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)
    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)
    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)
    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)
    qi.profile (bool) profile quantifier instantiation (default: false)
    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)
    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)
    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)
    random_seed (unsigned int) random seed for the smt solver (default: 0)
    refine_inj_axioms (bool) refine injectivity axioms (default: true)
    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)
    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)
    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)
    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)
    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)
    rewrite_patterns (bool) rewrite patterns. (default: false)
    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)
    seq.use_derivatives (bool) dev flag (not for users) enable derivative based unfolding of regex (default: false)
    seq.use_unicode (bool) dev flag (not for users) enable unicode semantics (default: false)
    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)
    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)
    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)
    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)
    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)
    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)
    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)
    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)
    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)
    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)
    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)
    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)
    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)
    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)
    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)
    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)
    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)
    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)
    threads (unsigned int) maximal number of parallel threads. (default: 1)
    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)
- uflra builtin strategy for solving UFLRA problems.
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)
    arith.bounded_expansion (bool) box variables used in branch and bound into bound assumptions (default: false)
    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)
    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)
    arith.cheap_eqs (unsigned int) 0 - do not run, 1 - use tree, 2 - use table (default: 1)
    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)
    arith.eager_eq_axioms (bool) eager equality axioms (default: true)
    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)
    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)
    arith.ignore_int (bool) treat integer variables as real (default: false)
    arith.int_eq_branch (bool) branching using derived integer equations (default: false)
    arith.min (bool) minimize cost (default: false)
    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.branching (bool) branching on integer variables in non linear clusters, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.expp (bool) expensive patching (default: false)
    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)
    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)
    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)
    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)
    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)
    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)
    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)
    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)
    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.horner (bool) run horner's heuristic (default: true)
    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)
    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)
    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.nra (bool) call nra_solver when incremental lianirization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)
    arith.nl.order (bool) run order lemmas (default: true)
    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)
    arith.nl.tangents (bool) run tangent lemmas (default: true)
    arith.print_ext_var_names (bool) print external variable names (default: false)
    arith.print_stats (bool) print statistic (default: false)
    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)
    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine bounds (default: 2)
    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)
    arith.reflect (bool) reflect arithmetical operators to the congruence closure (default: true)
    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)
    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)
    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    array.extensional (bool) extensional array theory (default: true)
    array.weak (bool) weak array theory (default: false)
    auto_config (bool) automatically configure solver (default: true)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)
    bv.reflect (bool) create enode for every bit-vector term (default: true)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    candidate_models (bool) (default: false) create candidate models even when quantifier or theory reasoning is incomplete.
    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)
    clause_proof (bool) record a clausal proof (default: false)
    context_solve (bool) (default: false) solve equalities under disjunctions.
    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)
    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)
    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)
    core.minimize (bool) minimize unsat core produced by SMT context (default: false)
    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)
    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)
    dack.eq (bool) enable dynamic ackermannization for transtivity of equalities (default: false)
    dack.factor (double) number of instance per conflict (default: 0.1)
    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)
    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)
    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)
    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)
    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)
    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    ematching (bool) E-Matching based quantifier instantiation (default: true)
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    induction (bool) enable generation of induction lemmas (default: false)
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    ite_solver (bool) (default: true) use if-then-else solver.
    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    logic (symbol) logic used to setup the SMT solver (default: )
    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)
    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_depth (unsigned int) (default: 1024) maximum term depth.
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    max_rounds (unsigned int) (default: 4) maximum number of rounds.
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)
    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)
    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )
    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)
    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)
    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)
    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)
    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)
    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)
    propagate_eq (bool) (default: false) enable equality propagation from bounds.
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    pull_nested_quantifiers (bool) pull nested quantifiers (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))
    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)
    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)
    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)
    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)
    qi.profile (bool) profile quantifier instantiation (default: false)
    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)
    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)
    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)
    random_seed (unsigned int) random seed for the smt solver (default: 0)
    refine_inj_axioms (bool) refine injectivity axioms (default: true)
    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)
    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)
    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)
    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)
    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)
    rewrite_patterns (bool) rewrite patterns. (default: false)
    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)
    seq.use_derivatives (bool) dev flag (not for users) enable derivative based unfolding of regex (default: false)
    seq.use_unicode (bool) dev flag (not for users) enable unicode semantics (default: false)
    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)
    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations.
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)
    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)
    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)
    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)
    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)
    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)
    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)
    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)
    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)
    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)
    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)
    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)
    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)
    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)
    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)
    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)
    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)
    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)
    theory_solver (bool) (default: true) use theory solvers.
    threads (unsigned int) maximal number of parallel threads. (default: 1)
    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)
- auflia builtin strategy for solving AUFLIA problems.
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)
    arith.bounded_expansion (bool) box variables used in branch and bound into bound assumptions (default: false)
    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)
    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)
    arith.cheap_eqs (unsigned int) 0 - do not run, 1 - use tree, 2 - use table (default: 1)
    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)
    arith.eager_eq_axioms (bool) eager equality axioms (default: true)
    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)
    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)
    arith.ignore_int (bool) treat integer variables as real (default: false)
    arith.int_eq_branch (bool) branching using derived integer equations (default: false)
    arith.min (bool) minimize cost (default: false)
    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.branching (bool) branching on integer variables in non linear clusters, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.expp (bool) expensive patching (default: false)
    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)
    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)
    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)
    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)
    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)
    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)
    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)
    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)
    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.horner (bool) run horner's heuristic (default: true)
    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)
    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)
    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.nra (bool) call nra_solver when incremental lianirization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)
    arith.nl.order (bool) run order lemmas (default: true)
    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)
    arith.nl.tangents (bool) run tangent lemmas (default: true)
    arith.print_ext_var_names (bool) print external variable names (default: false)
    arith.print_stats (bool) print statistic (default: false)
    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)
    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine bounds (default: 2)
    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)
    arith.reflect (bool) reflect arithmetical operators to the congruence closure (default: true)
    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)
    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)
    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    array.extensional (bool) extensional array theory (default: true)
    array.weak (bool) weak array theory (default: false)
    auto_config (bool) automatically configure solver (default: true)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)
    bv.reflect (bool) create enode for every bit-vector term (default: true)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    candidate_models (bool) (default: false) create candidate models even when quantifier or theory reasoning is incomplete.
    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)
    clause_proof (bool) record a clausal proof (default: false)
    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)
    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)
    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)
    core.minimize (bool) minimize unsat core produced by SMT context (default: false)
    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)
    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)
    dack.eq (bool) enable dynamic ackermannization for transtivity of equalities (default: false)
    dack.factor (double) number of instance per conflict (default: 0.1)
    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)
    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)
    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)
    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)
    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)
    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    ematching (bool) E-Matching based quantifier instantiation (default: true)
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    induction (bool) enable generation of induction lemmas (default: false)
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    logic (symbol) logic used to setup the SMT solver (default: )
    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)
    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_depth (unsigned int) (default: 1024) maximum term depth.
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    max_rounds (unsigned int) (default: 4) maximum number of rounds.
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)
    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)
    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )
    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)
    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)
    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)
    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)
    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)
    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)
    propagate_eq (bool) (default: false) enable equality propagation from bounds.
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    pull_nested_quantifiers (bool) pull nested quantifiers (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))
    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)
    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)
    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)
    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)
    qi.profile (bool) profile quantifier instantiation (default: false)
    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)
    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)
    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)
    random_seed (unsigned int) random seed for the smt solver (default: 0)
    refine_inj_axioms (bool) refine injectivity axioms (default: true)
    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)
    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)
    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)
    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)
    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)
    rewrite_patterns (bool) rewrite patterns. (default: false)
    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)
    seq.use_derivatives (bool) dev flag (not for users) enable derivative based unfolding of regex (default: false)
    seq.use_unicode (bool) dev flag (not for users) enable unicode semantics (default: false)
    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)
    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)
    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)
    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)
    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)
    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)
    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)
    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)
    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)
    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)
    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)
    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)
    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)
    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)
    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)
    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)
    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)
    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)
    threads (unsigned int) maximal number of parallel threads. (default: 1)
    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)
- auflira builtin strategy for solving AUFLIRA problems.
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)
    arith.bounded_expansion (bool) box variables used in branch and bound into bound assumptions (default: false)
    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)
    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)
    arith.cheap_eqs (unsigned int) 0 - do not run, 1 - use tree, 2 - use table (default: 1)
    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)
    arith.eager_eq_axioms (bool) eager equality axioms (default: true)
    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)
    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)
    arith.ignore_int (bool) treat integer variables as real (default: false)
    arith.int_eq_branch (bool) branching using derived integer equations (default: false)
    arith.min (bool) minimize cost (default: false)
    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.branching (bool) branching on integer variables in non linear clusters, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.expp (bool) expensive patching (default: false)
    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)
    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)
    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)
    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)
    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)
    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)
    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)
    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)
    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.horner (bool) run horner's heuristic (default: true)
    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)
    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)
    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.nra (bool) call nra_solver when incremental lianirization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)
    arith.nl.order (bool) run order lemmas (default: true)
    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)
    arith.nl.tangents (bool) run tangent lemmas (default: true)
    arith.print_ext_var_names (bool) print external variable names (default: false)
    arith.print_stats (bool) print statistic (default: false)
    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)
    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine bounds (default: 2)
    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)
    arith.reflect (bool) reflect arithmetical operators to the congruence closure (default: true)
    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)
    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)
    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    array.extensional (bool) extensional array theory (default: true)
    array.weak (bool) weak array theory (default: false)
    auto_config (bool) automatically configure solver (default: true)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)
    bv.reflect (bool) create enode for every bit-vector term (default: true)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    candidate_models (bool) (default: false) create candidate models even when quantifier or theory reasoning is incomplete.
    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)
    clause_proof (bool) record a clausal proof (default: false)
    context_solve (bool) (default: false) solve equalities under disjunctions.
    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)
    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)
    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)
    core.minimize (bool) minimize unsat core produced by SMT context (default: false)
    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)
    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)
    dack.eq (bool) enable dynamic ackermannization for transtivity of equalities (default: false)
    dack.factor (double) number of instance per conflict (default: 0.1)
    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)
    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)
    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)
    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)
    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)
    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    ematching (bool) E-Matching based quantifier instantiation (default: true)
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    induction (bool) enable generation of induction lemmas (default: false)
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    ite_solver (bool) (default: true) use if-then-else solver.
    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    logic (symbol) logic used to setup the SMT solver (default: )
    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)
    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_depth (unsigned int) (default: 1024) maximum term depth.
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    max_rounds (unsigned int) (default: 4) maximum number of rounds.
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)
    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)
    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )
    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)
    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)
    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)
    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)
    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)
    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)
    propagate_eq (bool) (default: false) enable equality propagation from bounds.
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    pull_nested_quantifiers (bool) pull nested quantifiers (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))
    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)
    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)
    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)
    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)
    qi.profile (bool) profile quantifier instantiation (default: false)
    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)
    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)
    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)
    random_seed (unsigned int) random seed for the smt solver (default: 0)
    refine_inj_axioms (bool) refine injectivity axioms (default: true)
    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)
    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)
    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)
    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)
    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)
    rewrite_patterns (bool) rewrite patterns. (default: false)
    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)
    seq.use_derivatives (bool) dev flag (not for users) enable derivative based unfolding of regex (default: false)
    seq.use_unicode (bool) dev flag (not for users) enable unicode semantics (default: false)
    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)
    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations.
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)
    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)
    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)
    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)
    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)
    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)
    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)
    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)
    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)
    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)
    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)
    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)
    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)
    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)
    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)
    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)
    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)
    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)
    theory_solver (bool) (default: true) use theory solvers.
    threads (unsigned int) maximal number of parallel threads. (default: 1)
    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)
- aufnira builtin strategy for solving AUFNIRA problems.
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)
    arith.bounded_expansion (bool) box variables used in branch and bound into bound assumptions (default: false)
    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)
    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)
    arith.cheap_eqs (unsigned int) 0 - do not run, 1 - use tree, 2 - use table (default: 1)
    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)
    arith.eager_eq_axioms (bool) eager equality axioms (default: true)
    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)
    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)
    arith.ignore_int (bool) treat integer variables as real (default: false)
    arith.int_eq_branch (bool) branching using derived integer equations (default: false)
    arith.min (bool) minimize cost (default: false)
    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.branching (bool) branching on integer variables in non linear clusters, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.expp (bool) expensive patching (default: false)
    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)
    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)
    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)
    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)
    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)
    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)
    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)
    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)
    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.horner (bool) run horner's heuristic (default: true)
    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)
    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)
    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.nra (bool) call nra_solver when incremental lianirization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)
    arith.nl.order (bool) run order lemmas (default: true)
    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)
    arith.nl.tangents (bool) run tangent lemmas (default: true)
    arith.print_ext_var_names (bool) print external variable names (default: false)
    arith.print_stats (bool) print statistic (default: false)
    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)
    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine bounds (default: 2)
    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)
    arith.reflect (bool) reflect arithmetical operators to the congruence closure (default: true)
    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)
    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)
    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    array.extensional (bool) extensional array theory (default: true)
    array.weak (bool) weak array theory (default: false)
    auto_config (bool) automatically configure solver (default: true)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)
    bv.reflect (bool) create enode for every bit-vector term (default: true)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    candidate_models (bool) (default: false) create candidate models even when quantifier or theory reasoning is incomplete.
    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)
    clause_proof (bool) record a clausal proof (default: false)
    context_solve (bool) (default: false) solve equalities under disjunctions.
    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)
    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)
    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)
    core.minimize (bool) minimize unsat core produced by SMT context (default: false)
    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)
    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)
    dack.eq (bool) enable dynamic ackermannization for transtivity of equalities (default: false)
    dack.factor (double) number of instance per conflict (default: 0.1)
    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)
    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)
    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)
    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)
    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)
    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    ematching (bool) E-Matching based quantifier instantiation (default: true)
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    induction (bool) enable generation of induction lemmas (default: false)
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    ite_solver (bool) (default: true) use if-then-else solver.
    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    logic (symbol) logic used to setup the SMT solver (default: )
    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)
    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_depth (unsigned int) (default: 1024) maximum term depth.
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    max_rounds (unsigned int) (default: 4) maximum number of rounds.
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)
    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)
    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )
    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)
    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)
    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)
    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)
    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)
    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)
    propagate_eq (bool) (default: false) enable equality propagation from bounds.
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    pull_nested_quantifiers (bool) pull nested quantifiers (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))
    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)
    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)
    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)
    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)
    qi.profile (bool) profile quantifier instantiation (default: false)
    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)
    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)
    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)
    random_seed (unsigned int) random seed for the smt solver (default: 0)
    refine_inj_axioms (bool) refine injectivity axioms (default: true)
    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)
    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)
    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)
    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)
    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)
    rewrite_patterns (bool) rewrite patterns. (default: false)
    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)
    seq.use_derivatives (bool) dev flag (not for users) enable derivative based unfolding of regex (default: false)
    seq.use_unicode (bool) dev flag (not for users) enable unicode semantics (default: false)
    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)
    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations.
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)
    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)
    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)
    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)
    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)
    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)
    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)
    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)
    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)
    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)
    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)
    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)
    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)
    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)
    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)
    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)
    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)
    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)
    theory_solver (bool) (default: true) use theory solvers.
    threads (unsigned int) maximal number of parallel threads. (default: 1)
    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)
- lra builtin strategy for solving LRA problems.
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)
    arith.bounded_expansion (bool) box variables used in branch and bound into bound assumptions (default: false)
    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)
    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)
    arith.cheap_eqs (unsigned int) 0 - do not run, 1 - use tree, 2 - use table (default: 1)
    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)
    arith.eager_eq_axioms (bool) eager equality axioms (default: true)
    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)
    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)
    arith.ignore_int (bool) treat integer variables as real (default: false)
    arith.int_eq_branch (bool) branching using derived integer equations (default: false)
    arith.min (bool) minimize cost (default: false)
    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.branching (bool) branching on integer variables in non linear clusters, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.expp (bool) expensive patching (default: false)
    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)
    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)
    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)
    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)
    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)
    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)
    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)
    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)
    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.horner (bool) run horner's heuristic (default: true)
    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)
    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)
    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.nra (bool) call nra_solver when incremental lianirization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)
    arith.nl.order (bool) run order lemmas (default: true)
    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)
    arith.nl.tangents (bool) run tangent lemmas (default: true)
    arith.print_ext_var_names (bool) print external variable names (default: false)
    arith.print_stats (bool) print statistic (default: false)
    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)
    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine bounds (default: 2)
    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)
    arith.reflect (bool) reflect arithmetical operators to the congruence closure (default: true)
    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)
    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)
    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    array.extensional (bool) extensional array theory (default: true)
    array.weak (bool) weak array theory (default: false)
    auto_config (bool) automatically configure solver (default: true)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)
    bv.reflect (bool) create enode for every bit-vector term (default: true)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    candidate_models (bool) (default: false) create candidate models even when quantifier or theory reasoning is incomplete.
    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)
    clause_proof (bool) record a clausal proof (default: false)
    context_solve (bool) (default: false) solve equalities under disjunctions.
    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)
    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)
    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)
    core.minimize (bool) minimize unsat core produced by SMT context (default: false)
    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)
    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)
    dack.eq (bool) enable dynamic ackermannization for transtivity of equalities (default: false)
    dack.factor (double) number of instance per conflict (default: 0.1)
    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)
    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)
    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)
    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)
    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)
    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    eliminate_variables_as_block (bool) (default: true) eliminate variables as a block (true) or one at a time (false)
    ematching (bool) E-Matching based quantifier instantiation (default: true)
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    induction (bool) enable generation of induction lemmas (default: false)
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    ite_solver (bool) (default: true) use if-then-else solver.
    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    logic (symbol) logic used to setup the SMT solver (default: )
    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)
    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_depth (unsigned int) (default: 1024) maximum term depth.
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    max_rounds (unsigned int) (default: 4) maximum number of rounds.
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)
    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)
    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )
    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)
    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)
    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)
    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)
    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)
    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)
    propagate_eq (bool) (default: false) enable equality propagation from bounds.
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    pull_nested_quantifiers (bool) pull nested quantifiers (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    qe_nonlinear (bool) (default: false) enable virtual term substitution.
    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))
    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)
    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)
    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)
    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)
    qi.profile (bool) profile quantifier instantiation (default: false)
    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)
    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)
    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)
    random_seed (unsigned int) random seed for the smt solver (default: 0)
    refine_inj_axioms (bool) refine injectivity axioms (default: true)
    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)
    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)
    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)
    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)
    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)
    rewrite_patterns (bool) rewrite patterns. (default: false)
    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)
    seq.use_derivatives (bool) dev flag (not for users) enable derivative based unfolding of regex (default: false)
    seq.use_unicode (bool) dev flag (not for users) enable unicode semantics (default: false)
    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)
    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations.
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)
    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)
    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)
    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)
    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)
    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)
    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)
    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)
    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)
    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)
    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)
    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)
    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)
    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)
    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)
    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)
    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)
    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)
    theory_solver (bool) (default: true) use theory solvers.
    threads (unsigned int) maximal number of parallel threads. (default: 1)
    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)
- lia builtin strategy for solving LIA problems.
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)
    arith.bounded_expansion (bool) box variables used in branch and bound into bound assumptions (default: false)
    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)
    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)
    arith.cheap_eqs (unsigned int) 0 - do not run, 1 - use tree, 2 - use table (default: 1)
    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)
    arith.eager_eq_axioms (bool) eager equality axioms (default: true)
    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)
    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)
    arith.ignore_int (bool) treat integer variables as real (default: false)
    arith.int_eq_branch (bool) branching using derived integer equations (default: false)
    arith.min (bool) minimize cost (default: false)
    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.branching (bool) branching on integer variables in non linear clusters, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.expp (bool) expensive patching (default: false)
    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)
    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)
    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)
    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)
    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)
    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)
    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)
    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)
    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.horner (bool) run horner's heuristic (default: true)
    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)
    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)
    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.nra (bool) call nra_solver when incremental lianirization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)
    arith.nl.order (bool) run order lemmas (default: true)
    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)
    arith.nl.tangents (bool) run tangent lemmas (default: true)
    arith.print_ext_var_names (bool) print external variable names (default: false)
    arith.print_stats (bool) print statistic (default: false)
    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)
    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine bounds (default: 2)
    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)
    arith.reflect (bool) reflect arithmetical operators to the congruence closure (default: true)
    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)
    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)
    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    array.extensional (bool) extensional array theory (default: true)
    array.weak (bool) weak array theory (default: false)
    auto_config (bool) automatically configure solver (default: true)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)
    bv.reflect (bool) create enode for every bit-vector term (default: true)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    candidate_models (bool) (default: false) create candidate models even when quantifier or theory reasoning is incomplete.
    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)
    clause_proof (bool) record a clausal proof (default: false)
    context_solve (bool) (default: false) solve equalities under disjunctions.
    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)
    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)
    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)
    core.minimize (bool) minimize unsat core produced by SMT context (default: false)
    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)
    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)
    dack.eq (bool) enable dynamic ackermannization for transtivity of equalities (default: false)
    dack.factor (double) number of instance per conflict (default: 0.1)
    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)
    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)
    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)
    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)
    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)
    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    eliminate_variables_as_block (bool) (default: true) eliminate variables as a block (true) or one at a time (false)
    ematching (bool) E-Matching based quantifier instantiation (default: true)
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    induction (bool) enable generation of induction lemmas (default: false)
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    ite_solver (bool) (default: true) use if-then-else solver.
    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    logic (symbol) logic used to setup the SMT solver (default: )
    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)
    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_depth (unsigned int) (default: 1024) maximum term depth.
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    max_rounds (unsigned int) (default: 4) maximum number of rounds.
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)
    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)
    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )
    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)
    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)
    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)
    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)
    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)
    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)
    propagate_eq (bool) (default: false) enable equality propagation from bounds.
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    pull_nested_quantifiers (bool) pull nested quantifiers (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    qe_nonlinear (bool) (default: false) enable virtual term substitution.
    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))
    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)
    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)
    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)
    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)
    qi.profile (bool) profile quantifier instantiation (default: false)
    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)
    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)
    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)
    random_seed (unsigned int) random seed for the smt solver (default: 0)
    refine_inj_axioms (bool) refine injectivity axioms (default: true)
    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)
    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)
    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)
    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)
    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)
    rewrite_patterns (bool) rewrite patterns. (default: false)
    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)
    seq.use_derivatives (bool) dev flag (not for users) enable derivative based unfolding of regex (default: false)
    seq.use_unicode (bool) dev flag (not for users) enable unicode semantics (default: false)
    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)
    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations.
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)
    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)
    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)
    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)
    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)
    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)
    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)
    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)
    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)
    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)
    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)
    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)
    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)
    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)
    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)
    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)
    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)
    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)
    theory_solver (bool) (default: true) use theory solvers.
    threads (unsigned int) maximal number of parallel threads. (default: 1)
    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)
- lira builtin strategy for solving LIRA problems.
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)
    arith.bounded_expansion (bool) box variables used in branch and bound into bound assumptions (default: false)
    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)
    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)
    arith.cheap_eqs (unsigned int) 0 - do not run, 1 - use tree, 2 - use table (default: 1)
    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)
    arith.eager_eq_axioms (bool) eager equality axioms (default: true)
    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)
    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)
    arith.ignore_int (bool) treat integer variables as real (default: false)
    arith.int_eq_branch (bool) branching using derived integer equations (default: false)
    arith.min (bool) minimize cost (default: false)
    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.branching (bool) branching on integer variables in non linear clusters, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.expp (bool) expensive patching (default: false)
    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)
    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)
    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)
    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)
    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)
    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)
    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)
    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)
    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.horner (bool) run horner's heuristic (default: true)
    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)
    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)
    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.nra (bool) call nra_solver when incremental lianirization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)
    arith.nl.order (bool) run order lemmas (default: true)
    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)
    arith.nl.tangents (bool) run tangent lemmas (default: true)
    arith.print_ext_var_names (bool) print external variable names (default: false)
    arith.print_stats (bool) print statistic (default: false)
    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)
    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine bounds (default: 2)
    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)
    arith.reflect (bool) reflect arithmetical operators to the congruence closure (default: true)
    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)
    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)
    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    array.extensional (bool) extensional array theory (default: true)
    array.weak (bool) weak array theory (default: false)
    auto_config (bool) automatically configure solver (default: true)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)
    bv.reflect (bool) create enode for every bit-vector term (default: true)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    candidate_models (bool) (default: false) create candidate models even when quantifier or theory reasoning is incomplete.
    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)
    clause_proof (bool) record a clausal proof (default: false)
    context_solve (bool) (default: false) solve equalities under disjunctions.
    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)
    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)
    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)
    core.minimize (bool) minimize unsat core produced by SMT context (default: false)
    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)
    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)
    dack.eq (bool) enable dynamic ackermannization for transtivity of equalities (default: false)
    dack.factor (double) number of instance per conflict (default: 0.1)
    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)
    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)
    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)
    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)
    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)
    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    eliminate_variables_as_block (bool) (default: true) eliminate variables as a block (true) or one at a time (false)
    ematching (bool) E-Matching based quantifier instantiation (default: true)
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    induction (bool) enable generation of induction lemmas (default: false)
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    ite_solver (bool) (default: true) use if-then-else solver.
    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    logic (symbol) logic used to setup the SMT solver (default: )
    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)
    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_depth (unsigned int) (default: 1024) maximum term depth.
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    max_rounds (unsigned int) (default: 4) maximum number of rounds.
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)
    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)
    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )
    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)
    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)
    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)
    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)
    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)
    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)
    propagate_eq (bool) (default: false) enable equality propagation from bounds.
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    pull_nested_quantifiers (bool) pull nested quantifiers (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    qe_nonlinear (bool) (default: false) enable virtual term substitution.
    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))
    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)
    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)
    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)
    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)
    qi.profile (bool) profile quantifier instantiation (default: false)
    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)
    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)
    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)
    random_seed (unsigned int) random seed for the smt solver (default: 0)
    refine_inj_axioms (bool) refine injectivity axioms (default: true)
    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)
    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)
    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)
    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)
    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)
    rewrite_patterns (bool) rewrite patterns. (default: false)
    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)
    seq.use_derivatives (bool) dev flag (not for users) enable derivative based unfolding of regex (default: false)
    seq.use_unicode (bool) dev flag (not for users) enable unicode semantics (default: false)
    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)
    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations.
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)
    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)
    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)
    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)
    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)
    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)
    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)
    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)
    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)
    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)
    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)
    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)
    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)
    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)
    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)
    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)
    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)
    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)
    theory_solver (bool) (default: true) use theory solvers.
    threads (unsigned int) maximal number of parallel threads. (default: 1)
    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)
- skip do nothing tactic.
- fail always fail tactic.
- fail-if-undecided fail if goal is undecided.
- macro-finder Identifies and applies macros.
    elim_and (bool) (default: false) eliminate conjunctions during (internal) calls to the simplifier.
    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes.
    produce_models (bool) (default: false) model generation.
    produce_proofs (bool) (default: false) proof generation.
- quasi-macros Identifies and applies quasi-macros.
    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes.
    produce_models (bool) (default: false) model generation.
    produce_proofs (bool) (default: false) proof generation.
- ufbv-rewriter Applies UFBV-specific rewriting rules, mainly demodulation.
    max_memory (unsigned int) (default: infty) maximum amount of memory in megabytes.
    produce_models (bool) (default: false) model generation.
    produce_proofs (bool) (default: false) proof generation.
- bv builtin strategy for solving BV problems (with quantifiers).
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)
    arith.bounded_expansion (bool) box variables used in branch and bound into bound assumptions (default: false)
    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)
    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)
    arith.cheap_eqs (unsigned int) 0 - do not run, 1 - use tree, 2 - use table (default: 1)
    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)
    arith.eager_eq_axioms (bool) eager equality axioms (default: true)
    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)
    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)
    arith.ignore_int (bool) treat integer variables as real (default: false)
    arith.int_eq_branch (bool) branching using derived integer equations (default: false)
    arith.min (bool) minimize cost (default: false)
    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.branching (bool) branching on integer variables in non linear clusters, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.expp (bool) expensive patching (default: false)
    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)
    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)
    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)
    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)
    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)
    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)
    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)
    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)
    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.horner (bool) run horner's heuristic (default: true)
    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)
    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)
    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.nra (bool) call nra_solver when incremental lianirization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)
    arith.nl.order (bool) run order lemmas (default: true)
    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)
    arith.nl.tangents (bool) run tangent lemmas (default: true)
    arith.print_ext_var_names (bool) print external variable names (default: false)
    arith.print_stats (bool) print statistic (default: false)
    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)
    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine bounds (default: 2)
    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)
    arith.reflect (bool) reflect arithmetical operators to the congruence closure (default: true)
    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)
    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)
    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    array.extensional (bool) extensional array theory (default: true)
    array.weak (bool) weak array theory (default: false)
    auto_config (bool) automatically configure solver (default: true)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)
    bv.reflect (bool) create enode for every bit-vector term (default: true)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    candidate_models (bool) (default: false) create candidate models even when quantifier or theory reasoning is incomplete.
    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)
    clause_proof (bool) record a clausal proof (default: false)
    context_solve (bool) (default: false) solve equalities under disjunctions.
    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)
    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)
    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)
    core.minimize (bool) minimize unsat core produced by SMT context (default: false)
    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)
    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)
    dack.eq (bool) enable dynamic ackermannization for transtivity of equalities (default: false)
    dack.factor (double) number of instance per conflict (default: 0.1)
    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)
    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)
    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)
    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)
    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)
    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    ematching (bool) E-Matching based quantifier instantiation (default: true)
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_labels (bool) remove/ignore labels in the input formula, this option is ignored if proofs are enabled (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    induction (bool) enable generation of induction lemmas (default: false)
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    ite_solver (bool) (default: true) use if-then-else solver.
    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    logic (symbol) logic used to setup the SMT solver (default: )
    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)
    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    max_rounds (unsigned int) (default: 4) maximum number of rounds.
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)
    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)
    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )
    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)
    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)
    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)
    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)
    mode (symbol) NNF translation mode: skolem (skolem normal form), quantifiers (skolem normal form + quantifiers in NNF), full (default: skolem)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)
    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)
    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)
    produce_models (bool) (default: false) model generation.
    produce_proofs (bool) (default: false) proof generation.
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    pull_nested_quantifiers (bool) pull nested quantifiers (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))
    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)
    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)
    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)
    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)
    qi.profile (bool) profile quantifier instantiation (default: false)
    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)
    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)
    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)
    random_seed (unsigned int) random seed for the smt solver (default: 0)
    refine_inj_axioms (bool) refine injectivity axioms (default: true)
    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)
    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)
    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)
    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)
    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)
    rewrite_patterns (bool) rewrite patterns. (default: false)
    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)
    seq.use_derivatives (bool) dev flag (not for users) enable derivative based unfolding of regex (default: false)
    seq.use_unicode (bool) dev flag (not for users) enable unicode semantics (default: false)
    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)
    sk_hack (bool) hack for VCC (default: false)
    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations.
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)
    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)
    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)
    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)
    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)
    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)
    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)
    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)
    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)
    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)
    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)
    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)
    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)
    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)
    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)
    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)
    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)
    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)
    theory_solver (bool) (default: true) use theory solvers.
    threads (unsigned int) maximal number of parallel threads. (default: 1)
    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)
- ufbv builtin strategy for solving UFBV problems (with quantifiers).
    algebraic_number_evaluator (bool) simplify/evaluate expressions containing (algebraic) irrational numbers. (default: true)
    arith.auto_config_simplex (bool) force simplex solver in auto_config (default: false)
    arith.bounded_expansion (bool) box variables used in branch and bound into bound assumptions (default: false)
    arith.bprop_on_pivoted_rows (bool) propagate bounds on rows changed by the pivot operation (default: true)
    arith.branch_cut_ratio (unsigned int) branch/cut ratio for linear integer arithmetic (default: 2)
    arith.cheap_eqs (unsigned int) 0 - do not run, 1 - use tree, 2 - use table (default: 1)
    arith.dump_lemmas (bool) dump arithmetic theory lemmas to files (default: false)
    arith.eager_eq_axioms (bool) eager equality axioms (default: true)
    arith.enable_hnf (bool) enable hnf (Hermite Normal Form) cuts (default: true)
    arith.greatest_error_pivot (bool) Pivoting strategy (default: false)
    arith.ignore_int (bool) treat integer variables as real (default: false)
    arith.int_eq_branch (bool) branching using derived integer equations (default: false)
    arith.min (bool) minimize cost (default: false)
    arith.nl (bool) (incomplete) nonlinear arithmetic support based on Groebner basis and interval propagation, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.branching (bool) branching on integer variables in non linear clusters, relevant only if smt.arith.solver=2 (default: true)
    arith.nl.expp (bool) expensive patching (default: false)
    arith.nl.gr_q (unsigned int) grobner's quota (default: 10)
    arith.nl.grobner (bool) run grobner's basis heuristic (default: true)
    arith.nl.grobner_cnfl_to_report (unsigned int) grobner's maximum number of conflicts to report (default: 1)
    arith.nl.grobner_eqs_growth (unsigned int) grobner's number of equalities growth  (default: 10)
    arith.nl.grobner_expr_degree_growth (unsigned int) grobner's maximum expr degree growth (default: 2)
    arith.nl.grobner_expr_size_growth (unsigned int) grobner's maximum expr size growth (default: 2)
    arith.nl.grobner_frequency (unsigned int) grobner's call frequency (default: 4)
    arith.nl.grobner_max_simplified (unsigned int) grobner's maximum number of simplifications (default: 10000)
    arith.nl.grobner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.horner (bool) run horner's heuristic (default: true)
    arith.nl.horner_frequency (unsigned int) horner's call frequency (default: 4)
    arith.nl.horner_row_length_limit (unsigned int) row is disregarded by the heuristic if its length is longer than the value (default: 10)
    arith.nl.horner_subs_fixed (unsigned int) 0 - no subs, 1 - substitute, 2 - substitute fixed zeros only (default: 2)
    arith.nl.nra (bool) call nra_solver when incremental lianirization does not produce a lemma, this option is ignored when arith.nl=false, relevant only if smt.arith.solver=6 (default: true)
    arith.nl.order (bool) run order lemmas (default: true)
    arith.nl.rounds (unsigned int) threshold for number of (nested) final checks for non linear arithmetic, relevant only if smt.arith.solver=2 (default: 1024)
    arith.nl.tangents (bool) run tangent lemmas (default: true)
    arith.print_ext_var_names (bool) print external variable names (default: false)
    arith.print_stats (bool) print statistic (default: false)
    arith.propagate_eqs (bool) propagate (cheap) equalities (default: true)
    arith.propagation_mode (unsigned int) 0 - no propagation, 1 - propagate existing literals, 2 - refine bounds (default: 2)
    arith.random_initial_value (bool) use random initial values in the simplex-based procedure for linear arithmetic (default: false)
    arith.reflect (bool) reflect arithmetical operators to the congruence closure (default: true)
    arith.rep_freq (unsigned int) the report frequency, in how many iterations print the cost and other info (default: 0)
    arith.simplex_strategy (unsigned int) simplex strategy for the solver (default: 0)
    arith.solver (unsigned int) arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination 4 - utvpi, 5 - infinitary lra, 6 - lra solver (default: 6)
    arith_ineq_lhs (bool) rewrite inequalities so that right-hand-side is a constant. (default: false)
    arith_lhs (bool) all monomials are moved to the left-hand-side, and the right-hand-side is just a constant. (default: false)
    array.extensional (bool) extensional array theory (default: true)
    array.weak (bool) weak array theory (default: false)
    auto_config (bool) automatically configure solver (default: true)
    bit2bool (bool) try to convert bit-vector terms of size 1 into Boolean terms (default: true)
    blast_distinct (bool) expand a distinct predicate into a quadratic number of disequalities (default: false)
    blast_distinct_threshold (unsigned int) when blast_distinct is true, only distinct expressions with less than this number of arguments are blasted (default: 4294967295)
    blast_eq_value (bool) blast (some) Bit-vector equalities into bits (default: false)
    bv.enable_int2bv (bool) enable support for int2bv and bv2int operators (default: true)
    bv.reflect (bool) create enode for every bit-vector term (default: true)
    bv_extract_prop (bool) attempt to partially propagate extraction inwards (default: false)
    bv_ineq_consistency_test_max (unsigned int) max size of conjunctions on which to perform consistency test based on inequalities on bitvectors. (default: 0)
    bv_ite2id (bool) rewrite ite that can be simplified to identity (default: false)
    bv_le_extra (bool) additional bu_(u/s)le simplifications (default: false)
    bv_not_simpl (bool) apply simplifications for bvnot (default: false)
    bv_sort_ac (bool) sort the arguments of all AC operators (default: false)
    bvnot2arith (bool) replace (bvnot x) with (bvsub -1 x) (default: false)
    cache_all (bool) cache all intermediate results. (default: false)
    candidate_models (bool) (default: false) create candidate models even when quantifier or theory reasoning is incomplete.
    case_split (unsigned int) 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal, 6 - activity-based case split with theory-aware branching activity (default: 1)
    clause_proof (bool) record a clausal proof (default: false)
    context_solve (bool) (default: false) solve equalities under disjunctions.
    core.extend_nonlocal_patterns (bool) extend unsat cores with literals that have quantifiers with patterns that contain symbols which are not in the quantifier's body (default: false)
    core.extend_patterns (bool) extend unsat core with literals that trigger (potential) quantifier instances (default: false)
    core.extend_patterns.max_distance (unsigned int) limits the distance of a pattern-extended unsat core (default: 4294967295)
    core.minimize (bool) minimize unsat core produced by SMT context (default: false)
    core.validate (bool) [internal] validate unsat core produced by SMT context. This option is intended for debugging (default: false)
    dack (unsigned int) 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution (default: 1)
    dack.eq (bool) enable dynamic ackermannization for transtivity of equalities (default: false)
    dack.factor (double) number of instance per conflict (default: 0.1)
    dack.gc (unsigned int) Dynamic ackermannization garbage collection frequency (per conflict) (default: 2000)
    dack.gc_inv_decay (double) Dynamic ackermannization garbage collection decay (default: 0.8)
    dack.threshold (unsigned int)  number of times the congruence rule must be used before Leibniz's axiom is expanded (default: 10)
    delay_units (bool) if true then z3 will not restart when a unit clause is learned (default: false)
    delay_units_threshold (unsigned int) maximum number of learned unit clauses before restarting, ignored if delay_units is false (default: 32)
    dt_lazy_splits (unsigned int) How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy (default: 1)
    elim_and (bool) conjunctions are rewritten using negation and disjunctions (default: false)
    elim_ite (bool) eliminate ite in favor of and/or (default: true)
    elim_rem (bool) replace (rem x y) with (ite (>= y 0) (mod x y) (- (mod x y))). (default: false)
    elim_sign_ext (bool) expand sign-ext operator using concat and extract (default: true)
    elim_to_real (bool) eliminate to_real from arithmetic predicates that contain only integers. (default: false)
    ematching (bool) E-Matching based quantifier instantiation (default: true)
    eq2ineq (bool) expand equalities into two inequalities (default: false)
    expand_nested_stores (bool) replace nested stores by a lambda expression (default: false)
    expand_power (bool) expand (^ t k) into (* t ... t) if  1 < k <= max_degree. (default: false)
    expand_select_store (bool) replace a (select (store ...) ...) term by an if-then-else term (default: false)
    expand_store_eq (bool) reduce (store ...) = (store ...) with a common base into selects (default: false)
    expand_tan (bool) replace (tan x) with (/ (sin x) (cos x)). (default: false)
    fail_if_inconclusive (bool) (default: true) fail if found unsat (sat) for under (over) approximated goal.
    flat (bool) create nary applications for and,or,+,*,bvadd,bvmul,bvand,bvor,bvxor (default: true)
    gcd_rounding (bool) use gcd rounding on integer arithmetic atoms. (default: false)
    hi_div0 (bool) use the 'hardware interpretation' for division by zero (for bit-vector terms) (default: true)
    hoist_ite (bool) hoist shared summands under ite expressions (default: false)
    hoist_mul (bool) hoist multiplication over summation to minimize number of multiplications (default: false)
    ignore_labels (bool) remove/ignore labels in the input formula, this option is ignored if proofs are enabled (default: false)
    ignore_patterns_on_ground_qbody (bool) ignores patterns on quantifiers that don't mention their bound variables. (default: true)
    induction (bool) enable generation of induction lemmas (default: false)
    ite_extra_rules (bool) extra ite simplifications, these additional simplifications may reduce size locally but increase globally (default: false)
    ite_solver (bool) (default: true) use if-then-else solver.
    lemma_gc_strategy (unsigned int) lemma garbage collection strategy: 0 - fixed, 1 - geometric, 2 - at restart, 3 - none (default: 0)
    local_ctx (bool) perform local (i.e., cheap) context simplifications (default: false)
    local_ctx_limit (unsigned int) limit for applying local context simplifier (default: 4294967295)
    logic (symbol) logic used to setup the SMT solver (default: )
    macro_finder (bool) try to find universally quantified formulas that can be viewed as macros (default: false)
    max_conflicts (unsigned int) maximum number of conflicts before giving up. (default: 4294967295)
    max_degree (unsigned int) max degree of algebraic numbers (and power operators) processed by simplifier. (default: 64)
    max_memory (unsigned int) maximum amount of memory in megabytes (default: 4294967295)
    max_rounds (unsigned int) (default: 4) maximum number of rounds.
    max_steps (unsigned int) maximum number of steps (default: 4294967295)
    mbqi (bool) model based quantifier instantiation (MBQI) (default: true)
    mbqi.force_template (unsigned int) some quantifiers can be used as templates for building interpretations for functions. Z3 uses heuristics to decide whether a quantifier will be used as a template or not. Quantifiers with weight >= mbqi.force_template are forced to be used as a template (default: 10)
    mbqi.id (string) Only use model-based instantiation for quantifiers with id's beginning with string (default: )
    mbqi.max_cexs (unsigned int) initial maximal number of counterexamples used in MBQI, each counterexample generates a quantifier instantiation (default: 1)
    mbqi.max_cexs_incr (unsigned int) increment for MBQI_MAX_CEXS, the increment is performed after each round of MBQI (default: 0)
    mbqi.max_iterations (unsigned int) maximum number of rounds of MBQI (default: 1000)
    mbqi.trace (bool) generate tracing messages for Model Based Quantifier Instantiation (MBQI). It will display a message before every round of MBQI, and the quantifiers that were not satisfied (default: false)
    mode (symbol) NNF translation mode: skolem (skolem normal form), quantifiers (skolem normal form + quantifiers in NNF), full (default: skolem)
    mul2concat (bool) replace multiplication by a power of two into a concatenation (default: false)
    mul_to_power (bool) collpase (* t ... t) into (^ t k), it is ignored if expand_power is true. (default: false)
    pb.conflict_frequency (unsigned int) conflict frequency for Pseudo-Boolean theory (default: 1000)
    pb.learn_complements (bool) learn complement literals for Pseudo-Boolean theory (default: true)
    phase_selection (unsigned int) phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences, 7 - theory (default: 3)
    produce_models (bool) (default: false) model generation.
    produce_proofs (bool) (default: false) proof generation.
    pull_cheap_ite (bool) pull if-then-else terms when cheap. (default: false)
    pull_nested_quantifiers (bool) pull nested quantifiers (default: false)
    push_ite_arith (bool) push if-then-else over arithmetic terms. (default: false)
    push_ite_bv (bool) push if-then-else over bit-vector terms. (default: false)
    push_to_real (bool) distribute to_real over * and +. (default: true)
    qi.cost (string) expression specifying what is the cost of a given quantifier instantiation (default: (+ weight generation))
    qi.eager_threshold (double) threshold for eager quantifier instantiation (default: 10.0)
    qi.lazy_threshold (double) threshold for lazy quantifier instantiation (default: 20.0)
    qi.max_instances (unsigned int) maximum number of quantifier instantiations (default: 4294967295)
    qi.max_multi_patterns (unsigned int) specify the number of extra multi patterns (default: 0)
    qi.profile (bool) profile quantifier instantiation (default: false)
    qi.profile_freq (unsigned int) how frequent results are reported by qi.profile (default: 4294967295)
    qi.quick_checker (unsigned int) specify quick checker mode, 0 - no quick checker, 1 - using unsat instances, 2 - using both unsat and no-sat instances (default: 0)
    quasi_macros (bool) try to find universally quantified formulas that are quasi-macros (default: false)
    random_seed (unsigned int) random seed for the smt solver (default: 0)
    refine_inj_axioms (bool) refine injectivity axioms (default: true)
    relevancy (unsigned int) relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant (default: 2)
    restart.max (unsigned int) maximal number of restarts. (default: 4294967295)
    restart_factor (double) when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the current restart threshold (default: 1.1)
    restart_strategy (unsigned int) 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic (default: 1)
    restricted_quasi_macros (bool) try to find universally quantified formulas that are restricted quasi-macros (default: false)
    rewrite_patterns (bool) rewrite patterns. (default: false)
    seq.split_w_len (bool) enable splitting guided by length constraints (default: true)
    seq.use_derivatives (bool) dev flag (not for users) enable derivative based unfolding of regex (default: false)
    seq.use_unicode (bool) dev flag (not for users) enable unicode semantics (default: false)
    seq.validate (bool) enable self-validation of theory axioms created by seq theory (default: false)
    sk_hack (bool) hack for VCC (default: false)
    solve_eqs_max_occs (unsigned int) (default: infty) maximum number of occurrences for considering a variable for gaussian eliminations.
    som (bool) put polynomials in sum-of-monomials form (default: false)
    som_blowup (unsigned int) maximum increase of monomials generated when putting a polynomial in sum-of-monomials normal form (default: 10)
    sort_store (bool) sort nested stores when the indices are known to be different (default: false)
    sort_sums (bool) sort the arguments of + application. (default: false)
    split_concat_eq (bool) split equalities of the form (= (concat t1 t2) t3) (default: false)
    str.aggressive_length_testing (bool) prioritize testing concrete length values over generating more options (default: false)
    str.aggressive_unroll_testing (bool) prioritize testing concrete regex unroll counts over generating more options (default: true)
    str.aggressive_value_testing (bool) prioritize testing concrete string constant values over generating more options (default: false)
    str.fast_length_tester_cache (bool) cache length tester constants instead of regenerating them (default: false)
    str.fast_value_tester_cache (bool) cache value tester constants instead of regenerating them (default: true)
    str.fixed_length_naive_cex (bool) construct naive counterexamples when fixed-length model construction fails for a given length assignment (Z3str3 only) (default: true)
    str.fixed_length_refinement (bool) use abstraction refinement in fixed-length equation solver (Z3str3 only) (default: false)
    str.overlap_priority (double) theory-aware priority for overlapping variable cases; use smt.theory_aware_branching=true (default: -0.1)
    str.regex_automata_difficulty_threshold (unsigned int) difficulty threshold for regex automata heuristics (default: 1000)
    str.regex_automata_failed_automaton_threshold (unsigned int) number of failed automaton construction attempts after which a full automaton is automatically built (default: 10)
    str.regex_automata_failed_intersection_threshold (unsigned int) number of failed automaton intersection attempts after which intersection is always computed (default: 10)
    str.regex_automata_intersection_difficulty_threshold (unsigned int) difficulty threshold for regex intersection heuristics (default: 1000)
    str.regex_automata_length_attempt_threshold (unsigned int) number of length/path constraint attempts before checking unsatisfiability of regex terms (default: 10)
    str.string_constant_cache (bool) cache all generated string constants generated from anywhere in theory_str (default: true)
    str.strong_arrangements (bool) assert equivalences instead of implications when generating string arrangement axioms (default: true)
    string_solver (symbol) solver for string/sequence theories. options are: 'z3str3' (specialized string solver), 'seq' (sequence solver), 'auto' (use static features to choose best solver), 'empty' (a no-op solver that forces an answer unknown if strings were used), 'none' (no solver) (default: seq)
    theory_aware_branching (bool) Allow the context to use extra information from theory solvers regarding literal branching prioritization. (default: false)
    theory_case_split (bool) Allow the context to use heuristics involving theory case splits, which are a set of literals of which exactly one can be assigned True. If this option is false, the context will generate extra axioms to enforce this instead. (default: false)
    theory_solver (bool) (default: true) use theory solvers.
    threads (unsigned int) maximal number of parallel threads. (default: 1)
    threads.max_conflicts (unsigned int) maximal number of conflicts between rounds of cubing for parallel SMT (default: 400)
builtin probes:
- ackr-bound-probe A probe to give an upper bound of Ackermann congruence lemmas that a formula might generate.
- is-unbounded true if the goal contains integer/real constants that do not have lower/upper bounds.
- is-pb true if the goal is a pseudo-boolean problem.
- arith-max-deg max polynomial total degree of an arithmetic atom.
- arith-avg-deg avg polynomial total degree of an arithmetic atom.
- arith-max-bw max coefficient bit width.
- arith-avg-bw avg coefficient bit width.
- is-qflia true if the goal is in QF_LIA.
- is-qfauflia true if the goal is in QF_AUFLIA.
- is-qflra true if the goal is in QF_LRA.
- is-qflira true if the goal is in QF_LIRA.
- is-ilp true if the goal is ILP.
- is-qfnia true if the goal is in QF_NIA (quantifier-free nonlinear integer arithmetic).
- is-qfnra true if the goal is in QF_NRA (quantifier-free nonlinear real arithmetic).
- is-nia true if the goal is in NIA (nonlinear integer arithmetic, formula may have quantifiers).
- is-nra true if the goal is in NRA (nonlinear real arithmetic, formula may have quantifiers).
- is-nira true if the goal is in NIRA (nonlinear integer and real arithmetic, formula may have quantifiers).
- is-lia true if the goal is in LIA (linear integer arithmetic, formula may have quantifiers).
- is-lra true if the goal is in LRA (linear real arithmetic, formula may have quantifiers).
- is-lira true if the goal is in LIRA (linear integer and real arithmetic, formula may have quantifiers).
- is-qfufnra true if the goal is QF_UFNRA (quantifier-free nonlinear real arithmetic with other theories).
- is-qfbv-eq true if the goal is in a fragment of QF_BV which uses only =, extract, concat.
- is-qffp true if the goal is in QF_FP (floats).
- is-qffpbv true if the goal is in QF_FPBV (floats+bit-vectors).
- is-qffplra true if the goal is in QF_FPLRA.
- memory amount of used memory in megabytes.
- depth depth of the input goal.
- size number of assertions in the given goal.
- num-exprs number of expressions/terms in the given goal.
- num-consts number of non Boolean constants in the given goal.
- num-bool-consts number of Boolean constants in the given goal.
- num-arith-consts number of arithmetic constants in the given goal.
- num-bv-consts number of bit-vector constants in the given goal.
- produce-proofs true if proof generation is enabled for the given goal.
- produce-model true if model generation is enabled for the given goal.
- produce-unsat-cores true if unsat-core generation is enabled for the given goal.
- has-quantifiers true if the goal contains quantifiers.
- has-patterns true if the goal contains quantifiers with patterns.
- is-propositional true if the goal is in propositional logic.
- is-qfbv true if the goal is in QF_BV.
- is-qfaufbv true if the goal is in QF_AUFBV.
- is-quasi-pb true if the goal is quasi-pb.
"
