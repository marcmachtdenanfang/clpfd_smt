:- module(smt_compiler,[
        smt_compile_constraints/2, 
        ins/2
    ]).

:- use_module(library(lists)).
:- use_module(library(codesio)).    %% load write_to_codes/2
:- use_module(printer_ext).


:- dynamic smt_declaration_strings/1.
:- dynamic smt_assertion_strings/1.
:- op(700, xfx, ins).

/**********************************************************************************************
 * DISCLAIMER:
 * This module is a refactored and extended version of the codebase found in SWIPrologZ3. 
 * https://github.com/mistupv/SWIPrologZ3
 * 
 * By Germ√°n Vidal, http://personales.upv.es/gvidal/
 * MIT License
 *
 * The core concept of the compiler remains the same as with SWIPrologZ3.
 * It has been heavily extended.
 * 
 * The surrounding predicates regarding the program loop
 * as well as the Z3 interface have been completely reworked from the ground
 * and they have been modularized.
 * 
 * This module has been built with Sicstus Prolog in mind.
 * Making this module SWIProlog compatible probably requires setting
 * the double-quoted string flag to ISO (however that works)
 * or using auxiliary predicates to turn double-quoted strings
 * into lists of codes.
***********************************************************************************************/

relops([#=, #<, #>, #>=, #=<, #\=]).


/**********************************************************************************************
    smt_compile_constraints/2 translates a list of constraints to a list of codes representing an smtlib2 string.
    If there are multiple constraints a single "and" suffices to be used.
    Supported Constraints can be found at..........................

    The list of supported constraints is an extended version of SWiPrologZ3.
    The codebase was really good.
    Thus, rather than reinventing the wheel, we refactor it and extend it.
***********************************************************************************************/
smt_compile_constraints(Constraints, Constraint_Assertion_String) :-
    constr2smt(Constraints, SMT_Constraints_String),
    smt_assertion_header_tail(Constraints, Assert_Start, Assert_End),
    append(Assert_Start, SMT_Constraints_String, Temp1),
    append(Temp1, Assert_End, Constraint_Assertion_String).

smt_assertion_header_tail(Constraints, Assert_Start, Assert_End) :-
    (
        length(Constraints,1) 
            ->
                Assert_Start = "(assert ", Assert_End = ")"
            ;
                Assert_Start = "(assert (and ", Assert_End = "))"
    ).

/**********************************************************************************************
 * translate each constraint to SMT, one by one.
 * append each translated constraint to the accumulator.
***********************************************************************************************/
constr2smt(List, SMT) :-
    constr2smt_aux(List, [], SMT).
constr2smt_aux([Constraint], SMT_Acc, Result) :- 
    !, con2smt(Constraint, SMT_Constr),
    append(SMT_Constr, SMT_Acc, Result).
constr2smt_aux([Constraint|Tail], SMT_Acc, Result) :-
    con2smt(Constraint, SMT_Constr),
    append(" ", SMT_Constr, SMT_String), 
    append(SMT_String, SMT_Acc, Temp_Acc),
    constr2smt_aux(Tail, Temp_Acc, Result).


/**********************************************************************************************
 * In general:
 * If you extend con2smt/2 functionality. 
 * Beware when writing an extension for expressions rooted by binary operators, which can not use transf/3:
 * Make sure NOT to use the CUT operator ('!/0').
 * Otherwise pattern will not be matched to final con2smt that handles unsupported constraints. 
 * (In case your implementation leads to an error.)
 * Not using cut operator will make debugging easier. 
***********************************************************************************************/

/**********************************************************************************************
 * propositional Operator "P #\ Q" with arity 2 is equivalent to xor (confusingly)!
***********************************************************************************************/
con2smt(#\(P,Q), SMT) :-
    !,
    con2smt(P, SMT1),
    con2smt(Q, SMT2),
    append("(xor ", SMT1, T1),
    append(T1, SMT2, T2),
    append(T2, ")", SMT).


/**********************************************************************************************
 * bool_constraint/2 is a compund term generated by to_smtlib/1.
 * When to_smtlib/1 encounters bool_and/2, bool_or/2 or bool_xor/2 
 * it will generate a reified constraint which is
 *     bool_constraint(Lits, Op) #<=> Lit, where Op is in [#\/, #/\, xor],
 *     xor should be #\ but that would introduce another case to be handled (see above),
 *     thus I selected xor.
 * 
 * E.g.:
 *     to_smtlib(bool_or(Lits, Lit))
 *         => bool_constraint(Lits, #\/) #<=> Lit
***********************************************************************************************/
con2smt(bool_constraint(Lits, Operator), SMT) :-
    !,
    transf(Operator, OpLeft, OpRight),
    (   foreach(Var, Lits), 
        foreach(C_SMT, Lits_Constraints) 
    do  con2smt(Var, VarSMT), 
        append("(= ", VarSMT, T1),
        append(T1, " 1)", C_SMT)
    ),
    (foreach(Lits_Constraint, Lits_Constraints), foreach(Temp, Result) do append(" ", Lits_Constraint, Temp)),      %% prepend all variable codes with blanks
    append(Result, ResultFlat),
    append(OpLeft, ResultFlat, Temp1),
    append(Temp1, OpRight, SMT).


/**********************************************************************************************
 * translate min(A, B), max(A,B) to ite-expressions. (ite = if-then-else)
 * min(A, B) = (ite (< A B) A B);
 * max(A, B) = (ite (> A B) A B)
***********************************************************************************************/
con2smt(min(Left, Right), SMT) :-
    !,
    con2smt(Left, SMTLeft),
    con2smt(Right, SMTRight),
    
    append(SMTLeft, " ", T0),
    append(T0, SMTRight, A_blank_B),
    
    append("(ite (< ", A_blank_B, T1),
    append(T1, ") ", T2),
    append(T2, A_blank_B, T3),
    append(T3, ")", SMT).
con2smt(max(Left, Right), SMT) :-
    !,
    con2smt(Left, SMTLeft),
    con2smt(Right, SMTRight),
    
    append(SMTLeft, " ", T0),
    append(T0, SMTRight, A_blank_B),
    
    append("(ite (> ", A_blank_B, T1),
    append(T1, ") ", T2),
    append(T2, A_blank_B, T3),
    append(T3, ")", SMT).

/**********************************************************************************************
 * We ignore extra Options for now. 
 * Makes it possible to use to_smtlib/1 without extra changes of code.
 * UPDATE: The extra options for all_distinct/2, all_different/2 are handled in to_smtlib/1.
***********************************************************************************************/
/*con2smt(Term, SMT) :-
    ( functor(Term, all_distinct, 2) ; functor(Term, all_different, 2)),
    !,
    Term =.. [Predicate, Vars, _Options],
    NewTerm =.. [Predicate, Vars],
    con2smt(NewTerm, SMT).*/
con2smt(Term, SMT) :-
    functor(Term, scalar_product, 5),
    !,
    Term =.. [scalar_product, Coeffs, Xs, RelOp, Value, _Options],
    NewTerm =.. [scalar_product, Coeffs, Xs, RelOp, Value],
    con2smt(NewTerm, SMT).

/**********************************************************************************************
 * expression rooted by all_distinct/1 or all_different/1
***********************************************************************************************/
con2smt(Term, SMT) :-
    ( functor(Term, all_distinct, _Arity) ; functor(Term, all_different, _Arity) ),
    !,
    arg(1, Term, Arg),
    (foreach(Var, Arg), foreach(VarSMT, VarCodes) do con2smt(Var, VarSMT)),                                 %% con2smt/2 returns a codelist when called on a variable
    (foreach(VarCode, VarCodes), foreach(VarCodeBlank, Result) do append(" ", VarCode, VarCodeBlank)),      %% prepend all variable codes with blanks
    append(Result, ResultFlat),
    append("(distinct", ResultFlat, Temp),
    append(Temp, ")", SMT), 
    %writes(SMT), nl,% debuging purposes only.
    true.



/**********************************************************************************************
 * expression rooted by scalar_product(+Coeffs, +Xs, +RelOp, ?Value),
 * Coeffs is a list of Integers, Xs is a list of Vars or Integers, RelOp is one in {#=, #<, #>, #=<, #>=, #\=}
 * 
 * e.g. Find all solutions for X*3+Y*4+Z*5 #= 100, for X,Y,Z in 0..100
 * ?- length(L,3),  domain(L, 0,100), 
 *    scalar_product([3,4,5], L, #=,100), 
 *    findall(L, labeling([], L), XL), 
 *    length(XL,Sol).
 ***********************************************************************************************/
con2smt(scalar_product(Coeffs, Xs, RelOp, Value), SMT) :-
    relops(RelOps), memberchk(RelOp, RelOps), 
    transf(+, OpLeftPlus, OpRightPlus),
    transf(RelOp, RelOpLeft, RelOpRight),
    con2smt(Value, Value_SMT),
    scalar_product_aux(Coeffs, Xs, "", Coeffs_times_Xs),
    append(OpLeftPlus, Coeffs_times_Xs, Temp1),
    append(Temp1, OpRightPlus, Temp2),
    append(RelOpLeft, Temp2, Temp3),
    append(Temp3, Value_SMT, Temp4),
    append(Temp4, RelOpRight, SMT), !.


/**********************************************************************************************
 * expression rooted by sum(+Xs, +RelOp, ?Value),
 * Xs is a list of integers or domain variables. RelOp as seen above.
 ***********************************************************************************************/
con2smt(sum(Xs, RelOp, Value), SMT) :-
    relops(RelOps), memberchk(RelOp, RelOps),
    transf(+, OpLeftPlus, OpRightPlus),
    transf(RelOp, RelOpLeft, RelOpRight),
    con2smt(Value, Value_SMT),
    sum_aux(Xs, "", Xs_String),
    append(OpLeftPlus, Xs_String, Temp1),
    append(Temp1, OpRightPlus, Temp2),
    append(RelOpLeft, Temp2, Temp3),
    append(Temp3, Value_SMT, Temp4),
    append(Temp4, RelOpRight, SMT), !.


/**********************************************************************************************
 * expression rooted by ins/2
***********************************************************************************************/
con2smt(ins(Vars, Range), SMT) :-
    ins_aux(Vars, Range, "", SMT), !.


/**********************************************************************************************
 * Alternative:
 *  call range_to_fdset(+Range, -Set), and then call translation of con2smt "Var in_set Set"
 * expression rooted by in/2.
 * ?X in +ConstantRange
 * ConstantRange is defined in https://sicstus.sics.se/sicstus/docs/latest4/html/sicstus.html/Syntax-of-Indexicals.html
 ***********************************************************************************************/
con2smt(in(Var, Range), SMT) :-
    clpfd:range_to_fdset(Range, FD_Set),
    Term =.. [in_set, Var, FD_Set],
    con2smt(Term, SMT), !.

% con2smt(in(Var, Range), SMT) :-    
%     con2smt(Var, Var_Codes),
%     in_aux(Var_Codes, Range, "", SMT), !.

con2smt(in_set(Var, Set), SMT) :-
    con2smt(Var, Var_Codes),
    in_set_aux(Var_Codes, Set, "", Temp_SMT), !,
    length(Set, Length),
    (
        Length > 1 
            -> 
                % experimental: use xor rather than or. Seems to yield better performance. Compare benchmarks/primesums/primesums_clpfd_z3.pl => ?- loop(5,P,Milliseconds). => 6 vs 18 seconds!
                append("(xor ", Temp_SMT, Temp1), 
                append(Temp1, ")", SMT) 
            ; 
                Temp_SMT = SMT
    ).

% smt_compiler:constr2smt([domain(['VAR'('_891'), 'VAR'('_892')],1,3)], SMT), writes(SMT).
% smt_compiler:constr2smt(['VAR'('_891') in_set [[1|3],[5|6],[8|sup]]],SMT), writes(SMT).
% smt_compiler:constr2smt(['VAR'('_891') in_set [[inf|sup]]],SMT), writes(SMT).
% smt_compiler:constr2smt(['VAR'('_891') in_set [[inf|sup],[1|3]]],SMT), writes(SMT).


/**********************************************************************************************
 * expression rooted by domain/3 
***********************************************************************************************/
con2smt(domain(_, inf, sup), "") :- !.
con2smt(domain(Vars, inf, Upper_Bound), SMT) :-
    domain_aux(Vars, Upper_Bound, #=<, "", Upper_Bound_String),
    append("(and ", Upper_Bound_String, Temp1),
    append(Temp1, ")", SMT).
con2smt(domain(Vars, Lower_Bound, sup), SMT) :-
    domain_aux(Vars, Lower_Bound, #>=, "", Lower_Bound_String),
    append("(and ", Lower_Bound_String, Temp1),
    append(Temp1, ")", SMT).
con2smt(domain(Vars, Lower_Bound, Upper_Bound), SMT) :-
    !,
    domain_aux(Vars, Lower_Bound, #>=, "", Lower_Bound_String),
    domain_aux(Vars, Upper_Bound, #=<, "", Upper_Bound_String),
    append(Lower_Bound_String, Upper_Bound_String, Bounds_String),
    append("(and ", Bounds_String, Temp1), 
    append(Temp1, ")", SMT).


/**********************************************************************************************
 * expression rooted by the #<= (#<== for SWI Prolog) operator (logical implication) 
 * A #=> B is equal to B #<= A. 
 * SMTlib only has a right associative version of this operator (=>). 
 * In order to reduce code redundancy we thus call con2smt((A #=> B), SMT).
***********************************************************************************************/
con2smt(Term, SMT) :-
    functor(Term, #<=, 2), !,
    Term =.. [_Op, LeftArg, RightArg],
    NewTerm =.. [#=>, RightArg, LeftArg],
    con2smt(NewTerm, SMT).


/**********************************************************************************************
 * Expression rooted by a binary operator 
 * Do not use cut operator, in case of unimplemented binary constraint.
***********************************************************************************************/
con2smt(Term, SMT) :-
    functor(Term, F, 2),
    transf(F, OpLeft, OpRight),
    arg(1, Term, Arg1), con2smt(Arg1, SMTLeft),
    arg(2, Term, Arg2), con2smt(Arg2, SMTRight),
    append(OpLeft, SMTLeft, Temp1), 
    append(Temp1, " ", Temp2),
    append(Temp2, SMTRight, Temp3), 
    append(Temp3, OpRight, SMT), !.


/**********************************************************************************************
 * Expression rooted by a unary operator ("-", "abs", "\+") 
 * Do not use cut operator, in case of unimplemented unary constraint. 
 * => use it after everything went right...
***********************************************************************************************/
con2smt(T, SMT) :-
    functor(T, F, 1), transf(F, OpLeft, OpRight),
    arg(1, T, Arg1), 
    con2smt(Arg1, SMT1),
    append(OpLeft, SMT1, Temp),
    append(Temp, OpRight, SMT), !.

/* integer */
con2smt(Term, SMT) :-
    integer(Term), !,
    write_to_codes(Term, SMT).
/* variable */
con2smt(Term, SMT) :-
    functor(Term, 'VAR', 1),!,
    arg(1, Term, Arg),
    write_to_codes(Arg, SMT).
/* unsupported term */
con2smt(T, _SMT) :-
    throw(unsupported_constraint(T)).


/*****************************************************************************************
 * Auxiliary Predicates 
******************************************************************************************/

domain_aux([], _, _, SMT, SMT) :- !.
domain_aux([Var|Tail], Bound, Operator, Accumulator, SMT) :-
    Term =.. [Operator, Var, Bound],
    con2smt(Term, Temp_String),
    append(Temp_String, Accumulator, Temp_Acc),
    domain_aux(Tail, Bound, Operator, Temp_Acc, SMT).


ins_aux([], _, SMT, SMT) :- !.
ins_aux([Var|Tail], Range, Accumulator, SMT) :-
    clpfd:range_to_fdset(Range, FD_Set),
    Term =.. [in_set, Var, FD_Set],
    con2smt(Term, Temp_String),
    append(Temp_String, Accumulator, Temp_Acc),
    ins_aux(Tail, Range, Temp_Acc, SMT).
    

/* ConstantSet */
in_aux(Var_Code, Range, Accumulator, SMT) :-
    functor(Range, {}, 1), !,
    Range =.. [{}, Arg],
    tuple_to_list(Arg, Integers),
    
    % retrieve a String of "(= Var Int1)(= Var Int2)..." for IntN in Range and Var described by Var_Code
    (   foreach(Int, Integers), 
        foreach(T4, Eq_Strings), 
        param(Var_Code)
    do  name(Int, Int_Codes), 
        append("(= ", Var_Code, T1),
        append(T1, " ", T2),
        append(T2, Int_Codes, T3),
        append(T3, ")", T4)
    ), 
    append(Eq_Strings, Temp_String),
    append("(or ", Temp_String, Temp), 
    append(Temp, ")", S),
    append(S, Accumulator, SMT).
in_aux(Var_Code, '..'(Lower, Upper), Accumulator, SMT) :-
    /* Constant..Constant, easier to just call con2smt on in_set/2 */
    !, name(Atom, Var_Code),
    Var =.. ['VAR', Atom],
    Term = in_set(Var, [[Lower|Upper]]),
    con2smt(Term, SMT_Temp),
    append(SMT_Temp, Accumulator, SMT).
in_aux(Var_Code, Left /\ Right, Accumulator, SMT) :-
    /* Intersection of two ConstantRanges. Naive translation, without any optimization. */
    !, 
    transf(/\, OpLeft, OpRight),
    in_aux(Var_Code, Left, "", SMT_Left),
    in_aux(Var_Code, Right, SMT_Left, SMT_Both),
    append(OpLeft, SMT_Both, Temp1),
    append(Temp1, OpRight, Temp2),
    append(Temp2, Accumulator, SMT).
in_aux(Var_Code, Left \/ Right, Accumulator, SMT) :-
    /* Union of two ConstantRanges. */
    !, 
    transf(\/, OpLeft, OpRight),
    in_aux(Var_Code, Left, "", SMT_Left),
    in_aux(Var_Code, Right, SMT_Left, SMT_Both),
    append(OpLeft, SMT_Both, Temp1),
    append(Temp1, OpRight, Temp2),
    append(Temp2, Accumulator, SMT).
in_aux(Var_Code, \Range, Accumulator, SMT) :-
    /* Complement of a ConstantRange. */
    transf(\, OpLeft, OpRight),
    in_aux(Var_Code, Range, "", SMT1),
    append(OpLeft, SMT1, SMT2),
    append(SMT2, OpRight, SMT3),
    append(SMT3, Accumulator, SMT).

tuple_to_list((E, Tuple_Tail), [E|List]) :-
    !, tuple_to_list(Tuple_Tail, List).
tuple_to_list((E), [E]).


/* Range = 1..3 is equivalent to Set = [[1|3]] */
in_set_aux(_, [], SMT, SMT) :- !.
in_set_aux(Var_Code, [[inf|sup]|Tail], Accumulator, SMT) :-
    !, in_set_aux(Var_Code, Tail, Accumulator, SMT).
in_set_aux(Var_Code, [[inf|Upper]|Tail], Accumulator, SMT) :-
    !, transf(=<, LoE_OpLeft, LoE_OpRight),
    con2smt(Upper, Upper_Int_String),
    in_set_aux(LoE_OpLeft, LoE_OpRight, Var_Code, Upper_Int_String, Upper_Bound_String),
    append(Upper_Bound_String, Accumulator, Temp_Acc),
    in_set_aux(Var_Code, Tail, Temp_Acc, SMT).
in_set_aux(Var_Code, [[Lower|sup]|Tail], Accumulator, SMT) :-
    !, transf(>=, GoE_OpLeft, GoE_OpRight),
    con2smt(Lower, Lower_Int_String),
    in_set_aux(GoE_OpLeft, GoE_OpRight, Var_Code, Lower_Int_String, Lower_Bound_String),
    append(Lower_Bound_String, Accumulator, Temp_Acc),
    in_set_aux(Var_Code, Tail, Temp_Acc, SMT).
in_set_aux(Var_Code, [[Int|Int]|Tail], Accumulator, SMT) :-
    !, transf(=, OpLeft, OpRight),
    con2smt(Int, Int_String),
    in_set_aux(OpLeft, OpRight, Var_Code, Int_String, Equal_String),
    append(Equal_String, Accumulator, Temp_Acc),
    in_set_aux(Var_Code, Tail, Temp_Acc, SMT).
in_set_aux(Var_Code, [[Lower|Upper]|Tail], Accumulator, SMT) :-
    !, transf(>=, GoE_OpLeft, GoE_OpRight),
    con2smt(Lower, Lower_Int_String),
    in_set_aux(GoE_OpLeft, GoE_OpRight, Var_Code, Lower_Int_String, Lower_Bound_String),
    transf(=<, LoE_OpLeft, LoE_OpRight),
    con2smt(Upper, Upper_Int_String),
    in_set_aux(LoE_OpLeft, LoE_OpRight, Var_Code, Upper_Int_String, Upper_Bound_String),
    append(Lower_Bound_String, Upper_Bound_String, Bounds_String), 
    append("(and ", Bounds_String, Temp3), 
    append(Temp3, ")", Temp_SMT),
    append(Temp_SMT, Accumulator, Temp_Acc),
    in_set_aux(Var_Code, Tail, Temp_Acc, SMT).
in_set_aux(OpLeft, OpRight, Var_Code, Int, String) :-
    append(OpLeft, Var_Code, Temp1),
    append(Temp1, " ", Temp2),
    append(Temp2, Int, Temp3),
    append(Temp3, OpRight, String).


/**********************************************************************************************
 * scalar_product_aux(+Coeffs, +Xs, +Accumulator, -SMT)
 * Coeffs is a list of integers
 * Xs is a list of Vars, which are grounded to 'VAR'(some_address). some_adress is an atom, e.g. '_891'
 * Accumulator is an empty list or "" (equivalent to empty list).
 *
 * SMT = "(* Coeff_1 X_1) ... (* Coeff_N X_N)"
***********************************************************************************************/
scalar_product_aux([], [], SMT, SMT) :- !.
scalar_product_aux([Coeff|CTail], [X|XTail], Accumulator, SMT) :-
    con2smt(Coeff, C_SMT),
    con2smt(X, X_SMT),
    transf(*, OpLeft, OpRight),
    append(OpLeft, C_SMT, Temp1),
    append(Temp1, " ", Temp2),
    append(Temp2, X_SMT, Temp3),
    append(Temp3, OpRight, Temp4),
    append(Temp4, Accumulator, Temp_Acc),
    scalar_product_aux(CTail, XTail, Temp_Acc, SMT).
    

sum_aux([], SMT, SMT) :- !.
sum_aux([X|Tail], Accumulator, SMT) :-
    con2smt(X, X_SMT),
    append(" ", X_SMT, Temp1),
    append(Temp1, Accumulator, Temp_Acc),
    sum_aux(Tail, Temp_Acc, SMT).


transf(=,       "(= ",       ")")   :- !.
transf(is,      "(= ",       ")")   :- !.
transf(\=,      "(not (= ",  "))")  :- !.
transf(#=,      "(= ",       ")")   :- !.
transf(#\=,     "(not (= ",  "))")  :- !.
transf(*,       "(* ",       ")")   :- !.
transf(+,       "(+ ",       ")")   :- !.
transf(-,       "(- ",       ")")   :- !.
transf(>,       "(> ",       ")")   :- !.
transf(<,       "(< ",       ")")   :- !.
transf(>=,      "(>= ",      ")")   :- !.
transf(=<,      "(<= ",      ")")   :- !.
transf(#>,      "(> ",       ")")   :- !.
transf(#<,      "(< ",       ")")   :- !.
transf(#>=,     "(>= ",      ")")   :- !.
transf(#=<,     "(<= ",      ")")   :- !.
transf(/\,      "(and ",     ")")   :- !.
transf(\/,      "(or ",      ")")   :- !.
transf(\,       "(not ",     ")")   :- !.
transf(#/\,     "(and ",     ")")   :- !.  
transf(#\/,     "(or ",      ")")   :- !.  
transf(#\,      "(not ",     ")")   :- !.
transf(#<=>,    "(= ",       ")")   :- !.  %% Z3: "Bi-implications are represented using equality =."
transf(#=>,     "(=> ",      ")")   :- !.
% transf(#<=,   ?,           ?)     :- !.  %% handled specifically
transf(xor,     "(xor ",     ")")   :- !.
transf(abs,     "(abs ",     ")")   :- !.
transf(mod,     "(mod ",     ")")   :- !.
transf(rem,     "(rem ",     ")")   :- !.
transf(div,     "(div ",     ")")   :- !.
transf(/,       "(/ ",       ")")   :- !.
transf(//,      "(/ ",       ")")   :- !.

